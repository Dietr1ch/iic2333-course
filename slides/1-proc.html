<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>1 - Administración de Procesos</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta content="Dietrich Daroch" name="author" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/reveal.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/theme/white.min.css" id="theme" rel="stylesheet" /><link href="https://github.com/frederickf/presentable/raw/master/src/presentable.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/css/zenburn.min.css" rel="stylesheet" /></head><body><div class="reveal"><div class="slides"><section><h2>Sistemas Operativos y Redes</h2><h1>1 - Administración de Procesos</h1><p>Semestre 1/2016</p><p>Cristian Ruz - cruz@ing.puc.cl</p><p style="padding-top:4em;">Departamento de Ciencia de la Computación</p><p>Pontificia Universidad Católica de Chile</p></section><section><h2>Procesos</h2></section><section><h2>¿Qué es un Proceso?</h2><section><p class="fragment">Un programa en ejecución</p><blockquote class="fragment">Proceso = Código + Recursos</blockquote><ul><li class="fragment">El código del programa</li><li class="fragment">Los recursos de la ejecución</li><ul><li class="fragment">Memoria, archivos</li><li class="fragment">Sockets, Dispositivos, Librerías (...)</li></ul></ul></section></section><section><h2>Composición y representación</h2><section><p>¿Qué hay en un Proceso?</p><ul><li class="fragment">Código (<em>.text</em>, información estática)</li><li class="fragment">Program Counter (PC) + Registros</li><li class="fragment">Stack (de funciones)</li><p class="fragment">Cada item del stack representa una función, por lo que tiene:</p><ul><li class="fragment">Parámetros</li><li class="fragment">Variables locales</li><li class="fragment">Lugar de retorno (donde estaba la ejecución anterior, PC)</li></ul><li class="fragment">Datos (<em>.data</em>)</li><ul><li class="fragment">Variables globales</li></ul><li class="fragment">Heap</li><p class="fragment">Memoria asignada dinámicamente (durante la ejecución)</p></ul><img src="../images/figures/01-3_01.pdf.png" /></section></section><section id="states"><h2>Estados</h2><section id="states-inside"><p>Un proceso en ejecución puede cambiar de estado</p><ul><li class="fragment"><b>[New]       </b>: En creación</li><li class="fragment"><b>[Running]   </b>: En ejecución</li><li class="fragment"><b>[Waiting]   </b>: Esperando (I/O, signal)</li><li class="fragment"><b>[Ready]     </b>: Listo para ejecutar. Esperando asignación de CPU</li><li class="fragment"><b>[Terminated]</b>: Ejecución terminada</li></ul></section><section id="states-automata"><img src="../images/figures/01-3_02.pdf.png" /><p class="fragment">¡Un autómata!</p></section><section id="states-status"><p>¿Cómo averiguo el estado de un proceso?</p><div class="fragment"><p>Desde un terminal</p><pre><code class="hljs lang-bash">$ htop || top || ps aux</code></pre></div><div class="fragment"><p>En C</p><pre><code class="hljs lang-c">#include "sys/types.h"
#include "sys/wait.h"
/* ... */
int status;
pid_t return_pid = waitpid(process_id, /*out*/ &status, WNOHANG);

switch(return_pid) {
  case 0:
    /* Still running */
  case process_id:
    /* Child terminated. Exit status in 'status' */
  case -1:
  default:
    /* Error */
}</code></pre></div><div class="fragment"><p>O con un Administrador de Procesos</p></div></section></section><section id="repr"><h3>Representación de Procesos</h3><section id="repr-PCB"><p>¿Cómo represento un proceso?</p><p class="fragment">Process Control Block (PCB)</p><ul><li class="fragment">Estado</li><li class="fragment">Identificador (PID)</li><li class="fragment">Program Counter (PC)</li><li class="fragment">Registros de CPU: <em>estado de ejecución</em></li><li class="fragment">Información de <em>scheduling</em>: prioridades, tipo de cola, &hellip;</li><li class="fragment">Información de memoria: límites, tabla de páginas/segmentos, &hellip;</li><li class="fragment">Contabilidad (<em>accounting</em>)</li><li class="fragment">Información de I/O: archivos y dispositivos abiertos, &hellip;</li></ul><img src="../images/figures/01-3_03.pdf.png" /></section><section id="repr-contextSwitch"><p>El cambio de procesos se conoce como <strong>Context Switch</strong></p><img width="50%" src="../images/figures/01-3_04.pdf.png" /></section></section><section id="creation"><h2>Creando procesos</h2><section id="creation-0"><p>Creación de procesos: ¿el huevo o la gallina?</p><ul><li class="fragment"> ¿Quién crea un proceso?...     <span class="fragment"> otro proceso</span></li><li class="fragment"> ¿Quién crea ese otro proceso?  <span class="fragment"> otro proceso</span></li><li class="fragment"> ¿Quién crea ese otro proceso?  <span class="fragment"> otro proceso&hellip;</span></li></ul><p class="fragment">Existe un proceso llamado 'init' que es construido durante la inicialización del kernel. Usualmente tienen asignado el ProcessID 1.</p><!--Salvo Windows por supuesto, que usa el 4.--><ul><li class="fragment">Linux: systemd, initV, upstart</li><li class="fragment">MacOS X: launchd</li><li class="fragment">Windows: InitialSystemProcess, System</li></ul></section><section id="creation-tree"><p>Como todos los procesos tienen un padre, forman un árbol de procesos</p><pre><code class="hljs">$ pstree --show-pids</code></pre><pre><code class="hljs">systemd(1)─┬─crond(572)───rsync(984)
           ├─dbus-daemon(563)
           ├─konsole(30672)───zsh(30675)───tmux(11098)
           ├─systemd(756)─┬─ncmpcpp(759)
           │              └─emacs(773)─┬─aspell(798)
           │                           └─{gmain}(774)
           ├─systemd-logind(573)
           └─tmux(11100)─┬─zsh(9853)
                         └─zsh(11221)───vim(13615)</code></pre></section><section id="creation-init"><p>Si un proceso crea a un proceso (hijo).</p><ul><li class="fragment">¿Quién sigue ejecutando? (modos de ejecución)</li><ul><li class="fragment">Padre e hijo continúan ejecutando concurrentemente</li><li class="fragment">Padre espera que algunos o todos sus hijos terminen</li></ul><li class="fragment">¿Qué personalidad tiene el hijo? (modos de espacio de direcciones)</li><ul><li class="fragment">El hijo es un duplicado <a href="http://linux.die.net/man/2/fork">casi</a> exacto del padre (secciones <strong>.text</strong>, <strong>.data</strong> y el stack son copiados)</li><li class="fragment">El hijo es un nuevo programa</li></ul></ul></section><section id="creation-syscalls"><p>Syscalls</p><dl><div class="fragment"><dt>Fork</dt><dd><p class="fragment">Crea un nuevo proceso como <strong>copia</strong> del padre.</p><p class="fragment">Ambos continúan ejecutando desde la instrucción posterior a <code>fork</code></p><p class="fragment">La llamada retorna* el <code>PID</code> del hijo al padre y <code>0</code> al hijo</p></dd></div><div class="fragment"><dt>Exec</dt><dd><p class="fragment">Carga un binario en memoria <strong>reemplazando</strong> el código de quien lo llamó, e inicia su ejecución.</p><p class="fragment">Básicamente otro programa se <em>roba</em> el proceso</p></dd></div></dl></section><section id="creation-fork-l-q"><p>¿Qué imprimen los programas?</p><pre><code class="hljs lang-c">int a = 42;

pid_t child_pid = fork(); /* create new process */
if (child_pid == 0) { /* child gets 0 */
  a++;
  printf("CHILD: a is : %d\n", a); /* ??? */
}
else if(child_pid > 0) { /* parent gets the new pid ('random' number) */
  printf("PARENT: child_pid is %d\n", child_pid);
  printf("PARENT: a is %d\n", a); /* ??? */
}</code></pre></section><section id="creation-fork-loop-q"><p>¿Cuántos procesos se crean?</p><pre><code class="hljs lang-c">/* ... */
for(int i=0; i<4; i++) {
  fork();
  printf("[%4d] %d\n", getpid(), i);
}</code></pre></section><section id="creation-wait"><p>Usualmente, después del <code>fork()</code>, uno de los dos (el hijo) ejecuta un <code>exec()</code>.</p><ul><li class="fragment">El padre conoce el <strong>pid</strong> del hijo</li><li class="fragment">El padre podría seguir ejecutando y crear más hijos</li><li class="fragment">&hellip; o bien esperar que el hijo termine (o muera)</li></ul><img src="../images/figures/01-3_10.pdf.png" /></section><section id="creation-wait-def"><p>Syscalls</p><dl><dt>Fork</dt><dd><p>Clona el proceso.</p></dd><dt>Exec</dt><dd><p>Reemplaza el proceso por otro</p></dd><div class="fragment"><dt>Wait</dt><dd><p class="fragment">Espera a un proceso hijo termine de ejecutar.</p></dd></div></dl></section></section><section id="termination"><h2>Terminando procesos</h2><section id="termination-0"><p class="fragment">Todo proceso, al terminar su ejecución, ejecuta <code>exit()</code></p><ul><li class="fragment">Entrega un <em>código de retorno</em> (¿para qué?)</li><li class="fragment">El SO recupera todos los recursos asignados</li></ul></section><section id="termination-retCode"><p>El código de retorno se utiliza para avisar cómo resultó la ejecución</p><ul><li class="fragment">Generalmente es <code>0</code> cuando no hubo problemas</li><li class="fragment">Y un número distinto de <code>0</code> para indicar un problema</li><ul><li class="fragment">La documentación del programa debería relacionar errores a códigos de retorno.</li></ul><li class="fragment">Por su uso, también es conocido por <em>código de error</em>.</li></ul></section><section id="termination-syscalls"><p>Syscalls</p><dl><dt>Fork</dt><dd><p>Clona el proceso.</p></dd><dt>Exec</dt><dd><p>Reemplaza el proceso por otro</p></dd><dt>Wait</dt><dd><p>Espera a un proceso hijo termine de ejecutar.</p></dd><div class="fragment"><dt>Exit</dt><dd><p class="fragment">Termina el proceso con un código de retorno dado.</p></dd></div></dl></section><section id="termination-signals"><dl><dt>kill / TerminateProcess</dt><dd><p>Envía una <strong>señal</strong> a otro proceso (típicamente <em>SIGTERM</em>)</p><p>Se puede especificar la señal (<em>SIGKILL</em> no tiene piedad)</p></dd></dl></section><section id="termination-q"><p>Si el padre muere, ¿deben morir los hijos?</p><ul><li class="fragment">Usualmente el SO no permite que un hijo exista si el padre ha terminado.</li><li class="fragment">Sistema Operativo ejecuta una <strong>terminación en cascada</strong></li></ul></section><section id="termination-getReturnCode"><p>Huérfanos y zombies: the walking process</p><p class="fragment">Proceso terminado no se borra inmediatamente de la tabla de procesos.</p><ul><li class="fragment">¿Por qué? <span class="fragment">Para que el padre recupere su estado de salida con <code>wait()</code></span></li><li class="fragment">Cuando el padre hace <code>wait()</code> la entrada del hijo se borra de la tabla</li></ul><p class="fragment">¿Cómo se hace en Linux?</p><pre class="fragment"><code class="hljs lang-c">/* Un proceso (hijo) termina... */
exit(1);</code></pre><pre class="fragment"><code class="hljs lang-c">/* El padre consulta el estado */
int status;
pid_t pid = wait(/*out*/ &status); /* Ahora 'status' tiene el código de retorno */
/* Ahora el SO puede terminar de eliminar el proceso hijo */</code></pre><p class="fragment">Si el padre tenía varios hijos, ¿a cuál esperamos recién?</p></section><section id="termination-zombies"><p>¿Y si el padre jamás hace <code>wait()</code>?</p><ul><li class="fragment">Si el padre termina sin ejecutar <code>wait()</code>, el hijo queda <strong>huérfano</strong> (zombie).</li><div class="fragment"><li>Linux/UNIX: huérfanos pasan a ser hijos de <code>init</code></li><ul><li><code>init</code> llama periódicamente a <code>wait()</code> para deshacerse de los huérfanos (reaps zombies).</li></ul></div></ul></section><section id="termination-necromancy"><p>Creando zombies</p><pre><code class="hljs lang-c">#include "sys/wait.h"
#include "stdlib.h"
#include "unistd.h"

pid_t pids[10];
void main() {

  for (int i=9; i>=0; i--)
    if ((pids[i]=fork()) == 0) { /* pid == 0, only child enters */
       sleep(i+1);   /* Wait and terminate */
       exit(0);
    }

  for (int i=9; i>=0; i--)       /* Only root process reaches */
    waitpid(pids[i], NULL, 0);   /* First wait [9] is the longest */
}</code></pre></section></section><section id="_ipc"><h2>Comunicación entre procesos (IPC)</h2></section><section id="ipc"><h2>Comunicación entre procesos (IPC)</h2><section id="ipc-0"><p><em>InterProcess Comunication (IPC)</em></p><p class="fragment">Si hay multiprogramación, hay múltiples procesos "en ejecución"</p><ul><li class="fragment">Procesos <strong>independientes</strong> no provocan problemas &hellip;</li><li class="fragment">procesos <strong>cooperativos</strong> requieren <strong>comunicación inter-procesos</strong></li></ul><p class="fragment">Dos modelos fundamentales de IPC:</p><ul><li class="fragment"><strong>Memoria compartida</strong> (<em>shared memory</em>)</li><li class="fragment"><strong>Paso de mensajes</strong> (<em>message passing</em>)</li></ul></section><section id="ipc-shm_vs_mp"><p>Memoria compartida vs. Paso de mensajes</p><p>Memoria Compartida</p><p class="fragment" data-fragment-index="1">Procesos acuerdan un espacio de memoria donde ambos pueden escribir</p><ul><li class="fragment" data-fragment-index="3">Más rápido que paso de mensajes (sólo un <em>syscall</em> para crearla)</li><li class="fragment" data-fragment-index="5">Requiere coordinar accesos</li></ul><p></p><span class="fragment fade-in" data-fragment-index="0"><span class="fragment fade-out" data-fragment-index="1"><small>Fight!</small></span></span><p>Paso de Mensajes</p><p class="fragment" data-fragment-index="2">Procesos se envían mensajes</p><ul><li class="fragment" data-fragment-index="4">Requiere <em>Syscall</em>s <code>send</code>/<code>recv</code></li><li class="fragment" data-fragment-index="6">Fácil de programar para envíos pequeños (no provoca conflictos)</li></ul></section><section id="ipc-shm_vs_mp-fig"><img src="../images/figures/01-3_12.pdf.png" /></section></section><section id="ipc-_shm"><h2>Memoria Compartida</h2><section id="ipc-shm"><p>¿Escribir en memoria de otro proceso?</p><ul class="fragment"><li>Procesos $A$ y $B$ deben <strong>acordar</strong> permitirse acceso</li><li>Proceso $A$ designa una región de su espacio de memoria como <em>compartida</em></li><li>Proceso $B$ agrega esa región como parte de su espacio</li><li>$A$ y $B$ se preocupan de coordinar los accesos</li></ul><p class="fragment">API POSIX provee syscall para crear y exponer regiones de memoria compartida</p><ul class="fragment"><li><em>Memory-mapped files</em></li><li><code>shm_open()</code>, <code>ftruncate()</code>, <code>mmap()</code>, <code>shm_unlink()</code></li></ul></section></section><section id="ipc-_mp"><h2>Paso de mensajes</h2><section id="ipc-mp"><p class="fragment">Abstracción de <em>mensaje</em>. Dos primitivas:</p><ul class="fragment"><li><code>send(message)</code></li><li><code>receive(message)</code></li></ul></section><section id="ipc-mp-d-u"><p>Comunicación directa vs indirecta</p><p class="fragment" data-fragment-index="0">Con <strong>comunicación directa</strong>, cada proceso debe conocer el <em>nombre</em> del otro</p><ul class="fragment"><li><code>send(P, message)</code></li><li><code>receive(Q, message)</code></li></ul><p class="fragment">Este esquema es <strong>simétrico</strong><span class="fragment">. Variante <em>asimétrica</em>: <code>receive(&id, message)</code></span></p><p class="fragment" data-fragment-index="0">Con <strong>comunicación indirecta</strong> utiliza abstracción de <em>mailbox</em> o <em>port</em></p><ul class="fragment"><li><code>send(A, message)</code></li><li><code>receive(A, message)</code></li></ul><p class="fragment">Ambos deben poseer un referencia al <em>mailbox</em> <code>A</code></p></section><section id="ipc-mp-sync"><p>Comunicación síncrona vs asíncrona</p><p class="fragment">Tanto <code>send()</code> como <code>receive()</code> pueden ser <strong>bloqueantes</strong> (síncrono) o <strong>no bloqueantes</strong> (asíncrono)</p><ul><li class="fragment"><code>send</code> <strong>bloqueante</strong>: bloquea hasta que el mensaje es recibido</li><li class="fragment"><code>send</code> <strong>no-bloqueante</strong>: envía y continúa</li><li class="fragment"><code>recv</code> <strong>bloqueante</strong>: espera hasta recibir un mensaje</li><li class="fragment"><code>recv</code> <strong>no-bloqueante</strong>: recibe un mensaje inmediatamente o <code>null</code></li></ul></section></section><section id="threads"><h2>Threads</h2><section id="threads-_init"><h2><em>Threads</em> y <em>Multicores</em></h2></section><section id="threads-init"><p><strong><em>Thread</em></strong>: Como un proceso, pero más liviano.</p><p class="fragment">Unidad básica de uso de CPU</p><div class="fragment"><ul><li class="fragment"> <em>Thread ID</em> (<strong>tid</strong>)</li><li class="fragment"> Program Counter</li><li class="fragment"> Registros</li><li class="fragment"> <em>Stack</em></li></ul></div><p class="fragment">¿y el resto?&hellip; <span class="fragment">compartido con un proceso</span></p></section><section id="threads-mt"><p><em>Single-threading</em> vs <em>Multi-threading</em></p><p class="fragment">Procesos pueden tener uno o más <em>threads</em></p><img src="../images/figures/01-4_01.pdf.png" /></section><section id="threads-mt-1"><p><em>Multi-threading</em></p><ul><ul></ul><li class="fragment"> Proceso son unidades <em>pesadas</em></li><li class="fragment"> <em>Threads</em> pueden ejecutar parte del código de un proceso</li><ul><li class="fragment"> Concurrencia real en la medida que hayan múltiples <em>core</em>s</li></ul><li class="fragment"> Un <em>web browser</em> puede:</li><ul><li class="fragment"> Recuperar y desplegar imágenes</li><li class="fragment"> Hacer <em>parsing</em> de HTML</li><li class="fragment"> Proponer opciones de autocompletado mientras se escribir</li><li class="fragment"> Ejecutar corrector ortográfico mientras se escribe</li></ul></ul><p class="fragment">Si voy a ejecutar parte del mismo código, talvez no necesito crear un proceso nuevo.</p><p class="fragment">Es como hacer <code>fork()</code> ¿y &hellip; hacer <code>exec()</code>?</p></section><section id="threads-mt-2"><p><em>Multi-threading</em></p><p>Otro caso: un <em>web server</em> necesita atender múltiples conexiones</p><ul><li class="fragment"> ¿Espero atender completamente una antes de recibir la siguiente?</li></ul><div class="fragment"><img src="../images/figures/01-4_02.pdf.png" /></div></section><section id="threads-mt-3"><p><em>Multi-cores</em> y <em>Multi-threading</em></p><p class="fragment">Con <em>single-core</em> solo un <em>thread</em> de un proceso puede ejecutar al mismo tiempo</p><div class="fragment"><p>¿Cómo se provee la ilusión de que múltiples <em>threads</em> ejecutan simultáneamente?</p><p>&hellip; ¡pero ahora hay <strong>multi-cores</strong>!</p></div><ul class="fragment"><li>Múltiples <em>threads</em> avanzan: <strong>concurrencia</strong></li><li>Múltiples <em>threads</em> ejecutan simultáneamente: <strong>paralelismo</strong></li></ul></section></section><section id="ll"><h2>Paralelismo</h2><section id="ll-Amdahl"><p><em>Multi-cores</em> y <em>Multi-threading</em></p><p>¿Cuánto gano?</p><p class="fragment">Gene Amdahl propuso una fórmula (1967) para calcular la mejora <em>potencial</em> de un programa
   que contiene partes paralelizables y partes secuenciales</p><p class="fragment" style="font-size:1.5em;">$$\mathit{speedup} \leq \frac{1}{s + \frac{\bar{s}}{N}}$$</p></section><section id="ll-Amdahl-d-0"><p>Midiendo paralelismo</p><ul><li>$s$: Fracción de tiempo usado en de código no-paralelizable (secuencial).</li><li>$N$: Número de <em>cores</em></li></ul><p>El <em>speedup</em> es un valor positivo que indica la mejora de un código paralelo respecto a su versión secuencial</p><p>$$\mathit{speedup} = \frac{T_{\mathit{secuencial}}}{T_{\mathit{paralelo}}} = \frac{T_{1}}{T_{N}}$$</p><p class="fragment">Ejemplo: $\mathit{speedup}=2$ signfica que $T_{1}=2T_{N}$, dos veces más rápido</p></section><section id="ll-Amdahl-d-1"><p>Sea $T_N$ el tiempo de ejecución con $N$ cores, y $s \in (0, 1]$ la fracción de código estrictamente secuencial</p><p class="fragment">El tiempo en $N$ cores se puede definir como:</p><ul><li class="fragment">$$T_N = T_1 s + \frac{T_1 \bar{s}}{N} = T_1 \left( s + \frac{\bar{s}}{N} \right)$$</li></ul><p class="fragment">Por lo tanto el <em>speedup</em> es:</p><p class="fragment">$$\mathit{speedup} = \frac{T_1}{T_N} = \frac{T_1}{T_1 \left( s + \frac{\bar{s}}{N} \right)} = \frac{1}{s + \frac{\bar{s}}{N}}$$</p></section></section><section id="mt"><h2><em>Multi-threading</em></h2><section id="mt"></section><section id="mt-dataModels"><p>Modelos de <em>multithreading</em></p><p>Dos tipos de <em>threads</em></p><ul><li class="fragment"> <strong>User threads</strong></li><ul><li class="fragment"> Manejados por una biblioteca de usuario</li><li class="fragment"> Sistema Operativo sólo ve procesos</li></ul><li class="fragment"> <strong>Kernel threads</strong></li><ul><li class="fragment"> Administrador por el Sistema Operativo (asignables a <em>core</em>s)</li><li class="fragment"> Soportados en (casi) todos los Sistemas Operativos contemporáneos</li></ul></ul><p class="fragment">¿Cómo se relacionan <em>kernel</em> y <em>user threads</em>?</p></section><section id="mt-dataModels-greenThreads"><p><em>Many-to-one</em></p><ul><li class="fragment"> + Manejo de <em>threads</em> en biblioteca de usuario</li><li class="fragment"> - Un <em>syscall</em> de un <em>thread</em> bloquea todo el proceso</li></ul><div class="fragment"><img width="40%" src="../images/figures/01-4_05.pdf.png" /></div><br /><p class="fragment">Solaris: biblioteca <em>green threads</em></p></section><section id="mt-dataModels-id"><p><em>One-to-one</em></p><ul><li class="fragment"> + <em>Threads</em> ejecutando <em>syscall</em> no bloquean el proceso</li><li class="fragment"> + Asignables a distintos <em>core</em>s</li><li class="fragment"> - Creación implica ejecutar <em>syscalls</em></li><li class="fragment"> - Sistemas Operativos limitan el máximo número de <em>threads</em></li></ul><img width="60%" src="../images/figures/01-4_06.pdf.png" /><br /><p class="fragment">Linux & Windows</p></section><section id="mt-dataModels-m2m"><p><em>Many-to-many</em></p><ul><li class="fragment"> + Usuario pueden crear número ilimitado de <em>threads</em></li><li class="fragment"> + Asignación de <em>user thread</em> a <em>kernel thread</em> se hace <em>on-demand</em></li><li class="fragment"> + <em>Threads</em> ejecutando <em>syscall</em> no bloquean el proceso</li><li class="fragment"> - Creación implica ejecutar <em>syscalls</em></li><li class="fragment"> - Sistemas Operativos limitan el máximo número de <em>threads</em></li></ul><img width="40%" src="../images/figures/01-4_07.pdf.png" /><br /></section><section id="mt-threadingLibs"><p>Bibliotecas de <em>threads</em></p><p class="fragment">Tres principales:</p><ul class="fragment"><li>POSIX Pthreads (kernel ó user)</li><li>Windows Threads (kernel)</li><li>Java threads (user)</li></ul></section><section id="mt-threadingLibs-pthreads"><h5><code>pthread</code></h5><p>POSIX standard IEEE 1003.1c (especificación)</p><p class="fragment">API para creación y sincronización de <em>thread</em>s.</p><p class="fragment">Implementaciones para Linux, Mac OS X, Solaris</p><ul><li class="fragment"> <code>pthread_t</code>, identificador</li><li class="fragment"> <code>pthread_create()</code>, creación de <em>thread</em></li><li class="fragment"> <code>pthread_join()</code>, padre espera que hijo(s) termine(n)</li><li class="fragment"> <code>pthread_exit()</code>, termina el <em>thread</em> actual</li></ul></section><section id="mt-threadingLibs-winThreads"><h5>Windows Threads</h5><p>Disponible nativamente en Windows API (kernel <em>thread</em>s)</p><ul><li class="fragment"> <code>HANDLE</code>, permite acceder al <em>thread</em> (puntero)</li><li class="fragment"> <code>CreateThread()</code>, creación de <em>thread</em></li><li class="fragment"> <code>WaitForSingleObject()</code> padre espera que hijo termine</li><li class="fragment"> <code>WaitForMultipleObjects()</code> padre espera que hijo(s) termine(n)</li><li class="fragment"> <code>CloseHandle()</code>, borra el <em>thread</em> indicado</li></ul></section><section id="mt-threadingLibs-javaThreads"><h5>Java Threads</h5><p>Implementado como biblioteca nativa en la JVM</p><p class="fragment">Se consideran <em>user thread</em>s ya que la JVM ejecuta sobre algún Sistema Operativo <em>host</em></p><ul><li class="fragment"> Creación: extender clase <code>Thread</code> y hacer <em>override</em> del método <code>run()</code></li><li class="fragment"> Creación: clase que implementa la interfaz <code>Runnable</code></li><li class="fragment"> <em>Thread</em> es efectivamente creado al invocar <code>start()</code></li><ul><li class="fragment"> Asigna memoria para el nuevo objeto <em>thread</em> en la JVM</li><li class="fragment"> Llama al método <code>run()</code> iniciando la ejecución del <em>thread</em></li></ul><li class="fragment"> Esperar que un <em>thread</em> hijo termine: <code>join()</code></li></ul></section></section><section id="semantics"><h2>Semántica de <code>fork</code>/<code>exec</code> y señales</h2><p>Aún quedan algunas situaciones "poco claras"</p><ul><li class="fragment"> Semántica de <code>fork()</code> y <code>exec()</code> en proceso <em>multithreaded</em></li><ul><li class="fragment"> ¿Se duplican todos los <em>thread</em>s o solo el actual?</li><li class="fragment"> ¿<code>exec()</code> reemplaza todos los <em>thread</em>s?</li><!--ul
  li.fragment  No se debería poder, el resto de los threads quedarían corruptos
  li.fragment  Si se espera que funcione  debe ser creando un proceso nuevo y terminando el thread--></ul><li class="fragment"> Semántica de señales (<em>signal</em>s) en Unix, ¿quién la recibe?</li><ul><li class="fragment"> Un <em>thread</em>, aquél al cual se le aplica</li><li class="fragment"> A todos los <em>thread</em>s del proceso</li><li class="fragment"> A algunos <em>thread</em>s</li><li class="fragment"> Siempre al mismo <em>thread</em></li></ul></ul></section><section id="summary-"><h2>Resumen: <em>Threads</em></h2><ul><li class="fragment"> <em>Thread</em>: flujo de control básico dentro de un proceso</li><li class="fragment"> Múltiples <em>thread</em>s en el mismo proceso comparten espacio de memoria</li><li class="fragment"> <em>User thread</em>s: fáciles de crear, pero no visto por el Sistema Operativo</li><li class="fragment"> <em>Kernel thread</em>s: manejables por el Sistema Operativo, más costosos de crear</li><li class="fragment"> MacOSX, Windows, Linux, soportan <em>kernel thread</em>s y hacen <em>mapping</em> a <em>user thread</em>s</li><li class="fragment"> Bibliotecas de <em>thread</em>s más comunes: Pthreads, Windows threads, Java threads</li></ul></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/js/reveal.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    width: 1600,
    height: 900,

    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    math: {
        mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
        // config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
    },

    // Optional reveal.js plugins
    dependencies: [

        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },

        // Markdown
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' );} },

        // Highlight <code>
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/highlight/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Mathjax
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/math/math.min.js', async: true },

        // Zoom
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/zoom-js/zoom.min.js', async: true },

        // Speaker Notes
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/notes/notes.min.js', async: true }

        // Title footer
        //{ src: '../js/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }
    ]
});</script></body></html>