<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>Administración de Memoria</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta content="Dietrich Daroch" name="author" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/reveal.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/theme/white.min.css" id="theme" rel="stylesheet" /><link href="https://github.com/frederickf/presentable/raw/master/src/presentable.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/css/zenburn.min.css" rel="stylesheet" /></head><body><div class="reveal"><div class="slides"><section><h2>Sistemas Operativos y Redes</h2><h1>Administración de Memoria</h1><p>Semestre 1/2016</p><p>Cristian Ruz - cruz@ing.puc.cl</p><p style="padding-top:4em;">Departamento de Ciencia de la Computación</p><p>Pontificia Universidad Católica de Chile</p></section><section><h2>Direccionamiento de Memoria</h2></section><section><h2>Direccionamiento de Memoria</h2><section id="memory0"><div><b>MEMORIA</b> </div><ul><li>Un gran arreglo de <i>bytes</i></li><li>Cada uno con su propia <b>dirección</b></li></ul><div><img width="50%" src="/images/figures/04-memory1.png" /></div><ul class="fragment"><li> PC lee instrucciones desde una dirección de memoria</li><li> Instrucciones pueden requerir leer operandos desde otra dirección de memoria</li><li> Resultados suelen ser almacenados en alguna dirección de memoria</li></ul></section><section id="memory1"><div><b>Velocidad</b></div><ul class="fragment"><li>Registro: acceso en un ciclo de CPU</li><li>Memoria: requiere acceso al <i>bus de memoria</i></li><li>¿Solución? <span class="fragment">caché</span></li></ul></section><section id="memory2"><div class="fragment"><b>Protección</b></div><ul class="fragment"><li>Multiprogramación. Procesos no deben acceder a memoria de otro procesos</li><li>¿Si hay dos procesos que hagan referencia a la misma dirección?</li></ul><div><img width="35%" src="/images/figures/04-spaces.png" /></div><div class="fragment">Referencias absolutas</div></section><section id="memory3"><div>Procesos poseen registros <i>base</i> y <i>limit</i></div><div><img width="30%" src="/images/figures/02-8_01.pdf.png" /></div><ul class="fragment"><li>¿S.O. verifica cada acceso? <span class="fragment">leeeento</span></li><li class="fragment">¿Solución? <span class="fragment">Verificación por <i>hardware</i></span></li></ul></section><section id="memory4"><div>Registros <i>base</i> y <i>limit</i> se cargan, y son verificados por <i>hardware</i>.</div><div><img width="70%" src="/images/figures/02-8_02.pdf.png" /></div><div>¿Quién hace esto? <span class="fragment">MMU: <i>Memory Manager Unit</i></span></div><div class="fragment">Referencias relativas:  <b>JMP 28 + base</b>, en lugar de <b>JMP 28</b></div></section><section id="memory5"><div>Procesos piden una dirección de memoria ... <span class="fragment"> pero MMU les entrega otra</span></div><ul class="fragment"><li><b>Dirección lógica o virtual</b>: solicitado por el proceso (JMP 28)</li><li><b>Dirección física</b>: accedida en la memoría física (JMP 16384+28)</li></ul><div><img width="25%" src="/images/figures/04-twoprocs.png" /></div><div class="fragment">¿Cuándo se determina la dirección física? (1) Compilación (2) Ejecución (3) Carga</div></section></section><section id="spaces0"><h2>Cargando procesos</h2><section id="spaces1"><div>Procesos pueden ser cargados y descargados de la memoria</div><div><img width="50%" src="/images/figures/02-8_05.pdf.png" /></div></section><section id="spaces2"><div>Espacio libre se modifica en cada carga/<i>swap-in</i> o descarga/<i>swap-out</i></div><div><img width="70%" src="/images/figures/04-loadprocs.png" /></div></section><section id="spaces3"><div>Direcciones deben ajustarse ante cada carga</div><div><img width="70%" src="/images/figures/02-8_06.pdf.png" /></div></section><section id="spaces4"><div><b>¿Dónde ubicar un proceso nuevo?</b></div><div>Estrategias</div><ul><li class="fragment"><strong>First-fit</strong>. En el primer lugar disponible.</li><li class="fragment"><strong>Best-fit</strong>. En el que deja menos espacio libre (el más pequeño posible).</li><li class="fragment"><strong>Worst-fit</strong>. En el que deja más (el más grande).</li></ul><div class="framgent">¿Cuál es mejor?</div></section><section id="spaces5"><div><b>Problema: FRAGMENTACION</b></div><div>En dos variedades</div><ul><li class="fragment"><b>Fragmentación Externa</b>: Hay espacio para otro proceso, pero no contiguo.</li><li class="fragment"><b>Fragmentación Interna</b>: Espacio sobre-asignado a un proceso.</li></ul></section><section id="spaces6"><div><b>¿Cómo evitar la fragmentación externa?</b></div><div class="fragment"><b>Compactación</b>: fusionar huecos</div><div class="fragment"><img width="20%" src="/images/figures/02-fusion.png" /></div><div class="framgment">¿Pero?</div><ul><li class="fragment">Es <b>costoso</b>. No voy esperar que mis 16GB se reacomoden.</li><li class="fragment">¿Otras soluciones? <span class="fragment">Técnicas de <i>memoria virtuual</i>: <span class="fragment"><b>segmentación</b>, </span><span class="fragment"><b>paginación</b></li></ul></section></section><section id="seg"><h2>Segmentación</h2><section id="seg1"><div>Espacio de direcciones se divide en segmentos lógicos</div><ul><li class="fragment"> Código</li><li class="fragment"> Variables globales</li><li class="fragment"> <em>Heap</em> (para asignación dinámica de memoria)</li><li class="fragment"> <em>Stacks</em> para cada <em>thread</em></li><li class="fragment"> Código de la librería estándar de C</li></ul><div><img width="20%" src="/images/figures/02-8_07.pdf.png" /></div></section><section id="seg2"><div>Cada <b>segmento</b> se puede cargar en regiones distintas de memoria.</div><div>Segmentos poseen: identificador y longitud</div><div><img width="20%" src="/images/figures/02-8_07.pdf.png" /></div><div>Una dirección de memoria específica en memoria segmentada está formada por una tupla con dos datos (un par):
$\langle$ <code>numeroDeSegmento</code>, <code>offset</code> $\rangle$</div></section><section id="seg3"><div>Una dirección lógica es: $\langle$ <code>segmento</code>, <code>offset</code> $\rangle$</div><div>Información de segmentos cargados se almacena en: <b>Tabla de segmentos</b></div><div><img width="40%" src="/images/figures/02-8_09.pdf.png" /></div></section><section id="seg4"><div>Una dirección lógica es: $\langle$ <code>segmento</code>, <code>offset</code> $\rangle$</div><div>MMU usa la <b>Tabla de segmentos</b> para obtener la <b>dirección física</b></div><div><img width="50%" src="/images/figures/02-8_08.pdf.png" /></div></section></section><section id="pag"><h2>Paginación</h2><section id="pag1"><div style="text-align:left;">Segmentación reduce el problema de la fragmentación externa <span class="fragment"> ... pero no lo soluciona</span></div><div class="fragment" style="text-align:left;"><b>Paginación</b> divide el espacio virtual de direcciones en regiones de igual tamaño</div><ul><li class="fragment">Espacio virtual (lógico) de direcciones se divide en <b>páginas</b></li><li class="fragment">Espacio físico de direcciones se divide en <b>frames</b> (marcos)</li><li class="fragment">Páginas y <i>frames</i> son del mismo tamaño</li></ul><div class="fragment">¿De qué tamaño son las páginas de su sistema?</div></section><section id="pag2"><div>Dirección de memoria paginada está compuesta de<br/>
$\langle$ <code>numeroDePagina</code>, <code>offset</code> $\rangle$</div><div><img width="60%" src="/images/figures/02-8_10.pdf.png" /></div></section><section id="pag3"><div><img width="45%" src="/images/figures/02-8_11.pdf.png" /></div></section><section id="pag4"><div style="text-align:left;">Tamaños posibles de páginas y frames son determinados por <i>hardware</i></div><div style="text-align:left;">Al ser potencias de 2, se evitan sumas.</div><ul><li class="fragment">Direcciones lógicas de $m$-bit</li><li class="fragment">Tamaño de página de $2^n$ bytes</li></ul><div><img src="/images/figures/02-in-8_1.pdf.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div><div class="fragment">Cantidad de páginas posibles: $2^{m-n}$</div></section><section id="pag5"><div style="text-align:left;">Dirección virtual: $m=4$ bit, $n=2$</div><ul><li class="fragment">$2$-bit: número de página... $2^{m-n} = 4$ páginas</li><li class="fragment">$2$-bit: <i>offset</i>... Páginas de tamaño $2^{n}=4$ byte.</li><li class="fragment">Memoria física: 32 byte... $8$ <i>frames</i> de memoria.</li></ul><div><img src="/images/figures/02-8_12.pdf.png" style="background:none; border:none; box-shadow:none;" width="25%" /></div><div class="fragment">Dirección lógica: 1001 <span class="fragment">, ... dirección física: 0101</span></div></section><section id="pag6"><div style="text-align:left;">Paginación elimina <b>fragmentación externa</b>...<span class="fragment">pero tenemos <b>fragmentación interna</b></span></div><div style="text-align:left;">Ejemplo: Páginas de $4$KB, y un proceso solicita $8$KB.</div><ul><li class="fragment">Se asignan 21 páginas de $4$KB... <span class="fragment">$3$KB desperdiciados.</span></li></ul></section><section id="pag7"><div style="text-align:left;">Ejemplo: Páginas de $8$KB. Direcciones virtuales de $16$-bit.</div><ul><li class="fragment">¿Cuántas páginas?</li><li class="fragment">¿Tamaño de la tabla de páginas?</li></ul></section><section id="pag8"><div style="text-align:left;">Ejemplo: Páginas de $4$KB. Direcciones virtuales de $32$-bit.</div><ul><li class="fragment">¿Cuántas páginas? <span class="fragment">$2^{20}$</span></li><li class="fragment">¿Tamaño de la tabla de páginas? <span class="fragment">$\geq 1$MB</span></li></ul><div class="fragment">Accesos pueden hacerse lentos. ¿Por qué?</div></section><section id="pag9"><div><b>Translation Look-aside Buffer (TLB)</b></div><div style="text-align:left;">Caché en <i>hardware</i> para las entradas de la tabla de páginas (32 a 1024 entradas).</div><div class="fragment"><img src="/images/figures/02-8_14.pdf.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section id="pag10"><div><img src="/images/figures/02-8_14.pdf.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div><ul><li class="fragment">Tiempo de acceso a TLB: $100$ns</li><li class="fragment">Tiempo de acceso a memoria: $500$ns</li><li class="fragment">¿Tiempo promedio de acceso con $80\%$ hit-rate?</li></ul></section><section id="pag11"><div><b>Tablas de páginas jerárquicas</b></div><div><img src="/images/figures/02-8_17.pdf.png" style="background:none; border:none; box-shadow:none;" width="35%" /></div></section><section id="pag12"><div><b>Tablas de páginas jerárquicas</b></div><div>Direccionamiento de dos niveles</div><div><img src="/images/figures/02-8_18.pdf.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div><div><img src="/images/figures/02-in-8_2.pdf.png" style="background:none; border:none; box-shadow:none;" width="35%" /></div></section><section id="pag13"><div><b>Tablas de páginas jerárquicas</b></div><div>Direcciones de 64-bit</div><div><img src="/images/figures/02-in-8_4.pdf.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div><div>Con otro nivel de paginación</div><div><img src="/images/figures/02-in-8_5.pdf.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section id="pag14"><div><b>Tablas de páginas con <i>hash</i></b></div><div><img src="/images/figures/02-8_19.pdf.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div><div>Apropiadas para espacios de direcciones <em>sparse</em> (ralos)</div></section><section id="pag15"><div><b>Tablas de páginas invertida</b></div><ul><li class="fragment"> Una entrada por frame (en lugar de página)</li><li class="fragment"> Sólo una tabla en el sistema (no por proceso)</li></ul><div><img src="/images/figures/02-8_20.pdf.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div><div>Usada en 64-bit UltraSPARC, y PowerPC</div></section></section><section id="virmem"><h2>Memoria Virtual</h2><section id="virmem1"><div style="text-align:left;">Segmentación y paginación intentan dar la ilusión que toda la memoria es contínua.</div><div class="fragment" style="text-align:left;">... pero el programa aún debe estar completamente en memoria</div><div class="fragment" style="text-align:left;">Pero no es siempre necesario.</div><div class="fragment" style="text-align:left;">&nbsp<br/>&nbsp;<br/></div><ul><li class="fragment">Carga dinámica</li><li class="fragment">¿Se requiere todo el código en memoria? ¿Librerías (estáticas y dinámicas)?</li><li class="fragment">¿Y si un proceso solicita más memoria que la memoria física del sistema?</li></ul></section><section id="virmem2"><div><i>Frames</i> se cargan de disco a medida que se necesitan.</div><div><img src="/images/figures/02-9_01.pdf.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div></section><section id="virmem3"><div>Bibliotecas compartidas se asigna a <em>frames</em> ya cargados</div><div><img src="/images/figures/02-9_03.pdf.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div></section><section id="virmem4"><div style="text-align:left;"><b>Paginación por demanda</b> <span class="fragment">Primera etapa: mantener registro de páginas cargadas</span></div><ul class="fragment"><li>Bit adicional en tabla de páginas</li><ul><li><em>Valid</em>: Página en memoria</li><li><em>Invalid</em>: Página almacenada en disco, pero no en memoria</li></ul><li class="fragment"> Al detectar un acceso a una página <em>invalid</em>, ésta se carga dinámicamente y marca el bit a <em>valid</em></li></ul><div><img src="/images/figures/02-9_05.pdf.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div></section><section id="virmem5"><div style="text-align:left;">Segunda etapa: cargar páginas que se necesiten</div><div style="text-align:left;">Proceso de carga se activa ante un <strong><i>page-fault</i></strong></div><div><img src="/images/figures/02-9_06.pdf.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div><ul><li class="fragment"> Proceso podría empezar con una única página en memoria: <strong>paginación por demanda pura</strong></li></ul></section><section id="virmem6"><div style="text-align:left;">Rendimiento de la paginación por demanda</div><ul><li class="fragment"> $p$, probabilidad de <em>page fault</em></li><li class="fragment"> $t_{ma}$, tiempo de acceso a memoria, $\sim 200 \times 10^{-9}s$</li><li class="fragment"> $t_{pf}$, tiempo generado por <em>page fault</em></li></ul><div class="fragment" style="text-align:left;">Tiempo efectivo de acceso a memoria, $t_e$: </div><div class="fragment">&nbsp; $t_e = (1-p) \times t_{ma} + p \times t_{pf}$</div><div class="fragment" style="text-align:left;">Con $t_{pf} = 8 \text{ms}$:</div><div class="fragment">&nbsp; $t_{e} = 200 + 7999800 p$</div><div class="fragment" style="text-align:left;">Si queremos que la degradación no sea mayor a $10\%$: </div><div class="fragment">&nbsp; $220 > 200 + 7999800p \Rightarrow p < 0.0000025$</div></section><section id="virmem7"><div style="text-align:left;">Al hacer un <code>fork()</code> se <em>copia</em> la memoria del padre al hijo.</div><ul><li class="fragment"> ¿Y si el hijo no escribe en su memoria o hace inmediatamente <code>exec()</code>?</li></ul><div class="fragment">Estrategia <strong>copy-on-write</strong> mantiene las páginas del padre como <em>región compartida para el hijo</em></div><div><img src="/images/figures/02-9_07.pdf.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div><div><img src="/images/figures/02-9_08.pdf.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section></section><section id="reemp"><h2>Reemplazo de páginas</h2><section id="reemp1"><div>Cuando no hay espacio en memoria se necesita <i>reemplazar una página </i></div><div><img src="/images/figures/02-9_09.pdf.png" style="background:none; border:none; box-shadow:none;" width="55%" /></div></section><section id="reemp2"><div>Sistema Operativo ejecuta un algoritmo para elegir una página como <i>víctima</i> a reemplazar.</div><div><img src="/images/figures/02-9_10.pdf.png" style="background:none; border:none; box-shadow:none;" width="55%" /></div></section><section id="reemp3"><div><img src="/images/figures/02-9_10.pdf.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div><div>Dos transferencias de páginas (pasos 1 y 3)</div><ul><li class="fragment"> Páginas que no han sido modificadas no necesitan escribirse a disco</li><li class="fragment"> <strong>Modify bit</strong> o <strong>Dirty bit</strong> indican si la página ha sido modificada desde la última vez que se cargó</li><li class="fragment"> Páginas <em>read-only</em> nunca modifican su <strong>dirty bit</strong></li></ul></section><section id="reemp4"><div>¿Cuál conviene reemplazar? ... <span class="fragment">una que genere pocos <i>page faults</i></span></div><div>Supongamos páginas que almacenan 100 direcciones. Con esta secuencia de acceso:</div><div class="fragment">0145, 0400, 0102, 0670, 0110, 0672, 0112, 0198, 0153, 0602, 0170</div><div class="fragment">Esto significa que se accede a las siguientes páginas:</div><div class="fragment">1,4,1,6,1,6,1,6,1</div></section><section id="reemp5"><div><img src="/images/figures/02-9_11.pdf.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div><div>La tasa de <i>page faults</i> también depende de la cantidad de <i>frame</i>s disponibles.</div></section><section id="reemp6"><h3>Reemplazo FIFO</h3><div>Reemplazar la página que fue cargada hace más tiempo</div><div><img src="/images/figures/02-9_12.pdf.png" style="background:none; border:none; box-shadow:none;" width="65%" /></div><ul class="fragment"><li> +Fácil de implementar</li><li> -Comportamiento impredecible</li></ul></section><section id="reemp7"><div>Aumentar la cantidad de <em>frames</em> debe disminuir la cantidad de <em>page faults</em></div><ul><li class="fragment"> Ejemplo. Secuencia 1,2,3,4,1,2,5,1,2,3,4,5</li><li class="fragment"> Con 3 frames genera 9 <em>page faults</em></li><li class="fragment"> Con 4 frames genera 10 <em>page faults</em> (¿?)</li></ul><div><img src="/images/figures/02-9_13.pdf.png" style="background:none; border:none; box-shadow:none;" width="35%" /></div><div>Este problema se conoce como <strong>anomalía de Bélády</strong>. Fue planteada por el húngaro László Bélády, 1969.</div></section><section id="reemp8"><h3>Reemplaza óptimo</h3><div>Reemplaza la página que no será usada durante el mayor tiempo (en el futuro)</div><div><img src="/images/figures/02-9_14.pdf.png" style="background:none; border:none; box-shadow:none;" width="65%" /></div><li class="fragment">+Óptimo</li><li class="fragment">+No sufre la anomalía de Bélády</li><li class="fragment">-Difícil de implementar, pues requiere conocimiento futuro (como SJF)</li></section><section id="reemp9"><h3>Reemplaza LRU (<i> Least Recently Used</i>)</h3><div>Reemplazar la página que no ha sido usada por más tiempo</div><div><img src="/images/figures/02-9_15.pdf.png" style="background:none; border:none; box-shadow:none;" width="65%" /></div><div class="fragment">Compromiso más razonable para el óptimo. ¿Cómo implementarlo?</div><ul><li class="fragment"> Contadores, actualizado con valor de <em>timer</em></li><li class="fragment"> <em>Stack</em>, el último acceso avanza al tope del <em>stack</em></li><li class="fragment">En cualquier caso se requiere ayuda de <em>hardware</em></li></ul></section><section id="reemp10"><h3>Aproximación a LRU</h3><div>Si no hay soporte de <em>hardware</em>, se puede aproximar el comportamiento de LRU</div><ul><li class="fragment"> <strong>Reference bit</strong> se marca para indicar páginas referenciadas</li><li class="fragment"> Permite determinar qué páginas se han usado y cuáles no (sin orden)</li></ul><div class="fragment">Una técnica para incorporar orden:</div><ul><li class="fragment"> 8-bit reference (<em>reference byte</em>) funcionan como "bit de historia"</li><li class="fragment"> A intervalo $r$ ($\sim 100$ms) se hace <em>right shift</em> del <em>reference bit</em></li><li class="fragment"> Frame con mayor <em>reference byte</em> es el usado más recientemente    </li></ul><div class="fragment">Valores pueden no ser únicos. Entre ellos se decide de manera FIFO.</div></section><section id="reemp11"><div><b>Algoritmo de segunda oportunidad:</b> Inicialmente, FIFO, ordenado por tiempo de carga. </div><ul><li class="fragment"> Reference bit 0: se reemplaza</li><li class="fragment"> Reference bit 1: 2da oportunidad. Se cambia a 0, se establece tiempo de carga al tiempo actual, y se pasa a la siguiente página</li></ul><div><img src="/images/figures/02-9_17.pdf.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div><div>¿Qué pasa si todos los bit están marcados como 1?</div></section><section id="reemp12"><div><b>Segunda oportunidad mejorada</b></div><div>Segunda oportunidad, considerando el par (<em>reference bit</em>, <em>dirty bit</em>)</div><ul><li class="fragment">Si es (0,0), no usado recientemente ni modificada</li><ul><li class="fragment"> Buena víctima</li></ul><li class="fragment">Si es (0,1), no usada recientemente, pero modificada</li><ul><li class="fragment"> Casi buena víctima. Requiere escribirla.</li></ul><li class="fragment">Si es (1,0), recientemente usada, pero no modificada</li><ul><li class="fragment"> Probablemente será leída pronto</li></ul><li class="fragment">Si es (1,1), recientemente usada, y modificada</li><ul><li class="fragment"> Probablemente será leída pronto</li></ul></ul></section><section id="reemp13"><h3>Otros algoritmos</h3><div>Con contador de accesos (costoso de implementar)</div><ul><li class="fragment"> <strong>Least Frequently Used</strong>. Una página muy accedida debe tener alto contador.</li><ul><li class="fragment"> ¿Y si se usó solo al inicio?</li><li class="fragment"> Se puede complementar haciendo <em>shift</em> del contador periódicamente</li></ul><li class="fragment"> <strong>Most Frequently Used</strong>. La página que tiene pocos accesos probablemente fue cargada recientemente y aún no ha sido muy usada</li></ul></section></section><section id="last"><h2>Asignación de frames</h2><section id="last1"><div>¿Cuántos <em>frames</em> asignar a cada proceso?</div><div><strong>Mínimo</strong></div><ul><li class="fragment"> Puede ser definido por la arquitectura</li><li class="fragment"> O bien, depender de la cantidad de direcciones referenciables en una instrucción</li><ul><li class="fragment"> <code>load r1, 0x0160</code>. Dos frames: para la instrucción y para la dirección.</li><li class="fragment"> Más complejo cuando se permiten indirecciones</li></ul></ul><div><strong>Máximo</strong></div><ul><li class="fragment"> ¿Cómo dividir $m$ <em>frames</em> entre $n$ procesos?</li></ul></section><section id="last2"><div>$m$ <em>frames</em> y $n$ procesos</div><ul><li class="fragment"> <strong>Asignación equitativa</strong>: $\lfloor m/n \rfloor$ a cada uno. </li><li class="fragment"> <strong>Asignación proporcional</strong>: sea $s_i$ el tamaño de la memoria virtual del proceso $p_i$, cada proceso recibe $a_i$ <em>frames</em>: 

\[ a_i = \frac{s_i}{\sum{s_i}} \times m \]</li></ul><div>Proporción también puede estar relacionada a la prioridad del proceso</div></section><section id="last3"><h3>Thrashing</h3><div>Cada <em>page fault</em> genera tráfico entre disco y memoria de <em>al menos</em> una página.</div><div class="fragment">Con alta tasa de <em>page fault</em> el sistema gasta más tiempo copiando <em>frames</em> entre disco y memoria</div><div><img src="/images/figures/02-9_18.pdf.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div><ul><li class="fragment"> Baja utilización de CPU</li><li class="fragment"> <em>Scheduler</em> incrementa nivel de multiprogramación</li><li class="fragment"> Procesos nuevos requieren <em>frames</em>.</li><li class="fragment"> S.O. quita <em>frames</em> a procesos en ejecución</li><li class="fragment"> Procesos en ejecución aumentan su tasa de <em>page fault</em></li><li class="fragment"> S.O. gasta más tiempo cargando <em>frames</em></li></ul></section><section id="last4"><h3>Modelo de <i>working set</i></h3><div>Conjunto de páginas usadas en los últimos $\Delta$ accesos</div><div><img src="/images/figures/02-9_20.pdf.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div><div>$\Delta$ determina el tamaño del <em>working set</em> del proceso $i$: $\text{WSS}_i$</div><div>Demanda por páginas: $D=\sum{\text{WSS}_i}$</div><div>Si hay $m$ frames, y $D > m$, entonces habrá <em>thrashing</em></div></section><section id="last5"><h3>Working set</h3><div>¿Cómo implementarlo?: aprovechando los <em>reference bit</em></div><ul><li class="fragment"> Observar <em>reference bit</em> a intervalos regulares, cada $R$ referencias</li><li class="fragment"> <em>Reference bit</em> se copian y se borran</li><li class="fragment"> En la siguiente observación se comparan los valores copiados y los nuevos <em>reference bit</em>.</li><li class="fragment"> Páginas modificadas se mantienen dentro del <em>working set</em></li></ul><div>Permite aproximar el <em>working set</em>, a menor costo que analizar todas las referencias</div></section></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/js/reveal.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    width: 1600,
    height: 900,

    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    math: {
        mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
        // config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
    },

    // Optional reveal.js plugins
    dependencies: [

        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },

        // Markdown
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' );} },

        // Highlight <code>
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/highlight/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Mathjax
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/math/math.min.js', async: true },

        // Zoom
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/zoom-js/zoom.min.js', async: true },

        // Speaker Notes
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/notes/notes.min.js', async: true }

        // Title footer
        //{ src: '/js/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }
    ]
});</script></body></html>