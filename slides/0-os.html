<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>0 - Caracterización de Sistemas Operativos</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta content="Dietrich Daroch" name="author" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/reveal.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/theme/white.min.css" id="theme" rel="stylesheet" /><link href="https://github.com/frederickf/presentable/raw/master/src/presentable.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/css/zenburn.min.css" rel="stylesheet" /></head><body><div class="reveal"><div class="slides"><section><h2>Sistemas Operativos y Redes</h2><h1>0 - Caracterización de Sistemas Operativos</h1><p>Semestre 1/2016</p><p>Cristian Ruz - cruz@ing.puc.cl</p><p style="padding-top:4em;">Departamento de Ciencia de la Computación</p><p>Pontificia Universidad Católica de Chile</p></section><section><h2>Estructura de un Sistema Operativo</h2><section data-transition="fade"><div>¿Dónde vive el Sistema Operativo?</div><div class="fragment"><img width="50%" src="/images/figures/00-os-location.jpg" /></div></section><section data-transition="fade"><div>Sistema Operativo <b>es</b> <i>software</i></div><div><img width="50%" src="/images/figures/00-os-location.jpg" /></div></section><section data-transition="fade"><div>Sistema Operativo <b>habla con</b> el <i>hardware</i></div><div><img width="50%" src="/images/figures/00-os-location.jpg" /></div><div class="fragment">¿Qué pasaría si no hubiese sistema operativo? ... <span class="fragment">Antes no había</span></div></section><section data-transition="fade"><div>¿Interactuamos con el Sistema Operativo?</div><div><img width="50%" src="/images/figures/00-os-location.jpg" /></div><div class="fragment">Normalmente interactuamos con <b>interfaces de usuario</b>: <span class="fragment"><b>shell</b>, <b>GUI</b></span></div></section><section data-transition="fade"><div>¿User mode?, ¿kernel mode?</div><div><img width="50%" src="/images/figures/00-os-location.jpg" /></div><div class="fragment">Solo el Sistema Operativo utiliza el <i>kernel mode</i> ... <span class="fragment"><i>(a.k.a. monitor, privileged, system, supervised)</i></span></div></section></section><section><h2>¿Qué es un Sistema Operativo?</h2><section><p class="fragment"><i>Software</i> ... <span class="fragment">que corre en <i>kernel mode</i></span></p><p class="fragment">No hace mucho por sí mismo (es como el gobierno)</p><p class="fragment">Pero es fundamental</p><p class="fragment">Sería inútil sin programas/aplicaciones/usuarios (personas)</p></section><section><h3>¿Qué hace el sistema operativo?</h3><ul><li class="fragment" data-fragment-index="1">Para el usuario:</li><blockquote class="fragment" data-fragment-index="3" style="background: #F4C7C3;">Permite <strong>utilizar los recursos</strong> del computador (el <i>hardware</i>)</blockquote><span class="fragment" data-fragment-index="4">Ejecutar programas, leer archivos, efectuar cálculos ... de manera limpia, fácil y rápida</span><br /><br /><br /><li class="fragment" data-fragment-index="2">Para el sistema computacional:</li><blockquote class="fragment" data-fragment-index="5" style="background: #F4C7C3;">Permite <b>administrar los recursos</b></blockquote><span class="fragment" data-fragment-index="6">Permite <b>multiplexar</b> el uso de los recursos (escasos) entre múltiples programas.</span><ul><li class="fragment">Multiplexión en tiempo: turnos. Ejemplo: uso de CPU(s), uso de impresora</li><li class="fragment">Multiplexión en espacio: división del recurso. Ejemplo: procesos cargados en memoria, programas almacenados en disco</li></ul></ul></section></section><section><h2>Historia de los Sistemas Operativos</h2><section><p>Érase una vez ...</p><div class="fragment" style="display:inline-block; width=50px"><div>Charles Babbage (1791-1871)</div><div><img src="/images/figures/00-babbage.jpg" width="20%"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</img><img src="/images/figures/00-babbage-analytical.jpg" width="20%" /></div></div><div class="fragment" style="display:inline-block; width=50px"><div style="display:inline-block;">and the Analytical Engine  </div></div></section><section><div style="display:inline-block; width=50px"><div>Ada Lovelace (1815-1852)</div><div><img src="/images/figures/00-AdaLovelace.jpg" width="20%">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</img><img src="/images/figures/00-AdaLovelace-algorithm.jpg" width="20%" /></div></div><div class="fragment" style="display:inline-block; width=50px"><div style="display:inline-block;">and the First Algorithm  		</div></div></section><section><h3>Primera Generación (1945-55): Tubos de vacío</h3><p>Colossus Mark 2 @ Bletchley Park (incluyendo a Alan Turing)</p><div><img src="/images/figures/00-colossus.jpg" width="60%" /></div></section><section data-transition="fade"><h3>Primera Generación (1945-55): Tubos de vacío</h3><p>ENIAC @ U.Pennsylvania</p><div><img src="/images/figures/00-ENIAC.jpg" width="40%" /></div></section><section data-transition="fade"><ul><li>Programación via conexión de cables (y luego, tarjetas perforadas)</li><li>No existían los lenguajes de programación (ni siquiera assembler)</li><li>Aprox. 20000 tubos de vacío</li></ul></section><section><h3>Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i></h3><p>Separación de roles: diseñador, constructor, programador, operador, mantenedor</p><p><b>Mainframes</b></p><div><img src="/images/figures/00-ibm1401.jpg" width="30%" /></div><p>IBM1402 (card reader), IBM1401 (processing), IBM1403 (printer)</p></section><section data-transition="fade"><p>Modo de operación: ejecución de un <b>job</b></p><ul><li>Programador escribe en FORTRAN (tarjetas perforadas) y entrega a operador</li><li>IBM1401 pasa tarjetas a cinta (operador lleva cinta a IBM7094)</li><li>IBM7094 procesa cinta (operador lleva cinta a IBM1403)</li><li>IBM1403 imprime resultados</li></ul><div><img src="/images/figures/00-ibm7094.jpg" width="30%" /></div><p>IBM7094</p></section><section data-transition="fade"><p>Proceso de <i>trabajo por lotes</i>, <b>batch</b></p><ul><li>Uso de lenguajes: assembler y FORTRAN</li><li>Sistema Operativo: FMS (Fortran Monitor System)</li><li>Sistema Operativo: IBSYS (para el IBM7094)</li></ul></section><section><h3>Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación</h3><p>IBM unifica sus <i>mainframes</i> en System/360. Misma arquitectura e instruction set.</p><blockquote>Primeros en utilizar <b>circuitos integrados</b></blockquote><div><img src="/images/figures/00-ibms360.jpg" width="40%" /></div></section><section data-transition="fade"><h3>Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación</h3><p>Si el <i>hardware</i> está unificado, ¿por qué no el <i>software</i>?</p><p class="fragment"><b>OS/360</b> (Fred Brooks)</p><p class="fragment">Mientras se procesa I/O, la CPU no realizaba trabajo</p><blockquote class="fragment" style="background: #F4C7C3;">OS/360 introduce la <b>multiprogramación</b></blockquote><ul><li class="fragment">Particionamiento de la memoria</li><li class="fragment">Si un proceso no está ocupando la CPU, se entrega a otro</li></ul></section><section data-transition="fade"><h3>Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación</h3><p>Posibilidad de cargar un programa de tarjeta a memoria en el momento que un espacio queda libre</p><blockquote class="fragment" style="background: #F4C7C3;">Simultaneous Peripheral Operation On Line <b>SPOOLing</b></blockquote></section><section data-transition="fade"><h3>Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación</h3><p>Usuarios aún deben esperar horas para obtener un resultado. <span class="fragment">¿Y si hay error de compilación?</span></p><p class="fragment">Solución: que múltiples usuarios puedan utilizar el computador simultáneamente</p><blockquote class="fragment" style="background: #F4C7C3;"><b>Timesharing</b></blockquote><p class="fragment">Cada usuario posee un terminal para entregar comandos al computador.</p><ul class="fragment"><li>CTSS (Compatible Time Sharing System), MIT.</li><li>Primer sistema de timesharing de propósito general.</li><li>Problema: usuarios deben tener cuidado de no alterar el trabajo de otros</li></ul></section><section data-transition="fade"><h3>Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación</h3><p>MIT, Bell Labs, General Electric, deciden crear un sistema que soporte cientos de usuarios.</p><ul><li class="fragment">MULTICS (MULTIplexed Information and Computing Service)</li><li class="fragment">Escrito en lenguaje PL/I (poco popular y con un compilador deficiente)</li><li class="fragment">Bell Labs y General Electric abandonan</li></ul><p class="fragment">Visión de MULTICS: sistema de computación que pueda ser accedido por múltiples usuarios, en que el <i>mainframe</i> ejecuta todo, y usuarios acceden a través de terminales "livianos"</p></section><section data-transition="fade"><h3>Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación</h3><p>DEC (Digital Equipment Corporation) produjo su propia seria de minicomputadores, desde PDP-1 al PDP-11</p><p class="fragment">1970. Ken Thompson y Dennis Ritchie escriben una versión reducida de MULTICS para un PDP-7 abandonado.</p><blockquote class="fragment" style="background: #F4C7C3;">Al ser un MULTICS reducido, lo llaman UNICS, y finalmente <b>UNIX</b></blockquote><ul><li class="fragment">1972. Dennis Ritchie reescribe el código de Unix en C</li><li class="fragment">Surgen muchas versiones (incompatibles entre sí), pero dos sobreviven</li><li class="fragment"><b>System V</b>, de AT&T, y <b>BSD</b> (Berkeley Software Distribution) de U.C.Berkeley.</li><li class="fragment">IEEE desarrolla una interfaz estándar: <b>POSIX</b></li></ul></section><section data-transition="fade"><h3>Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación</h3><p>1987. Andrew Tanenbaum desarrolla una versión simplificada con objetivos educacionales: MINIX</p><p class="fragment">1991. Linus Torvalds, inspirado en MINIX, escribe su propia versión: <b>LINUX</b></p></section><section><h3>Cuarta Generación (1980-): Computadores Personales</h3><p>LSI (Large Scale Integration) posibilita la construcción de miles de transistores en 1cm2. <span class="fragment">Surgen los computadores personales, o <b>microcomputadores</b></span></p><ul><li class="fragment">1974. Intel 8080. Primera CPU de propósito general de 8-bit. No tiene S.O.</li><li class="fragment">Gary Kildall, consultor, escriben <b>CP/M</b> (Control Program for Microcomputers) en un diskette de 8''.</li><li class="fragment">Intel no se interesa, y entrega CP/M de vuelta a Gary Kildall.</li><li class="fragment">1977. Gary Kildall funda Digital Research y adapta CP/M para otras CPU.</li><li class="fragment">1980. IBM crea el IBM PC. Para probarlo obtienen un intérprete BASIC de <span class="fragment">Bill Gates</span></li><li class="fragment">IBM PC no tiene Sistema Operativo. Bill Gates sugiere que contacten a Gary Kildall</li><li class="fragment">Kildall rechaza a IBM. IBM solicita un Sistema Operativo a Bill Gates.</li><li class="fragment">Bill Gates compra <b>DOS</b> a Seatlle Computer Products, y lo ofrece a IBM.</li><li class="fragment">Bill Gates contrata a Tim Patterson en su nueva compañía, Microsoft, y producen <b>MS-DOS</b></li><li class="fragment">MS-DOS se populariza al ser ofrecido a empresas de computación y no a usuarios.</li></ul></section><section data-transition="fade"><h3>Cuarta Generación (1980-): Computadores Personales</h3><p>GUIs atraen a usuarios que no saben (ni les interesa) el funcionamiento del computador.</p><ul><li class="fragment">1983. IBM PC/AT, con Intel 80286 y MS-DOS.</li><li class="fragment">MS-DOS ampliamente usado con Intel 80386 y 80486.</li><li class="fragment">Tanto CP/M como MS-DOS usaban una <b>shell</b> (línea de comandos) como interacción.</li><li class="fragment">1960s. Doug Engelbart inventa las <b>GUI</b> (Graphical User Interface), que empiezan a ser usadas en XEROX PARC.</li><li class="fragment">Steve Jobs conoce la GUI en XEROX PARC y la incorpora su siguiente computador Apple: <span class="fragment">Macintosh</span></li></ul></section><section data-transition="fade"><h3>Cuarta Generación (1980-): Computadores Personales</h3><p>Microsoft adopta GUIs: Windows</p><ul><li class="fragment">1985-1995. MS-DOS ejecuta Windows como una aplicación de usuario.</li><li class="fragment">1995. Windows 95 reemplaza a MS-DOS.</li><li class="fragment">Windows 95 y Windows 98 aún mantienen código assembler Intel 16-bit.</li><li class="fragment">Microsoft reescribe Windows completamente para 32-bit. Windows New Technology: <span class="fragment">Windows NT</span></li><li class="fragment">1999. Windows NT 4.0 y Windows 2000 se posicionan en el ámbito corporativo.</li><li class="fragment">Windows Me termina con la línea de Windows 95/98.</li><li class="fragment">2001. Windows 2000 evoluciona a Windows XP.</li><li class="fragment">Línea server. Windows 2003 Server, Windows 2008.</li><li class="fragment">Línea client. Windows Vista, Windows 7, Windows 8, Windows 10.</li></ul></section><section data-transition="fade"><h3>Cuarta Generación (1980-): Computadores Personales</h3><p>Evolución de UNIX</p><ul><li class="fragment">UNIX popular en ambiente de servidores. </li><li class="fragment">Linux crece en computadores personales.</li><li class="fragment"><b>FreeBSD</b> deriva de BSD. OSX es una versión modificada de FreeBSD.</li><li class="fragment">MIT produce un sistema de ventanas para UNIX: X Windows System (luego X11).</li><li class="fragment">UNIX adopta GUIs que funcionan sobre X11 (Gnome, KDE, XFCE, etc)</li><li class="fragment">Windows Me termina con la línea de Windows 95/98.</li></ul></section><section><h3>Quinta Generación (1980-): Computadores Móviles</h3><p>Evolución de dispositivos móviles</p><ul><li class="fragment">1946. Primer teléfono móvil. 40 kg.</li><li class="fragment">1970. Teléfono móvil de 1 kg. (ladrillo)</li><li class="fragment">1990s. Nokia N9000 combina teléfono con PDA (Personal Digital Assistant)</li><li class="fragment">Primeros sistemas operativos para móviles: SymbianOS</li><li class="fragment">2002. RIM. Blackberry OS</li><li class="fragment">2007. Apple. iOS.</li><li class="fragment">2008. Google. Android. Basado en Linux.</li><li class="fragment">2011. Nokia cambia SymbianOS por Windows Phone.</li></ul></section></section><section><h2>¿De qué tamaño es un Sistema Oprerativo?</h2><section><p class="fragment"><a href="http://www.informationisbeautiful.net/visualizations/million-lines-of-code">(¿Megas? ¿Kilos? ¿Gigas?)</a></p><ul><li class="fragment">Windows 7: \( \sim 40\times 10^6 \) líneas de código</li><li class="fragment">Linux: \( \sim 15 \times 10^6 \) líneas de código</li></ul></section><section><h3>¿Qué incluye?</h3><ul><li class="fragment">Sistema Operativo</li><blockquote class="fragment">Sistema Operativo = Kernel + Programas del Sistema</blockquote><li class="fragment">Kernel</li><blockquote class="fragment">Un programa que <strong>siempre</strong> se está ejecutando.<br/>Provee funcionalidad mínima: acceso a CPU, memoria, dispositivos.</blockquote><li class="fragment">Programas del sistema</li><blockquote class="fragment">Extienden las funciones del kernel.</blockquote></ul></section></section><section><h2>¿Por qué estudiar Sistemas Operativos?</h2><h6><small>(o ¿por qué no?)</small></h6><section><ul><div class="fragment"><li>Piezas de software complejas</li><ul><li>Años de estudio y evolución</li><li>¿Cuántos sistemas operativos distintos manejan?</li><li>¿Cuántos sistemas operativos distintos usarán?</li></ul></div><div class="fragment"><li>Un Sistema Operativo tiene múltiples desafíos:</li><ul><li>¿Cómo proveer sistemas de alto rendimiento?</li><li>¿Cómo consumir la menor cantidad de energía?</li><li>¿Cómo asegurar que un usuario no altere datos o programas privados?</li></ul></div></ul></section></section><section><h2>Conceptos de Sistemas Operativos</h2><p class="fragment"><b>Administración de procesos</b></p><ul><li class="fragment">Proceso</li><li class="fragment">Tablas (árbol) de proceso</li><li class="fragment">Comunicación entre procesos</li></ul><p class="fragment"><b>Administración de memoria</b></p><ul><li class="fragment">Espacios de direcciones</li><li class="fragment">Memoria Virtual</li></ul><p class="fragment"><b>Administración de almacenamiento</b></p><ul><li class="fragment">Archivos</li><li class="fragment">Directorios</li><li class="fragment">Rutas absolutas y relativas</li></ul></section><section><h2>¿Cómo funciona el Sistema Operativo?</h2><p>El Sistema Operativo está siempre en ejecución <span class="fragment">¿y el usuario?</span></p><blockquote class="fragment">Los Sistemas Operativos son manejados por <b>interrupciones</b> / <b>traps</b>.</blockquote><p class="fragment">Mientras nadie (usuario/programa) lo llame, el S.O. no hace nada.</p><ul><li class="fragment"><em>Trap</em>: interrupción generada por software</li><ul class="fragment"><li>Error o solicitud de un programa</li><li>Por cada solicitud, el S.O. toma una acción</li></ul><li class="fragment">S.O. debe asegurar que errores en un programa no afecten a otro</li><ul class="fragment"><li>¿Qué pasa si un programa entra en un loop infinito?</li><li>¿Si un programa trata de modificar memoria de otro programa? ¿o del S.O.?</li><li>Habría que asegurar que solo un proceso puede estar en modo ejecutable</li></ul><li class="fragment">Pero el S.O. sí debería poder modificar la memoria de otro programa, para cargarlo/descargarlo</li></ul></section><section><h2>Modos de operación de un Sistema Operativo</h2><section><br /><img width="60%" src="/images/figures/00-1_10.pdf.png" /><p>Modo dual suportado por hardware: mode bit (0=kernel/1=user)</p><p class="fragment"><strong>Solo puede ser modificado por el S.O.</strong> (¿por qué?)</p><p class="fragment">Kernel mode, a.k.a. (Privileged | Supervised | Monitor | System) mode</p><blockquote class="fragment">Instrucciones privilegiadas solo pueden ejecutar en modo kernel <br/>Si se intenta ejecutar en mode=1, el hardware no la ejecuta y genera una interrupción para el S.O. Evita acceso indebido de otros usuarios</blockquote><p class="fragment">Ej: cambio mode bit, llamada I/O, manejo timer, manejo de interrupciones</p></section><section><p>Multi-modos: Más de dos modos de operación, ¿para qué?</p><ul><li class="fragment">Útil para virtualización</li><li class="fragment">VMM (<em>Virtual Machine Manager</em>) opera en modo intermedio</li><ul class="fragment"><li>Menos privilegios que S.O.</li><li>Más privilegios que cada <em>Virtual Machine</em></li></ul></ul><div class="fragment"><img width="40%" src="/images/figures/00-1_20.pdf.png" /></div></section><section><p>Programas de usuario hacen llamadas al S.O para que ejecute acciones a nombre de ellos</p><ul><li class="fragment"><em>syscall</em>, <em>trap</em></li></ul><br /><br /><p class="fragment">¿Qué puede pasar si no hay bit mode? (Intel 8088 no lo tenía)</p><ul><li class="fragment">Mode bit permite protección de hardware</li><li class="fragment">Si un programa comete un acceso indebido o error, trap al S.O.</li><li class="fragment">¿Cómo evitar que un programa no devuelva el control al SO?</li></ul></section></section><section><h2>Llamadas al sistema</h2><section><h4>System Calls</h4><p>Programas utilizan llamadas al sistemas frecuentemente</p><p>Ej: <code>copy source.txt dest.txt</code>... ¿qué requiere?</p><ul><div class="fragment"><li>Abrir <code>source.txt</code></li><ul><li>¿Existe? ¿Tiene permisos?</li></ul></div><div class="fragment"><li>Abrir <code>dest.txt</code></li><ul><li>¿Existe? ¿se reemplaza? ¿Se puede escribir?</li></ul></div><li class="fragment">Lectura/escritura en disco requiere llamadas al sistema</li><li class="fragment">Terminar el programa en caso de error, requiere llamadas al sistema</li></ul></section><section><h4>API: Application Programming Interface</h4><p>Sistemas Operativos proveen una API para el programador.</p><ul><li class="fragment">Windows API</li><li class="fragment">POSIX API (UNIX, Linux, MacOS X), a través de <span style="font-family:'Lucida Console', monospace">libc</span></li><li class="fragment">Java API (para la JVM)</li></ul><br /><p class="fragment">¿Cómo usarla?</p><div class="fragment"><p>eg:</p><pre style="width:50%;"><code class="hljs">count = read(fd, buffer, nbytes);</code></pre></div></section><section><img style="max-width:60%; max-height:60%" src="/images/figures/00-2_06.pdf.png" /></section><section><img style="max-width:60%; max-height:60%" src="/images/figures/00-syscall-read.png" /></section><section><img style="max-width:50%; max-height:50%" src="/images/figures/00-syscalls-posix.png" /></section><section><img style="max-width:50%; max-height:50%" src="/images/figures/00-syscalls-posix-win32.png" /></section></section><section><h2>Elementos y Servicios de un Sistema Operativo</h2><section><p>At a glance...</p><img width="80%" src="/images/figures/00-2_01.pdf.png" /></section></section><section><h2>Interfaces de Usuario (UI)</h2><section><p>Varias alternativas...</p><ul><li class="fragment"><em>Command-Line Inteface (CLI):</em> Comandos se ingresan por teclado</li><li class="fragment"><em>Batch interface:</em> Comandos se ingresan en archivos</li><li class="fragment"><em>Graphical User Interface (GUI):</em> Sistema de ventanas + <em>pointing-device</em></li></ul></section><section><h4>Command-Line (línea de comandos) <span class="fragment">(<strong>shells</strong>)</span></h4><p class="fragment">Para UNIX</p><div class="fragment"><ul><li><em>Bourne shell</em>: Stephen Bourne, 1977, UNIX, <code>sh</code></li><li><em>C shell</em>: Bill Joy, 1978, BSD UNIX, <code>csh</code></li><li><em>TENEX C Shell</em>: Ken Greer, 1983, <code>tcsh</code></li><li><em>Korn shell</em>: David Korn, 1983, <code>ksh</code></li><li><em>Bourne-Again shell</em>: Brian Fox, 1989, <code>bash</code></li><li><em>Z shell</em>: Paul Fastad, 1990, <code>zsh</code></li></ul></div><p class="fragment">En windows</p><div class="fragment"><ul><li><em>MS-DOS prompt</em>: MS-DOS, Win95/98/Me, <code>COMMAND.COM</code></li><li><em>Command Prompt</em>: <code>cmd.exe</code></li><li><em>PowerShell</em></li></ul></div></section><section><h4>Command-Line (línea de comandos)</h4><p>Uso común:</p><ul><li>Solicitar comando/instrucción al usuario y ejecutarlo</li><li>Formato: <code>prompt comando [parametros]</code></li></ul><div class="fragment"><p><em>Command Prompt</em> (símbolo del sistema)</p><ul><li class="fragment">Indica que el sistema está lista para recibir un comando</li><li class="fragment">Usualmente un texto terminado en <code>$, %, #, :, ></code></li></ul></div><div class="fragment"><pre><code class="hljs">cruz$ ls

jabaier@grima$ cp clase-01.tex backup/

jnavon@www[15:35]:> rm tareaSistOp.*

dietr1ch@nb ~/SO/Tareas 
ls -d */ | parallel --tag 'cd {} && make'</code></pre></div></section><section><h4>Graphical User Interface (GUI)</h4><p>Interfaz gráfica (para quienes no les gusta escribir comandos)</p><div class="fragment"><ul><li>Usualmente con un <em>pointing-device</em> y ventanas</li><li>Métaforas: escritorio, íconos, carpetas, menúes</li><li>Más allá de <em>pointing-device</em>: gestos y acciones visuales</li></ul></div><p class="fragment">Vienen de los \(\sim\) 1970's</p><div class="fragment"><ul><li>Investigación de Xerox Palo Alto Research Center (PARC)</li><li>Primera interfaz gráfica: 1973</li><li>Popularizados en 1980s: Apple Macintosh (Mac OS)</li><li>Windows 1.0 agregó GUI a MS-DOS</li></ul></div></section><section><h4>Graphical User Interface (GUI)</h4><p>Tradicionalmente UNIX/Linux han sido manejados por CLI,</p><p class="fragment">pero se han desarrollado muchas GUIs</p><ul><li class="fragment">CDE (<em>Common Desktop Environment</em>): Unix, OpenVMS</li><li class="fragment">X-Windows Systems: Xfce, KDE, GNOME (Unix/Linux)</li><li class="fragment"><a href="https://wayland.freedesktop.org/">Wayland</a>: Nueva API de GUI (Linux)</li></ul><img style="max-width:50%;float:right;" src="/images/figures/00-Xwindows.png" /></section><section><img style="max-width:50%; max-height:50%" src="/images/figures/00-CDE.png" /><p>CDE (Common Desktop Environment)</p></section><section><img style="max-width:50%; max-height:50%" src="/images/figures/00-XFCE.png" /><p>Xfce</p></section><section><img style="max-width:50%; max-height:50%" src="/images/figures/00-GNOME.png" /><p>GNOME</p></section><section><img style="max-width:50%; max-height:50%" src="/images/figures/00-KDE.png" /><p>KDE (K Desktop Environment)</p></section></section><section><h2>Estructura: MS-DOS</h2><section><p>¿Sistemas <strong>monolíticos</strong> o sistemas <strong>modulares</strong>?</p><p class="fragment">Algunos ni siquiera tienen estructura</p><ul><li class="fragment">MS-DOS: sistema monolítico simple</li><li class="fragment">Nadie pensó que sería tan popular</li><li class="fragment">Intel 8088 no tenía protección de <em>dual mode</em></li><li class="fragment">¿Problemas? <span class="fragment">Seguridad</span></li></ul><br /><img style="float;right;" height="25%" width="25%" src="/images/figures/00-2_11.pdf.png" /></section></section><section><h2>Estructura: UNIX</h2><section><p>UNIX: Estructura monolítica diseñada de acuerdo al <em>hardware</em></p><img width="50%" src="/images/figures/00-2_12.pdf.png" /><p class="fragment">¿Problemas? <span class="fragment">Dificultad de mantenimiento</span></p></section></section><section><h2>Estructura: diseño por capas</h2><section><p>Capas se diseñan por niveles más <em>abstractos</em> de funcionalidad</p><ul><li>         Capa \(M\) invoca llamadas sobre capa \(M-1\)</li><li class="fragment">Ventaja: Facilidad de <em>debugging</em></li><li class="fragment">Desventaja: dificultad de definición de capas, eficiencia</li></ul><img width="25%" src="/images/figures/00-2_13.pdf.png" /><p class="fragment">THE (Technische Hogeschool Eindhoven), E. W. Dijkstra (1968) y estudiantes. 6 capas.</p></section></section><section><h2>Estructura: <em>microkernels</em></h2><section><p><b>Mach</b>: versión de UNIX usando diseño de <em>microkernel</em> (CMU)</p><ul><li class="fragment">Set de funcionalidades mínimas</li><li class="fragment">Otras funcionalidades agregadas como programas de usuario ¿dónde poner el límite?</li><li class="fragment">Ventaja: Sistemas pequeño y fácil de portar</li><li class="fragment">Desventaja: Mucha más interacción a través de <em>syscalls</em>!</li><li class="fragment"><b>Darwin</b> (MacOS X kernel) basado parcialmente en modelo Mach</li><li class="fragment"><b>Windows NT</b> usaba microkernel pero era más lento que Win95.</li><li class="fragment"><b>GNU/Hurd</b> es más lento que Linux.</li></ul><img width="50%" src="/images/figures/00-2_14.pdf.png" /></section></section><section><h2>Estructura: <i>Monolíticos</i> vs <i>microkernels</i></h2><section><img width="100%" src="/images/figures/00-mono-micro.png" /></section></section><section><h2>Estructura: <em>módulos</em></h2><section><p>Lo más común: <strong>loadable kernel modules</strong></p><ul><li>Kernel tiene un conjunto de componentes principales (<em>core</em>)</li><li>Módulos necesarios se agregan durante ejecución</li><li>Evita recompilar el kernel para cada nueva funcionalidad</li><li>Solaris, Linux, MacOS X, Windows</li><li>Ej: kernel con soporte de manejo de archivo + módulos por cada <em>filesystem</em></li></ul><img width="50%" src="/images/figures/00-2_15.pdf.png" /></section></section><section><h2>Al final: Estructuras híbridas</h2><section><p>En la práctica, pocos sistemas pueden ser encasillados</p><ul><li>Linux, Solaris, Windows tienen características monolíticas (performance!)</li><li>Pero algunas funcionalidades siguen el diseño de <em>microkernel</em></li><li>¡Y además permiten cargar módulos dinámicamente!</li></ul></section></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/js/reveal.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    width: 1600,
    height: 900,

    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    math: {
        mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
        // config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
    },

    // Optional reveal.js plugins
    dependencies: [

        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },

        // Markdown
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' );} },

        // Highlight <code>
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/highlight/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Mathjax
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/math/math.min.js', async: true },

        // Zoom
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/zoom-js/zoom.min.js', async: true },

        // Speaker Notes
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/notes/notes.min.js', async: true }

        // Title footer
        //{ src: '/js/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }
    ]
});</script></body></html>