---
title: Scheduling
layout: slide
---


section
	h2 Scheduling
	/  ----------

section
	h2 Scheduling
	/  ----------

	section
		p Planificación

		p.fragment En todos los problemas en que los recursos no son suficientes es necesario revisar cómo se distribuyen, <span class="fragment"> y aunque sean infinitos igual hay que administrarlos para evitar conflictos.</span>
		/! Hilbert's paradox
		/! https://en.wikipedia.org/wiki/Hilbert%27s_paradox_of_the_Grand_Hotel

		ul
			li.fragment Préstamo de libros en la biblioteca
			li.fragment Asignación de alumnos, cursos y salas
			li.fragment Tareas y empleados
		p.fragment Y dentro de lo que nos concierne,
		ul
			li.fragment Asignación de procesos a la CPU
			li.fragment Uso de I/O por los procesos
			ul
				li.fragment Disco
				li.fragment Memoria
				li.fragment Red
				li.fragment '/dev/*' audio, gpu,&hellip;
				/! QoS


section#cpuSched
	h2 CPU-Scheduling
	/  ----------
section#cpuSched-init_
	h2 CPU-Scheduling
	/  ----------

	section#cpuSched-init
		p <strong>¡Multiprogramación y Time-sharing (<em>multitasking</em>)!</strong>

		p.fragment Objetivo de tener multiprogramación:
		ul.fragment
			li <strong>Maximizar utilización de (una) CPU</strong>

		p.fragment Objetivo de tener <em>multitasking</em>
		ul.fragment
			li <strong>Asignar tiempo de (una) CPU frecuentemente a todos los procesos</strong>


		/p.fragment ¿Qué queremos?        <span class="fragment"><strong>¡Multiprogramación y Time-sharing (<em>multitasking</em>)!</strong></span>
		/p.fragment ¿Cuándo lo queremos?  <span class="fragment"><strong>ASAP</strong></span>
		.fragment
			= image_tag 'images/cpuSched-mp-mt-now.png'
		/p.fragment ¿Cómo lo conseguimos? <span class="fragment">Con <strong>¡planificación (<em>scheduling</em>)!</strong></span>

	section#cpuSched-how
		p Muchos procesos en estado <em>ready</em>

		p.fragment &hellip; ¿qué hacer con ellos?
		p.fragment <strong>¡Colas!</strong>


	section#cpuSched-queues
		p Colas de <em>scheduling</em>

		p Múltiples colas
		/ \includegraphics[width=8cm]{figs/01-3_05.pdf}


	/ section#cpuSched-queues-1
		p El <em>Scheduling</em> puede ser visto como un sistema de <em>manejo de colas</em>

		/ \includegraphics[width=8cm]{figs/01-3_06.pdf}

		p.fragment ¿Bajo qué criterio?
		p.fragment $\longrightarrow$ <strong>algoritmos de <em>scheduling</em></strong>


	section#cpuSched-queues
		p Distintos <em>schedulers</em> en un SO

		ul
			li [Long-term Scheduler]   <span class="fragment">Determina qué procesos son admitidos en la <em>cola ready</em>. Determina el <strong>grado de multiprogramación</strong>.</span>
			li [Short-term Scheduler]  <span class="fragment">Selecciona procesos <em>ready</em> de una o más colas para ejecutar.</span>
			li [Medium-term Scheduler] <span class="fragment">Modificación temporal del grado de multiprogramación, haciendo <strong>swapping</strong></span>

			/ \includegraphics[width=8cm]{figs/01-3_07.pdf}





	section#cpuSched-thrsh
		p ¿Y si estamos siempre haciendo <em>Scheduling</em> en vez de ejecutar programas?
		/   \framesubtitle{i.e. ``exceso de burocracia''}
		p.fragment <em>Scheduling</em> es importante para proveer <strong>multiprogramación</strong>
		p.fragment &hellip; pero <em>scheduling</em> y <em>context switch</em> <strong>son sólo <em>overhead</em></strong>

		ul
			li.fragment ¿Qué pasa si el <em>scheduler</em> demora más tiempo de lo que toma el proceso?
			li.fragment ¿Qué pasa si el <em>context switch</em> demora más tiempo de lo que toma el proceso?
			li.fragment ¿Qué pasa si se le asigna poco tiempo a cada proceso?
			li.fragment ¿Qué pasa si hay muchos procesos <em>ready</em>?

		blockquote.fragment
			| Contención de procesos se refleja en <strong>thrashing</strong>
/
  //   \onslide<8->{¿Los SS.OO. móviles permiten <em>multitasking</em>?}
  //   ul
  //     li.fragment  <9->{Hasta iOS 4, no había <em>multitasking</em> para procesos de usuasrio.}
  //     li.fragment  <10->{Android usa <em>servicios</em>: <em>multitasking</em> para procesos de sistema, que ejecutan tareas en el <em>background</em>}

/ Frame
  // %  \frametitle{Planificación de CPU}
  // %
  // %  <strong>¡Multiprogramación y Time-sharing (<em>multitasking</em>)!</strong>
  // %  
  // %  \onslide<2->{
  // %  \begin{block}{Objetivo de tener multiprogramación}
  // %    <strong>Maximizar utilización de (una) CPU</strong>
  // %  \end{block}
  // %  }
  // %
  // %  \onslide<2->{
  // %  \begin{block}{Objetivo de tener <em>multitasking</em>}
  // %    <strong>Asignar tiempo de (una) CPU frecuentemente a todos los procesos</strong>
  // %  \end{block}
  // %  }
  // %
  // %\end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  // %  \frametitle{Colas de <em>scheduling</em>}
  // %
  // %  Planificación puede ser vista como un sistema de <em>manejo de colas</em>
  // %
  // %  \onslide<2->{
  // %  \begin{center}
  // %    \includegraphics[width=8cm]{figs/01-3_06.pdf}
  // %  \end{center}
  // %  }
  // %  
  // %  \onslide<3->{¿Bajo qué criterio?}
  // %  \onslide<3->{ $\longrightarrow$ <strong>algoritmos de <em>scheduling</em></strong>}
  // %
  // %\end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Ejecución típica de un proceso}
  // 
  //   \begin{columns}
  //   \begin{column}[T]{8cm}
  //     Un proceso pasa por dos etapas
  //     ul
  //       li.fragment  Uso de CPU (CPU-burst)
  //       li.fragment  Espera por E/S (I/O-burst)
  //     \end{itemize}
  //     Procesos suelen estar dominados por uno u otro
  //     ul
  //       li.fragment  CPU-bound
  //       li.fragment  I/O-bound
  //     \end{itemize}
  //   \end{column}  
  //   \begin{column}[T]{4cm}
  //     \includegraphics[width=4cm]{figs/01-6_01.pdf}
  //   \end{column}
  //   \end{columns}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Ejecución típica de un proceso}
  //   \framesubtitle{Duración de CPU-burst}
  //   
  //   ¿Cuánto dura típicamente un CPU-burst?
  //   
  //   No hay una respuesta única, pero &hellip;
  //   
  //   \begin{center}
  //     \includegraphics[width=8cm]{figs/01-6_02.pdf}
  //   \end{center}
  //   
  //   Duración de CPU-burst podría afectar el algoritmo de <em>scheduling</em>
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Tipos de <em>scheduling</em></em>}
  // 
  //   Hay que tomar decisión de <em>scheduling</em> cuando:
  //   ul
  //     li.fragment <2->(a) Proceso pasa de <strong>Running</strong> a <strong>Waiting</strong>
  //     li.fragment <2->(b) Proceso pasa de <strong>Running</strong> a <strong>Ready</strong>
  //     li.fragment <2->(c) Proceso pasa de <strong>Waiting</strong> a <strong>Ready</strong>
  //     li.fragment <2->(d) Proceso termina
  //   \end{itemize}
  //   
  //   \onslide<3->{
  //   Dos tipos de <em>scheduling</em>
  //   
  //   \begin{block}{<em>Scheduling</em> con expropiación (<strong>preemptive</strong>)}
  //     Requiere interrupciones por <em>timer</em>
  //     
  //     Requiere cuidados de sincronización
  //   \end{block}
  // 
  //   \begin{block}{<em>Scheduling</em> sin expropiación (<strong>non-preemptive</strong>)}
  //     Sólo en (a) y (d). Proceso sólo libera la CPU voluntariamente.
  //     
  //     Windows 3.1, MacOS (antes de X). También se conoce como <em>scheduling cooperativo</em>
  //     
  //   \end{block}
  //   }
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Criterios de <em>scheduling</em>}
  // 
  //   ¿Qué algoritmo puede ser mejor? \onslide<2->{&hellip; depende}
  //   
  //   \begin{description}
  //      li.fragment <3->[Uso de CPU] Mantener la CPU lo más usada posible
  //      li.fragment <3->[Throughput] Cantidad procesos atendidos por unidad de tiempo
  //      li.fragment <3->[Turnaround time] Tiempo total de un proceso, incluyendo esperas (wall-clock time)
  //      li.fragment <3->[Waiting time] Tiempo de espera de un proceso en estado <strong>Ready</strong>
  //      li.fragment <3->[Response time] Importante para sistemas interactivos
  //   \end{description}
  //   
  //   \onslide<4->{¿Qué tiempo es mejor minimizar? ...}
  //   
  //   \onslide<4->{¿Tiempo promedio? ¿Tiempo máximo? ¿Varianza?}
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>First-Come First-Served</em> (FCFS)}
  //   \framesubtitle{Por orden de llegada}
  //   
  //   El más simple: una cola FIFO
  // 
  //   Ejemplo: Procesos en cola: $P=\{P_1,P_2,P_3\}$, con tiempos de ejecución (<em>burst-time</em>)
  //            $T=\{T_1=24,T_2=3,T_3=3\}$ en milisegundos
  //            
  //   ul
  //     li.fragment  Tiempo promedio de espera, para el orden $P_1, P_2, P_3$ \onslide<2->{$\to 17$ms}
  //     li.fragment  Tiempo promedio de espera, para el orden $P_2, P_3, P_1$ \onslide<2->{$\to 3$ms}
  //   \end{itemize}
  // 
  //   \onslide<3->{Non-preemptive}  
  //   ul
  //     li.fragment <4-> +Simple
  //     li.fragment <4-> -Poco predecible. Procesos CPU-bound pueden bloquear a los I/O-bound,
  //            bajo una secuencia ``desafortunada'' de llegada
  //   \end{itemize}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Shortest-Job First</em> (SJF)}
  //   \framesubtitle{El más corto primero}
  // 
  //   Ejemplo: Procesos en cola: $P=\{P_1,P_2,P_3,P_4\}$, 
  //            $T=\{T_1=6,T_2=8,T_3=7,T_4=3\}$
  // 
  //   ul
  //     li.fragment  Tiempo promedio de espera: \onslide<2->{$\to 7$ms}
  //     li.fragment <3->Con FCFS: \onslide<4->{$\to 10.25$ms}
  //   \end{itemize}
  // 
  //   ul
  //     li.fragment <4-> +¡Óptimo! en tiempo de espera promedio (demostrable)
  //     li.fragment <4-> -¿Cómo saber cuánto se tomará cada proceso?
  // %      ul
  // %        li.fragment  En <em>long-term scheduling</em> usuarios pueden especificar tiempo máximo 
  // %        li.fragment  En <em>short-term scheduling</em> hay que aproximarlo
  // %      \end{itemize}
  //   \end{itemize}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Shortest-Job First</em> (SJF)}
  //   \framesubtitle{El pronóstico del tiempo}
  //   
  //   Supuesto: el próximo <em>burst</em> durará lo mismo que el anterior
  //   
  //   \onslide<2->{Método de aproximación: <strong>promedio exponencial</strong> (<em>exponential average</em>)
  //                sobre los <em>burst</em> anteriores}
  //                
  //   \onslide<3->{
  //   Sea $t_n$ el tiempo que tomó el $n$-ésimo <em>burst</em>, y $\tau_{n+1}$ el valor predicho.
  //   Se define, con $0 \leq \alpha \leq 1$:
  //   \[ \tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n \]
  //   }
  //   
  //   \onslide<4->{
  //   $\alpha$ determina ``el peso de la historia'':
  //     ul
  //       li.fragment  $\alpha=0 \Rightarrow \tau_{n+1} = \tau_n$
  //       li.fragment  $\alpha=1 \Rightarrow \tau_{n+1} = t_n$
  //     \end{itemize}
  //   }
  //   
  //   \onslide<5->{
  //   Expansión:
  //   \[ \tau_{n+1} = \alpha t_n + (1-\alpha)\alpha t_{n-1} + &hellip; + (1-\alpha)^j \alpha t_{n-j} + &hellip; (1-\alpha)^{n+1}\tau_0 \]
  //   }
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Shortest-Job First</em> (SJF)}
  //   \framesubtitle{El pronóstico del tiempo}
  // 
  //   $\alpha = 1/2, \tau_0=10$
  //   
  //   \begin{center}
  //     \includegraphics[width=8cm]{figs/01-6_03.pdf}
  //   \end{center}
  // 
  // 
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Shortest-Job First</em> (SJF)}
  //   \framesubtitle{Versión <em>preemptive</em>}
  // 
  //   ¿Qué hacer cuando llega un proceso nuevo?
  //   
  //   \onslide<2->{
  //   Decidir en base al <strong>tiempo restante</strong>
  //   
  //   Ejemplo: $P=\{P_1,P_2,P_3,P_4\}$,
  //            tiempos de llegada $\{0,1,2,3\}$
  //            $T=\{8,4,9,5\}$  
  //   }
  //   
  //   \onslide<3->{
  //   ul
  //     li.fragment  Ejecución <em>preemptive</em>: \onslide<4->{$\to 6.5$ms} 
  //     li.fragment  Ejecución <em>non-preemptive</em>: \onslide<5->{$\to 7.75$ms}
  //   \end{itemize}
  //   }
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Scheduling</em> con prioridades}
  // %  \framesubtitle{}
  // 
  //   Cada proceso tiene asociada una <strong>prioridad</strong>
  //   
  //   ul
  //     li.fragment  Se atienden por orden de <strong>prioridad</strong>
  //     li.fragment  Prioridades iguales: FCFS
  //     li.fragment  SJF es un <em>caso particular</em> de este algoritmo (¿por qué?)
  //     li.fragment  Muchos criterios para definir prioridades
  //   \end{itemize}
  //   
  //   \onslide<2->{Puede ser <em>non-preemptive</em> o <em>preemptive</em> (si llega uno con mayor prioridad,
  //                ejecuta de inmediato)}
  //   
  //   \onslide<3->{
  //   ul
  //     li.fragment  -Inanición de los que tengan baja prioridad
  //   \end{itemize}
  //   }
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Round-Robin</em> (RR)}
  // %  \framesubtitle{}
  // 
  //   Ideal para <em>time-sharing</em>
  //   
  //   \onslide<2->{
  //   FCFS + Preemption + 
  //   <em>time quantum</em> o <em>time slice</em> $q$: unidad de tiempo\footnote{Típicamente $10$ a $100$ms}
  //   Cada proceso recibe un $q$ms para ejecutar.
  //   }
  //   
  //   \onslide<3->{
  //     Ejemplo: $P=\{P_1,P_2,P_3\}$,
  //            $T=\{24,3,3\}$  
  //   
  //   ul
  //     li.fragment  Tiempo de espera promedio: $\to 5.66$ms
  //   \end{itemize}
  //   }
  //   
  //   \onslide<4->{
  //   ul
  //     li.fragment  +Cada proceso recibe $1/n$ de CPU, para $n$ procesos
  //     li.fragment  +Ningún proceso espera más de $(n-1)\times q$ para ejecutar
  //     li.fragment  Altamente dependiente de la elección de $q$ (puede degenerar a FCFS)
  //   \end{itemize}
  //   }
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Colas Multinivel}
  // 
  //   Múltiples colas, divididas por tipo de proceso.
  //   
  //   \begin{center}
  //     \includegraphics[width=7cm]{figs/01-6_06.pdf}
  //   \end{center}
  //   
  //   Varias alternativas:
  //   ul
  //     li.fragment  Prioridades entre colas, FCFS dentro de cada cola
  //     li.fragment  RR entre colas, con quántums diferenciados
  //   \end{itemize}
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Colas Multinivel con Feedback (MLFQ)}
  // 
  //   Colas multinivel es muy rígido: procesos no cambian de cola
  // 
  //   \begin{center}
  //     \includegraphics[width=5cm]{figs/01-6_07.pdf}
  //   \end{center}
  //   
  //   ul
  //     li.fragment  Colas con quántum diferenciado. 
  //     li.fragment  Proceso que no terminan en su quántum pasan a cola inferior
  //     li.fragment  Proceso que entregan la CPU permanecen la misma cola
  //     li.fragment  Dentro de cada cola, <em>scheduling</em> es FCFS
  //     li.fragment  Favorece procesos con CPU <em>burst</em> cortos
  //     li.fragment  Eventualmente se puede promover de nivel a los que han esperado más
  //   \end{itemize}
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Scheduling</em> en multi-procesador}
  // 
  //   Para un procesador no hay una mejor solución &hellip; 
  //   \onslide<2->{para múltiples procesadores es más difícil}
  //   
  //   ul
  //     li.fragment <3-> Modo asimétrico: distintos tipos de procesos a distintos cores
  //     li.fragment <4-> Modo simétrico (SMP). Ampliamente soportado: Windows, Linux, MacOSX
  //       ul
  //         li.fragment  ¿colas por procesador o cola única?
  //         li.fragment  evitar que dos procesadores ejecuten el mismo proceso
  //       \end{itemize}
  //   \end{itemize}
  //     
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Scheduling</em> en multi-procesador}
  // 
  //   \begin{block}{<strong>Processor Affinity</strong> (afinidad)}
  //   Considera efectos de <em>cache</em>
  // 
  //   \onslide<2->{Es más conveniente que un proceso se mantenga en el mismo procesador}
  //   
  //   \end{block}
  // 
  //   \onslide<3->{
  //   \begin{block}{<strong>Load Balancing</strong> (balance de carga)}
  //   Objetivo: mantener carga similar entre procesadores
  //   
  //   \onslide<4->{Si hay procesadores desocupados, algunos
  //   procesos son migrados a ellos. Modo <em>push</em> ó <em>pull</em>}
  //     
  //   \end{block}
  //   }
  //   
  //   \onslide<5->{¿Objetivos conflictivos?}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Scheduling</em> en Windows}
  // 
  //   ul
  //     li.fragment  3.1, 95, 98. Preemptive para 32-bit. Cooperative para 16-bit.
  //     li.fragment  NT-based. MLFQ con 32 prioridades.
  //       ul
  //         li.fragment  16 prioridades normales
  //         li.fragment  16 prioridades <em>Real-Time</em>
  //         li.fragment  S.O. puede modificar prioridad para mejorar interactividad
  //       \end{itemize}
  //   \end{itemize}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Scheduling</em> en MacOS}
  // 
  //   ul
  //     li.fragment  Hasta MacOS 9: cooperativo. RR entre procesos.
  //     li.fragment  MacOSX: MLFQ con 4 prioridades
  //       ul
  //         li.fragment  Normal
  //         li.fragment  System high-priority
  //         li.fragment  Kernel mode only
  //         li.fragment  Real-time
  //       \end{itemize}
  //   \end{itemize}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Scheduling</em> en Linux}
  // 
  //   ul
  //     li.fragment  Linux 2.4. $O(n)$ <em>scheduler</em>. MLFQ. <em>Quantum</em>s no usados por completo se agregan a la siguiente ronda.
  //     li.fragment  Linux 2.6.0 a 2.6.22. $O(1)$ <em>scheduler</em>. Mejor soporte para SMP, mal soporte para tareas interactivas.
  //        ul
  //          li.fragment  Tiempo de selección independiente del número de procesos
  //        \end{itemize}
  //     li.fragment  Linux 2.6.23. <em>Completely Fair Scheduler</em> (CFS).
  //   \end{itemize}
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Resumen: <em>Scheduling</em>}
  //   \frametitle{Algunos puntos importantes}
  //   
  //   ul
  //     li.fragment  <em>Scheduler</em> permite seleccionar el próximo proceso del conjunto <em>ready</em>
  //     li.fragment  Debe ser una decisión rápida
  //     li.fragment  Diferentes métricas para comparar algoritmos de <em>scheduling</em>
  //     li.fragment  Algoritmos clásicos:
  //       ul
  //         li.fragment  FCFS: simple, tiempo de espera impredecible
  //         li.fragment  SJF: óptimo en tiempo de espera, difícil de predecir
  //         li.fragment  RR: mejor para <em>time-sharing</em>, depende de $q$
  //         li.fragment  Prioridades: con expropiación, apropiado para <em>real-time</em>
  //         li.fragment  Multicolas, MLFQ: flexible y base para <em>schedulers</em> reales
  //       \end{itemize}  
  //     li.fragment  <em>Scheduling</em> para multiprocesadores
  //       ul
  //         li.fragment  Arquitecturas SMP requiere <em>tradeoff</em> entre afinidad y balance de carga
  //       \end{itemize}
  //   \end{itemize}
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
  // \section{Sincronización de Procesos}
  // 
/ Frame
  //   \frametitle{Sincronización de Procesos}
  // 
  //   Cosas buenas:
  //   ul
  //     li.fragment  Tener <em>concurrencia</em> y <em>paralelismo</em>
  //     li.fragment  Crear <em>threads</em> livianos sobre el mismo espacio de memoria (no necesita <em>syscall</em> de <em>shared memory</em>) 
  //   \end{itemize}
  //   Pero &hellip;
  //   ul
  //     li.fragment  Hay que coordinarlos (¿por qué?)
  //   \end{itemize}
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Regreso al Productor/Consumidor}
  //   Solución con <em>threads</em> productor y consumidor. 
  //   Variable <code>counter</code> inicializada en <code>0</code> en memoria compartida.
  //   
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=true]{c}
  //   /** Productor **/
  //   while(true) {
  //     next_product = produce();
  //     while (counter == BUFFER_SIZE); /* do nothing */
  //     buffer[in] = next_product;
  //     in = (in+1)%BUFFER_SIZE;
  //     counter++;
  //   }
  // \end{minted}
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=true]{c}
  //   /** Consumidor **/  
  //   while(true) {
  //     while(counter == 0); /* do nothing */
  //     next_consumed = buffer[out];
  //     out = (out+1)%BUFFER_SIZE
  //     counter--;
  //     consume(next_consumed);
  //   }
  // \end{minted}  
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Regreso al Productor/Consumidor}
  // 
  //   ¿Qué podría salir mal?
  //   
  //   \onslide<2->{Supongamos <code>counter=13</code>. Considere la secuencia:}
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize]{c}
  //   counter++;  /** linea 7 productor **/
  //   counter--;  /** linea 6 consumidor **/
  // \end{minted}
  //   \onslide<3->{Resultado esperado: <code>counter == 13</code>}
  //   
  //   \onslide<4->{Pero también podría ocurrir <code>counter==12</code> o <code>counter==14</code> (what?)}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Regreso al Productor/Consumidor}
  //   \framesubtitle{Autoincremento en assembler o en bytecode}
  // 
  //   ¿Cómo se ejecutan los <code>++</code> y <code>--</code> en hardware?
  // 
  //   Línea 7 productor: <code>counter++</code>
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize]{nasm}
  //   load r1, counter  ; copia del valor desde memoria a registro 1 
  //   inc r1            ; autoincremento de registros es comun en muchas arquitecturas 
  //   store counter, r1 ; guarda el valor de r1 en memoria 
  // \end{minted}
  // 
  //   Línea 6 consumidor: <code>counter--</code>
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize]{nasm}
  //   load r2, counter
  //   dec r2
  //   store counter, r2
  // \end{minted}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Productor/Consumidor <em>multithreaded</em>}
  //   \framesubtitle{Because shit happens}
  //   
  //   Podría ocurrir este orden de ejecución (o talvez no)
  //   
  //   \begin{footnotesize}
  //   \begin{tabular}{llll}
  //   \onslide<2->{$t=0$ & productor  & <code>load r1, counter</code>  & $r_1=13, r2=?, \mathit{counter}=13$ \\ \hline}
  //   \onslide<3->{$t=1$ & productor  & <code>inc r1</code>            & $r_1=14, r2=?, \mathit{counter}=13$ \\ \hline}
  //   \onslide<4->{$t=2$ & consumidor & <code>load r2, counter</code>  & $r_1=14, r2=13, \mathit{counter}=13$ \\ \hline}
  //   \onslide<5->{$t=3$ & consumidor & <code>dec r2</code>            & $r_1=14, r2=12, \mathit{counter}=13$ \\ \hline}
  //   \onslide<6->{$t=4$ & productor &  <code>store counter, r1</code> & $r_1=14, r2=12, \mathit{counter}=14$ \\ \hline}
  //   \onslide<7->{$t=5$ & consumidor & <code>store counter, r2</code> & $r_1=14, r2=12, \mathit{counter}=12$ \\ }
  //   \end{tabular}
  //   \end{footnotesize}
  // 
  //   \onslide<8->{¿Podemos tener tan mala suerte para que ocurra así?}
  // 
  //   \onslide<9->{
  //   \begin{block}{<strong>Race condition</strong> (condición de carrera o competencia)}
  //     Situación en que la salida de una operación depende del orden temporal de sus operaciones internas,
  //     el cual no está bajo control del programador.
  //   \end{block}
  //   }
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Sincronización de <em>threads</em>}
  //   \framesubtitle{Un programador tenía un problema y decidió usar <em>threads</em>. tiene él problemas. Ahora dos }
  // 
  //   <em>Race conditions</em> hacen que el resultado de la ejecución no se pueda garantizar.
  //   \onslide<2->{
  //   \begin{alertblock}{<strong>Mala práctica</strong>}
  //      El resultado de una ejecución puede depender de la entremezcla (<em>interleaving</em>) de la ejecución de sus <em>threads</em>  
  //   \end{alertblock}
  //   }
  //   
  //   \onslide<3->{
  //   \begin{exampleblock}{<strong>Buena práctica</strong>}
  //     <strong>Evitar las race conditions</strong>
  //   \end{exampleblock}
  //   }
  //   
  //   \onslide<3->{¿Como? Empleando métodos de <strong>sincronización</strong> y <strong>coordinación</strong>.}
  //    
  // \end{frame}
  // %---------------------------------------------------------------------
  // \subsection{El Problema de la Sección Crítica}
  // 
/ Frame
  //   \frametitle{El Problema de la Sección Crítica}
  // 
  //   Considere un sistema de $n$ procesos, $\{P_0,P_1,&hellip;,P_{n-1}\}$.
  //   Cada proceso tiene un segmento de código llamado <strong>sección crítica</strong>
  //   ul
  //     li.fragment  Dentro de su sección crítica el proceso puede modificar recursos compartidos
  //   \end{itemize}
  //   
  //   \onslide<2->{
  //   \begin{block}{Problema de la Sección Crítica}
  //     Diseñar un protocolo que no permita que dos procesos se encuentren en su sección crítica al mismo tiempo
  //   \end{block}
  //   }
  //   
  //   \begin{center}
  //     \includegraphics[width=5cm]{figs/01-seccioncritica.png}
  //   \end{center}
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Requisitos para una solución}
  // 
  //   Una solución al problema de la sección crítica (SC) debe cumplir 3 requisitos:
  //   
  //   \begin{description}
  //     li.fragment [<strong>Exclusión Mutua</strong>] <em>A lo más uno</em>. Si $P_i$ se encuentra en su SC, entonces
  //                                  nadie más lo está.
  //     li.fragment [<strong>Progreso</strong>] <em>Al menos alguien puede entrar</em>. Si ningún proceso está en su SC, y hay
  //                           procesos que desean entrar, entonces los que quieren entrar deben ser capaces
  //                           de decidir quién entra, y decidirlo en un tiempo acotado.
  //     li.fragment [<strong>Espera acotada</strong>] <em>Ausencia de inanición</em>. Si un proceso quiere entrar a su SC, entonces
  //                                 después de una cantidad limitada de turnos, el proceso podrá entrar.
  //                                 Esto significa que nadie espera indefinidamente.
  //   \end{description}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
  // \subsection{Algunas soluciones al problema de la sección crítica}
  // 
/ Frame[fragile]
  //   \frametitle{Solución de Peterson}
  //   Solución para 2 procesos, propuesta por Gary L. Peterson, 1981.
  //   
  //   Variables compartidas: <code>int turn; boolean flag[2];</code>
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=true]{c}
  //   /** Codigo para proceso P_i, i $\in$ {0,1}, j=1-i */
  //   
  //   do {
  //     flag[i] = true;
  //     turn = j;
  //     while(flag[j] && turn == j);
  //     
  //     /** SECCION CRITICA **/
  //     
  //     flag[i] = false;
  //     
  //     /** resto del codigo **/
  //   
  //   } while(true);
  // 
  // \end{minted}
  // 
  // \onslide<2->{¿En qué valor se inicializan <code>turn</code> y <code>flag</code>?}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Solución de Peterson}
  //   \framesubtitle{¿Cumple los requisitos?}
  //   
  //   <strong>Exclusión Mutua</strong>
  //   
  //   ul
  //     li.fragment  $P_i$ puede entrar solamente si <code>flag[j]==false</code> ó <code>turn == i</code>
  //     li.fragment  Si $P_i$ y $P_j$ se encuentran ambos en la SC, entonces <code>flag[0]==flag[1]==true</code>
  //     li.fragment  <code>flag[0]==true</code> $\Rightarrow$ <code>turn=i</code>
  //     li.fragment  <code>flag[1]==true</code> $\Rightarrow$ <code>turn=j</code>
  //     li.fragment  Pero <code>i</code>$\neq$<code>j</code>, por lo tanto no pueden estar ambos en su SC
  //   \end{itemize}
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Solución de Peterson}
  //   \framesubtitle{¿Cumple los requisitos?}
  // 
  //   <strong>Progreso</strong>
  //   
  //   ul
  //     li.fragment  Si $P_i$ desea entrar a su SC, sólo puede estar detenido en la línea 6
  //     li.fragment  Entonces se cumple <code>flag[j]==true</code> y <code>turn==j</code>
  //     li.fragment  Si $P_j$ no desea entrar a su SC, entonces <code>flag[j]==false</code>
  //     li.fragment  Si $P_j$ desea entrar, entonces <code>turn==i</code> ó <code>turn==j</code>
  //     li.fragment  En cualquier caso, uno de los que quiere entrar, entra 
  //   \end{itemize}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Solución de Peterson}
  //   \framesubtitle{¿Cumple los requisitos?}
  // 
  //   <strong>Espera acotada</strong>
  //   
  //   ul
  //     li.fragment  Si $P_i$ desea entrar y está esperando, entonces <code>flag[i]==true</code>, <code>flag[j]==true</code> y <code>turn==j</code>
  //     li.fragment  En cuanto $P_j$ sale, establece <code>flag[j]=false</code>, y $P_i$ puede entrar (si empieza a ejecutar)
  //     li.fragment  Si $P_j$ intenta entrar inmediatamente, deberá establecer <code>flag[j]=true</code> y <code>turn=i</code>.
  //     li.fragment  Se cumple entonces <code>flag[i]==true</code>, <code>flag[j]==true</code>, y <code>turn=i</code>, con lo que $P_j$ no puede entrar.    
  //     li.fragment  Por lo tanto después de, a lo más, 1 turno, $P_i$ puede entrar (espera acotada)
  //   \end{itemize}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Sincronización por <em>hardware</em> }
  //   \framesubtitle{}
  // 
  //   Soluciones por <em>software</em> dependen de que existan <strong>instrucciones atómicas</strong> por <em>hardware</em>:
  //   instrucciones <strong>ininterruptibles</strong>
  // 
  //   Una solución más sencilla:
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** Exclusion mutua **/
  //     do {
  //       lock = true;
  //       while (lock == false);
  //       
  //       /* SECCION CRITICA */
  //       
  //       lock = false;
  //   
  //       /* resto del codigo */
  //       
  //   }  while(true);
  // \end{minted}
  //   
  //   ¿Basta con esto?
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Sincronización por <em>hardware</em> }
  //   \framesubtitle{<code>test_and_set()</code>}
  // 
  //   Algunas arquitecturas proveen instrucciones atómicas del tipo \verb+test_and_set+
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** test_and_set() **/
  //     boolean test_and_set (boolean *target) {
  //       boolean rv = *target;
  //       *target = true;
  //   
  //       return rv;
  //     }
  // \end{minted}
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Sincronización por <em>hardware</em> }
  //   \framesubtitle{Exclusión mutua con <code>test_and_set()</code>}
  // 
  //   ¿Cómo usarlo?
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** Exclusion mutua usando test_and_set() **/
  //     do {
  //       while (test_and_set(&lock));
  //       
  //       /* SECCION CRITICA */
  //       
  //       lock = false;
  //   
  //       /* resto del codigo */
  //       
  //   }  while(true);
  // \end{minted}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Sincronización por <em>hardware</em> }
  //   \framesubtitle{<code>compare_and_swap()</code>}
  // 
  //   Otra instrucción atómica: \verb+compare_and_swap+
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** compare_and_swap  **/
  //     boolean compare_and_swap (int *value, int expected, int new_value) {
  //       int temp = *value;
  // 
  //       if(*value == expected)
  //         *value = new_value;
  //   
  //       return temp;
  //     }
  // \end{minted}
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Sincronización por <em>hardware</em> }
  //   \framesubtitle{Exclusión mutua con <code>compare_and_swap()</code>}
  // 
  //   ¿Cómo usarlo?
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** Exclusion mutua usando test_and_set() **/
  //     do {
  //       while (compare_and_swap(&lock, 0, 1) != 0);
  //       
  //       /* SECCION CRITICA */
  //       
  //       lock = 0;
  //   
  //       /* resto del codigo */
  //       
  //   } while(true);
  // \end{minted}
  // 
  // Estos algoritmos ¿cumplen con las propiedades de solución para sección crítica?
  // 
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Sincronización por <em>hardware</em> }
  //   \framesubtitle{Una solución con <code>test_and_set()</code>}
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** Exclusion mutua usando test_and_set() para $n$ procesos **/
  //     do {
  //       waiting[i] = true;
  //       key = true;
  //       while (waiting[i] && key) 
  //         key = test_and_set(&lock);
  //       waiting[i] = false;
  //       /* SECCION CRITICA */
  //       j = (i+1)%n
  //       while((j != i) && !waiting[j])
  //         j = (j+1)%n;
  //       if(j == i) 
  //         lock = false;
  //       else
  //         waiting[j] = false;
  //       /* resto del codigo */
  //   } while(true);
  // \end{minted}
  // 
  // Ejercicio: probar que cumple las propiedades de la sección crítica
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Locks de Exclusión Mutua (<em>Mutex</em>) }
  //   \framesubtitle{}
  // 
  //   En general no se usan directamente soluciones por <em>hardware</em> sino que &hellip;
  //   \onslide<2->{se construyen primitivas de <em>software</em> sobre ellas}.
  //   
  //   \onslide<3->{La más simple: 
  //   \begin{block}{<strong>Mutex Lock</strong> (<strong>mut</strong>ual <strong>ex</strong>clusion)}
  //     Dos operaciones:
  //     ul
  //       li.fragment {<code>acquire()</code>}
  //       li.fragment {<code>release()</code>}
  //     \end{itemize}  
  //   \end{block}
  //   }
  // 
  // 
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Locks de Exclusión Mutua (<em>Mutex</em>) }
  //   \framesubtitle{}
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** Lock acquire **/
  //   acquire() {
  //     while(!available); /* busy wait */
  //     available = false;
  //   }
  // 
  //   /** Lock release **/
  //   release() {
  //     available = true;
  //   }
  // \end{minted}
  // 
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Locks de Exclusión Mutua (<em>Mutex</em>) }
  //   \framesubtitle{Sección crítica con <em>Mutex Locks</em>}
  // 
  //   Solución simple a sección crítica usando <em>Mutex Locks</em>
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   do {
  //     acquire();
  //     
  //     /** SECCION CRITICA **/
  //     
  //     release();
  //     
  //     /** resto del codigo **/
  // 
  //   } while(true);
  // \end{minted}  
  //   
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Semáforos}
  //   \framesubtitle{}
  // 
  //   <em>Mutex Locks</em> solo permiten un acceso a la sección crítica (<em>exclusión mutua</em>)
  //   
  //   \onslide<2->{En ocasiones se quiere un acceso acotado, pero mayor a 1}
  // 
  //   \onslide<3->{
  //   \begin{block}{<strong>Semáforo</strong>}
  //     Un semáforo <code>S</code> incluye un contador y dos operaciones:
  //     ul
  //       li.fragment  <code>P()</code> ó <code>wait</code>. Prueba a decrementar el valor.\footnote{Original: <em>proberen</em>, holandés para <em>probar</em>}
  //       li.fragment  <code>V()</code> ó <code>signal</code>. Incrementa el valor.\footnote{Original: <em>verhogen</em>, holandés para <em>incrementar</em>}
  //     \end{itemize}
  //   \end{block}
  //   }
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Semáforos}
  //   \framesubtitle{<code>P()</code> y <code>V()</code>, a.k.a., <code>wait</code> y <code>signal()</code>}
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** P(): bloquea si es $\leq$ 0 **/
  //   wait(S) {
  //     while(S <= 0); /* busy wait */
  //     S--;
  //   }
  // 
  //   /** V(): incrementa contador **/
  //   signal() {
  //     S++;
  //   }
  // \end{minted}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Semáforos}
  //   \framesubtitle{Sección crítica con semáforos}
  // 
  //   Una variante de la sección crítica: máximo de $r$ procesos en ella
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** Inicializar el semaforo en $r$  **/
  //   Semaphore S(r);
  // \end{minted}
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** Para cada proceso: **/
  //   do {
  //     wait(S);
  //     
  //     /** SECCION CRITICA **/
  //     
  //     signal(S);
  //     
  //     /* resto del codigo */
  //   }
  // \end{minted}
  // 
  // ¿Cuándo sirve esto?
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Semáforos}
  //   \framesubtitle{La maldición de la espera ocupada: ``lo llamamos''}
  // 
  //   Las definiciones propuesta de <em>mutex lock</em> y <em>semáforos</em> incluyen <strong>busy waiting</strong>
  //   \onslide<2->{&hellip; eso es <strong>malo</strong>}
  //   
  //   \onslide<2->{
  //   \begin{alertblock}{<strong>Busy waiting</strong> (espera ocupada)}
  //   
  //     Una solución que usa <em>busy waiting</em> <strong>NO ES</strong> una buena solución. 
  //     Desperdicia ciclos de CPU
  //   \end{alertblock}
  //   }
  //   
  //   \onslide<3->{¿Alternativas?}
  //   \onslide<4->{&hellip; ponerse en una cola de espera}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Semáforos}
  //   \framesubtitle{Implementando semáforos sin <em>busy waiting</em>}
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** Definicion del tipo semaforo **/
  //   typedef struct {
  //     int value;
  //     struct process *list;
  //   } semaphore;
  // \end{minted}
  // 
  // Un semáforo contiene un <em>valor</em>, y una <em>lista de procesos</em>.
  // 
  // Supongamos una instrucción <code>block()</code> que libera la CPU voluntariamente,
  // y una instrucción <code>wakeup(p)</code> que despierta al proceso <code>p</code>.
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Semáforos}
  //   \framesubtitle{Implementando semáforos sin <em>busy waiting</em>}
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   /** P(), wait() **/
  //   wait(semaphore *S) {
  //     S->value--;
  //     if(S->value < 0) {
  //       p = currentProcess();
  //       addToList(S->list, p);
  //       block();
  //     }
  //   }
  // 
  //   /** V(), signal() **/
  //   signal(semaphore *S) {
  //     S->value++;
  //     if(S->value <= 0) {
  //       p = extractFromList(S->list);
  //       wakeup(p);
  //     }
  //   }
  // \end{minted}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Semáforos}
  //   \framesubtitle{Cuidado con los bloqueos}
  // 
  //   Un uso poco cuidadoso de semáforos puede traer otro enemigo: el <strong>bloqueo mutuo</strong> ó <strong>deadlock</strong>
  //   
  //   \onslide<2->{Supongamos dos semáforos <code>S</code> y <code>Q</code>, y dos procesos $P_0$ y $P_1$}
  // 
  //   \begin{center}
  //   \begin{footnotesize}
  //   \begin{tabular}{ll}
  //   \onslide<2->{$P_0$ & $P_1$ \\ \hline}
  //   \onslide<3->{<code>wait(S);</code>   & <code>wait(Q);</code>  \\ }
  //   \onslide<4->{<code>wait(Q);</code>   & <code>wait(S);</code>  \\ }
  //   \onslide<5->{<code>&hellip;</code>     & <code>&hellip;</code>    \\ }
  //   \onslide<5->{<code>signal(S);</code> & <code>signal(Q);</code> \\ }
  //   \onslide<5->{<code>signal(Q);</code> & <code>signal(S);</code> \\ }
  //   \end{tabular}
  //   \end{footnotesize}
  //   \end{center}
  //   
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
  // \subsection{Problemas clásicos de sincronización}
  // 
/ Frame[fragile]
  //   \frametitle{Problema del buffer acotado}
  //   \framesubtitle{¿Otra vez el <em>buffer</em>?}
  // 
  //   ¿Cómo lo solucionamos con semáforos?
  //   
  //   Variables compartidas:
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   int BUFFER_SIZE;    /* tamano del buffer */
  //   semaphore mutex(1); /* semaforo de exclusion mutua (podria ser un lock) */
  //   semaphore empty(BUFFER_SIZE); /* para detener al consumidor */
  //   semaphore full(0);  /* para detener al productor */
  // \end{minted}
  // 
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Problema del buffer acotado}
  //   \framesubtitle{Buffer acotado con semáforos}
  // 
  // 
  //   \begin{columns}[c]
  //     \begin{column}[T]{6cm}
  //       \begin{center}
  //         <strong>Productor</strong>
  //       \end{center}
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   do {
  //     wait(empty);
  //     wait(mutex);
  // 
  //     next_product = produce();
  //     buffer[in] = next_product;
  //     in = (in+1)%BUFFER_SIZE;
  //     
  //     signal(mutex);
  //     signal(full);
  // 
  //   } while(true);
  // \end{minted}
  //     \end{column}
  //     
  //     \begin{column}[T]{6cm}
  //       \begin{center}
  //         <strong>Consumidor</strong>
  //       \end{center}
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   do {
  //     wait(full);
  //     wait(mutex);
  // 
  //     next_product = buffer[out];
  //     out = (out+1)%BUFFER_SIZE;
  //     consume(next_consumed);
  //     
  //     signal(mutex);
  //     signal(empty);
  // 
  //   } while(true);
  // \end{minted}
  //     \end{column}
  //   \end{columns}
  // 
  // 
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Problema de los lectores y escritores (<em>readers</em>/<em>writers</em>)}
  // 
  //   La sección crítica suele exigir <strong>solo un</strong> <em>thread</em> en ella.
  // 
  //   \onslide<2->{¿Y si solo permitimos lecturas?}
  //   \onslide<3->{ OK, entonces $n$ lectores simultáneos}
  //   
  //   \onslide<4->{¿Y si alguien quiere escribir?}
  //   \onslide<5->{ Entonces, que solo <strong>uno</strong> pueda escribir}
  //   
  //   \onslide<6->{Condiciones distintas para cada rol}
  //   
  //   \onslide<7->{
  //   \begin{block}{<strong>Problema de lectores y escritores</strong>}
  //     Permitir acceso de $n$ lectores simultáneos, pero solamente 1 escritor
  //   \end{block}
  //   }  
  //   
  //   \onslide<8->{Hay variaciones: lectores ilimitados, escritores con prioridad}
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Problema de los lectores y escritores (<em>readers</em>/<em>writers</em>)}
  // 
  //   Variables compartidas
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   semaphore rw_mutex(1); /* semaforo para lectores y escritores */
  //   semaphore mutex(1);    /* semaforo de exclusion mutua */
  //   int read_count = 0;    /* contador de lectores */
  // \end{minted}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Problema de los lectores y escritores (<em>readers</em>/<em>writers</em>)}
  // 
  //   \begin{columns}[c]
  //     \begin{column}[T]{6cm}
  //       \begin{center}
  //         <strong>Escritor</strong>
  //       \end{center}
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   do {
  //     wait(rw_mutex);
  // 
  //     /** WRITE **/
  //     
  //     signal(rw_mutex);
  // 
  //   } while(true);
  // \end{minted}
  //     \end{column}
  //     
  //     \begin{column}[T]{6cm}
  //       \begin{center}
  //         <strong>Lector</strong>
  //       \end{center}
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   do {
  //     wait(mutex);
  //     read_count++;
  //     if(read_count == 1)
  //       wait(rw_mutex);
  //     signal(mutex);
  //     
  //     /** READ **/
  //     
  //     wait(mutex);
  //     read_count--;
  //     if(read_count == 0)
  //       signal(rw_mutex);
  //     signal(mutex);
  //   } while(true);
  // \end{minted}
  //     \end{column}
  //   \end{columns}
  // 
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Problema de los filósofos comensales}
  //   \framesubtitle{Un clásico}
  // 
  //   5 filósofos se pasan la vida en dos actividades: <em>comer</em> y <em>pensar</em>
  //   
  //   \begin{center}
  //       \includegraphics[width=3cm]{figs/01-5_13.pdf}
  //   \end{center}
  //   
  //   \onslide<2->{Restricción 1: Para comer deben tomar ambos palillos}
  //   
  //   \onslide<3->{Restricción 2: Sólo pueden tomar un palillo a la vez}
  //    
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Problema de los filósofos comensales}
  // 
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   semaphore chopstick[5];
  //   do {
  //     wait(chopstick[i]);
  //     wait(chopstick[(i+1)%5]);
  //       ...
  //     /* COMER */
  //       ... 
  //     signal(chopstick[i]);
  //     signal(chopstick[(i+1)%5]);
  //       ...
  //     /* PENSAR */
  //       ...
  //   } while (true);
  // \end{minted}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Monitores}
  // 
  //   Construcción de sincronización de (más) alto nivel
  //   
  //   ul
  //     li.fragment  Provee métodos que permiten controlar el acceso exclusivo
  //     li.fragment  Utiliza <strong>variables de condición</strong>, que tiene dos operaciones
  //       \begin{exampleblock}{<strong>Variables de condición</strong>}
  //         ul
  //           li.fragment  <code>condition.wait()</code> bloquea <strong>siempre</strong> el <em>thread</em>
  //           li.fragment  <code>condition.signal()</code> despierta a un <em>thread</em> bloqueado, si lo hay
  //         \end{itemize}
  //         No son iguales a semáforos (pero pueden implementarse con ellos)
  //       \end{exampleblock}
  //   \end{itemize}
  // 
  //   ¿Semántica para <code>signal()</code>?
  //   ul
  //     li.fragment  <strong>Signal-and-continue</strong>: el que acaba de llamar a <code>signal()</code> continúa ejecutando (Java, C\#)
  //     li.fragment  <strong>Signal-and-wait</strong>: el que acaba de llamar a <code>signal()</code> se bloquea inmediatamente
  //   \end{itemize}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Filósofos Comensales Monitoreados}
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   monitor FilosofosComensales {
  //     enum {PENSANDO, HAMBRIENTO, COMIENDO} estado[5];
  //     condition filosofo[5];
  //     void tomar(int i) {
  //       estado[i] = HAMBRIENTO;
  //       probar(i);
  //       if(estado[i] != COMIENDO)
  //         filosofo[i].wait();
  //     }
  //     void soltar(int i) {
  //       estado[i] = PENSANDO;
  //       probar((i+4)%5);
  //       probar((i+1)%5);
  //     }
  //     void probar(int i) {
  //       if( (estado[(i+4)%5] != COMIENDO) && estado[i] == HAMBRIENTO && 
  //           (estado[(i+1)%5] != COMIENDO) ) {
  //         estado[i] = COMIENDO;
  //         filosofo[i].signal();
  //       }
  //     }
  //   }
  // \end{minted}
  // 
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Filósofos Comensales Monitoreados}
  // 
  //   La implementación de cada filósofo se reduce a:
  //   
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   do {
  //     FilosofosComensales.tomar(i);
  //       ...
  //     /* COMER */
  //       ... 
  //     FilosofosComensales.soltar(i);
  //       ...
  //     /* PENSAR */
  //       ...
  //   } while (true);
  // \end{minted}
  // 
  //   \onslide<2->{Pregunta 1: ¿Cómo deben inicializarse los estados?}
  //   
  //   \onslide<3->{Pregunta 2: ¿Cumple todas las condiciones del problema de la sección crítica?}
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Monitores usando semáforos}
  // 
  // 
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   monitor {
  //     semaphore mutex(1);
  //     semaphore next(0);
  //     int nextCount = 0;    /* cuantos estan esperando en next */
  //     condition {
  //       semaphore conditionSem(0); /* para bloquearse en la condicion */
  //       int count = 0;             /* cuantos esperan en la condicion */
  //       wait();
  //       signal();
  //     }
  //   }
  //  \end{minted}
  // 
  // \end{frame}
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Monitores usando semáforos}
  // 
  //   <code>condition.wait()</code>: <em>thread</em> se bloquea incondicionalmente
  // 
  //   <code>condition.signal()</code>: despierta a algún <em>thread</em> bloqueado, si lo hay
  //   
  //     \begin{columns}[c]
  //     \begin{column}[T]{5cm}
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   condition.wait() {
  //     count++;
  //     if(nextCount > 0)
  //       signal(next);
  //     else
  //       signal(mutex);
  //     wait(conditionSem);
  //     count--;
  //   }  
  // \end{minted}
  //     \end{column}
  //     \begin{column}[T]{5cm}
  // \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //   condition.signal() {
  //     if(count > 0) {
  //       nextCount++;
  //       signal(conditionSem);
  //       wait(next);
  //       nextCount--;
  //     }
  //   }
  // \end{minted}
  //     \end{column}
  //     \end{columns}
  // 
  // Esta implementación utiliza la semántica <em>signal-and-wait</em>.
  // 
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Resumen: Sincronización}
  //   \framesubtitle{Algunos puntos clave}
  // 
  //   ul
  //     li.fragment  Necesidad de sincronizar <em>thread</em> que ``compiten por datos''
  //     li.fragment  Problema de la sección crítica:
  //       ul
  //         li.fragment  Exclusión mutua, progreso, espera acotada
  //       \end{itemize}
  //     li.fragment  Primitivas básicas de sincronización:
  //       ul
  //         li.fragment  <em>Hardware</em>, Locks, semáforos
  //       \end{itemize}
  //     li.fragment  Estructuras de mayor nivel
  //       ul
  //         li.fragment  Monitores
  //       \end{itemize}
  //   \end{itemize}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
  // \section{<em>Deadlocks</em>}
  // 
/ Frame
  //   \frametitle{<em>Deadlocks</em>}
  // 
  //   Hemos visto situaciones de <em>bloqueo mutuo</em> (<em>deadlock</em>)
  //   
  //   ul
  //     li.fragment  Cuando los filósofos toman los palillos de a uno
  //     li.fragment  Cuando los procesos toman <em>locks</em> o <em>semáforos</em> en distinto orden
  //   \end{itemize}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Deadlocks</em>}
  // 
  //   Ley 18290: Ley de Tránsito.
  //   
  //   Título XI. Derecho preferente de paso.
  //   
  //   Artículo 143:
  //   \begin{quotation}
  //   Todo vehículo que se aproxime a un cruce deberá hacerlo a velocidad razonable y prudente, deteniéndose si fuere necesario, y el de la izquierda cederá el paso al vehículo que se acerque al cruce por la derecha, el que tendrá derecho preferente de paso.
  // 
  //   \onslide<2->{
  // El conductor del vehículo de la izquierda reiniciará la marcha e ingresará a la intersección sólo cuando se asegure que no hay riesgos de accidente, en atención a la distancia, visibilidad y velocidad de los otros vehículos que se aproximen por la derecha.}
  //   \end{quotation}
  // 
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Deadlocks</em>}
  //   \framesubtitle{¿Qué puede ocurrir?}
  // 
  //   También se les llama <em>interbloqueo</em>
  //   
  //   \begin{center}
  //     \includegraphics[width=10cm]{figs/01-cruces.png}
  //   \end{center}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Deadlocks</em>}
  // 
  //   &hellip; u otros nombres menos favorables
  // 
  //   \begin{center}
  //     \includegraphics[width=5cm]{figs/01-abrazomortal.jpg}
  //   \end{center}
  // 
  //   (\#NOT!!)
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Deadlocks</em>}
  // 
  //   Puede verse así:
  //   
  //   \begin{center}
  //     \includegraphics[width=6cm]{figs/01-dealocks-code.jpg}
  //   \end{center}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Deadlocks</em>}
  // 
  //   O así:
  // 
  //   \begin{center}
  //     \includegraphics[width=8cm]{figs/01-cruce-gridlock.jpg}
  //   \end{center}
  // 
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{<em>Deadlocks</em>}
  // 
  //   ¿Cuándo se producen?
  //   
  //   \onslide<2->{Cuando hay <strong>competencia por recursos</strong>}
  //   
  //   \onslide<3->{
  //   Modelo:
  //   
  //   ul
  //     li.fragment  Cantidad finita de recursos y de procesos
  //     li.fragment  Distintas clases de recursos (CPU, dispositvo E/S, &hellip;)
  //     li.fragment  Cada proceso ejecuta en algún momento estos pasos:
  //       ul
  //         li.fragment  <strong>Solicitar</strong> recursos (<em>request</em>)
  //         li.fragment  <strong>Utilizar</strong> recurso (<em>use</em>)
  //         li.fragment  <strong>Liberar</strong> recurso (<em>release</em>)
  //       \end{itemize}
  //   \end{itemize}
  //   }
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Caracterización de <em>Deadlocks</em>}
  // 
  //   Condiciones <em>necesarias</em>
  //   
  //   \begin{description}
  //     li.fragment [<strong>Exclusión mutua</strong>] Existe al menos un recurso <strong>no compartible</strong>
  //     li.fragment [<strong>Hold and Wait</strong>] Un proceso debe poseer el recurso y esperar otro recurso
  //     li.fragment [<strong>Ausencia de expropiación</strong>] Los recursos sólo pueden ser liberados voluntariamente
  //     li.fragment [<strong>Espera circular</strong>] Conjunto $\{P_0, P_1,&hellip;,P_n\}$ tal que ``$P_0$ espera a $P_1$'',
  //                                  ``$P_1$ espera a $P_2$'', &hellip; ``$P_n$ espera a $P_0$''
  //   \end{description}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Grafo de Asignación de Recursos}
  // 
  //   Herramienta para determinar la ocurrencia de <em>deadlocks</em>
  //   \begin{block}{Grafo de Asignación de Recursos (<em>Resource-Allocation Graph</em>)}
  //     Grafo dirigido $G=(V,E)$
  //     ul
  //       li.fragment  $V = P \cup R$. $P=\{P_1, P_2, &hellip;, P_n\}$ son los procesos activos;
  //                             $R=\{R_1, R_2, &hellip;, R_m\}$ son clases de recursos en el sistema
  //       li.fragment  Arista de solicitud. $P_i \to R_j$: $P_i$ está esperando un recurso de clase $R_j$
  //       li.fragment  Arista de asignación. $R_j \to P_i$: Recurso clase $R_j$ ha sido asignado a $P_i$
  //     \end{itemize}
  //   \end{block}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Grafo de Asignación de Recursos}
  // 
  //   $P=\{P_1,P_2,P_3\}$
  //   
  //   $R=\{R_1,R_2,R_3,R_4\}, |R_1|=1, |R_2|=2, |R_3|=1, |R_4|=3$
  //   
  //   $E=\{P_1 \to R_1, P_2 \to R_3, R_1 \to P_2, R_2 \to P_2, R_2 \to P_1, R_3 \to P_3\}$
  // 
  //   \begin{center}
  //     \includegraphics[width=3cm]{figs/01-7_01.pdf}
  //   \end{center}
  // 
  //   <em>¿Deadlock?</em> &hellip; \onslide<2->{No (¿por qué?)}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Grafo de Asignación de Recursos}
  // 
  //   \begin{alertblock}{Condición de <em>deadlock</em>}
  //     En el grafo de asignación de recursos:
  //     ul
  //       li.fragment  Si no hay ciclos $\to$ no hay <em>deadlock</em>
  //       li.fragment  Si hay ciclos $\to$ puede haber <em>deadlock</em>
  //     \end{itemize}
  //   \end{alertblock}
  //   
  //   \onslide<2->{
  //   ¿Y si hay una sola instancia de cada clase de recurso?
  //   }
  //   \begin{center}
  //   \onslide<3->{Ciclo $\Leftrightarrow$ <em>deadlock</em>}
  //   \end{center}
  //     
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Grafo de Asignación de Recursos}
  // 
  //   \begin{center}
  //     \includegraphics[width=3cm]{figs/01-7_01.pdf}
  //     $P_3$ solicita $R_2$
  //     \includegraphics[width=3cm]{figs/01-7_02.pdf}
  //   \end{center}
  // 
  //   \onslide<2->{¡<em>Deadlock</em>!}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Grafo de Asignación de Recursos}
  // 
  //   \begin{center}
  //     \includegraphics[width=4cm]{figs/01-7_03.pdf}
  //   \end{center}
  // 
  //   \onslide<2->{¡Ciclo! &hellip;}\onslide<3->{ pero sin <em>deadlock</em>}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{¿Como manejar <em>deadlock</em>s?}
  // 
  //   Tres alternativas:
  //   ul
  //     li.fragment  Prevenir o evitar llegar a un estado de <em>deadlock</em>
  //     li.fragment  Permitir el <em>deadlock</em>, detectarlo, y tomar medidas
  //     li.fragment  Ignorarlo
  //   \end{itemize}
  // 
  //   \begin{center}
  //     \includegraphics<2->[width=6cm]{figs/01-avestruces.jpg}
  //   \end{center}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Prevención de <em>deadlock</em>s}
  //   \framesubtitle{Decisión política}
  // 
  //   Asegurar que al menos una de las condiciones <strong>no se cumpla</strong>.
  //   
  // 
  //   ul
  //     li.fragment  <strong>Impedir ``Exclusión mutua''</strong>. Que todos los recursos sean compartibles.
  //     li.fragment  <strong>Impedir ``Hold-and-wait''</strong>. No ejecutar mientras no se tengan todos los recursos:
  //           procesos deben solicitar todos los recursos antes de ejecutar ; o bien,
  //           no permitir solicitudes a procesos que ya tengan recursos asignados
  //           ul
  //             li.fragment  -Posible subutilización de recursos
  //             li.fragment  -Posible inanición
  //           \end{itemize}
  //   \end{itemize}
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Prevención de <em>deadlock</em>s}
  //   \framesubtitle{Decisión política}
  // 
  //   Asegurar que al menos una de las condiciones <strong>no se cumpla</strong>.
  //   
  // 
  //   ul
  //     li.fragment  <strong>Impedir ``No expropiación''</strong>. Permitir expropiación.
  //           Si el proceso tiene recursos, solicita más y no se pueden asignar, entonces
  //           debe liberar los que ya tiene.
  //             ul
  //               li.fragment  O bien, quitarle los que otro proceso necesita
  //               li.fragment  Aplicable a recursos cuyo estado se puede recuperar
  //             \end{itemize}
  // 
  //     li.fragment  <strong>Impedir ``Espera circular''</strong>. Que todos los recursos deban ser solicitados en el mismo orden.
  //           ul
  //             li.fragment  ¿Por qué esto es suficiente?
  //             li.fragment  -La regla debe ser respetada por el programador
  //             li.fragment  FreeBSD incluye objetos <em>witness</em> que verifican este orden
  // %Chequear ejemplo Figure 7.5!!
  //           \end{itemize}
  //   \end{itemize}
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Evitar <em>deadlock</em>s}
  //   \framesubtitle{Solución algorítmica}
  //   
  //   En lugar de impedir alguna condición ``políticamente'', tomar
  //   la acción justo antes que ocurra el <em>deadlock</em>.
  //   
  //   \onslide<2->{Require examinar dinámicamente el grafo de asignación de recursos}
  //   
  //   ul
  //     li.fragment <3-> Cada procesos debe especificar la cantidad máxima de recursos que puede pedir
  //   \end{itemize}
  //   
  //   \onslide<4->{
  //   \begin{exampleblock}{<strong>Estado seguro</strong> (<em>safe state</em>)}
  //     Un estado es seguro si el sistema puede satisfacer las necesidades de todos los procesos
  //     en algún orden, y evitar el <em>deadlock</em>.
  //     
  //     Para un conjunto ordenado de procesos $\{P_1, P_2, &hellip;, P_n\}$, el estado es seguro
  //     si cada proceso $P_i$ puede satisfacer su demanda máxima usando los recursos que tiene,
  //     y los que tienen los procesos $P_j$, $j<i$.
  //   \end{exampleblock}
  //   }
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Evitar <em>deadlock</em>s}
  // 
  //   ul
  //     li.fragment  Un estado que no es seguro es &hellip; <strong>inseguro</strong>
  //     li.fragment <2-> Un estado de <em>deadlock</em> es <em>inseguro</em>
  //     li.fragment <3-> No todo estado <em>inseguro</em> es estado de <em>deadlock</em>
  //   \end{itemize}
  //   
  //   \begin{center}
  //     \includegraphics[width=4cm]{figs/01-7_06.pdf}
  //   \end{center}
  // 
  //   \onslide<4->{
  //   La política es mantenerse siempre en estados seguros
  //   }
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Evitar <em>deadlock</em>s}
  // 
  //   Ejemplo: $P=\{P_0,P_1,P_2\}$, $R=\{R_0\}$, $|R_0|=12$
  //   
  //   Solicitud máxima: $S_M=\{10,4,9\}$
  //   
  //   Solicitud actual: $S_a=\{5,2,2\}$
  //   
  //   \begin{center}
  //     ¿Está el sistema en un estado seguro?
  //   \end{center}
  // 
  //   \onslide<2->{Sí, ya que existe la secuencia $\langle P_1, P_0, P_2 \rangle$}
  //   
  //   \onslide<3->{
  //   \begin{center}
  //     ¿Y si a $P_2$ se le asigna un recurso más?
  //   \end{center}
  //   }
  //   
  //   \onslide<4->{
  //     <strong>¡Estado inseguro!</strong> (¿por qué?)
  //   }  
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Evitar <em>deadlock</em>s}
  //   \framesubtitle{Volviendo al grafo de asignación de recursos}
  //   
  //   Nuevo tipo de arista (existían de solicitud y de asignación):
  //   
  //   \onslide<2->{Arista de <strong>demanda</strong>: $P_i\to R_j$ significa que $P_i$ <em>puede</em> solicitar 
  //                el recurso $R_j$ en el futuro.}
  // 
  //   \begin{center}
  //     \includegraphics[width=3cm]{figs/01-7_07.pdf}
  //   \end{center}
  // 
  //   \onslide<3->{Algoritmo: satisfacer solicitud sólo si al satisfacer demanda
  //                no se obtiene un ciclo}
  //                
  //   \onslide<4->{Costo de detectar ciclo con $n$ procesos: }\onslide<5->{$O(n^2)$}
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Evitar <em>deadlock</em>s}
  //   \framesubtitle{Algoritmo del banquero (E.W.Dijkstra, 1977)}
  // 
  //   Analogía: el banquero entrega dinero de manera que pueda satisfacer a todos sus clientes
  //   
  //   ul
  //     li.fragment <2-> Cada proceso debe declarar su máximo de demanda para cada (clase de) recurso,
  //              que no debe ser mayor que el máximo existente
  //     li.fragment <3-> El algoritmo sólo asigna recursos si se mantiene dentro de un estado seguro
  //   \end{itemize}
  //   
  //   \onslide<4->{Estructuras: $m$ recursos, $n$ procesos}
  //   ul
  //     li.fragment <5-> <code>Available[m]</code>, cantidad disponible para cada recurso
  //     li.fragment <5-> <code>Max[n][m]</code>, máxima demanda para cada proceso.
  //       ul
  //         li.fragment  <code>Max[i][j]=k</code>: $P_i$ puede solicitar hasta $k$ instancias de $R_j$
  //       \end{itemize}
  //     li.fragment <5-> <code>Allocation[n][m]</code>, cantidades asignadas a cada proceso.
  //       ul
  //         li.fragment  <code>Allocation[i][j]=k</code>: $P_i$ tiene $k$ instancias de $R_j$
  //       \end{itemize}
  //     li.fragment <5-> <code>Need[n][m]</code>, solicitud potencial para cada proceso
  //       ul
  //         li.fragment  <code>Need[i][j]=k</code>: $P_i$ podría pedir hasta $k$ instancias de $R_j$
  //         li.fragment  <code>Need[i][j] == Max[i][j] - Allocation[i][j]</code>
  //       \end{itemize}
  //   \end{itemize}
  //   
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Evitar <em>deadlock</em>s}
  //   \framesubtitle{Algoritmo del banquero (E.W.Dijkstra, 1977)}
  // 
  //   ¿Cómo saber si estamos en un estado seguro?
  //   
  //   \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //     /** Safety Algorithm **/
  //     int Work[m] = Available;
  //     bool Finish[n] = FALSE;
  //     
  //     /** encontrar indice $i$ tal que Finish[i]==FALSE y Need[i] $\leq$ Work **/
  //     while(existe i tal que (!Finish[i] && Need[i] <= Work)) {
  //       Work = Work + Allocation[i];
  //       Finish[i] = TRUE;
  //     }
  //     for(i=0;i<n;i++) {
  //       if(Finish[i] == FALSE) {
  //         return UNSAFE;
  //       }
  //     }
  //     return SAFE;
  //   \end{minted}
  //   
  //   Tiempo de ejecución: \onslide<2->{$O(m \times n^2)$}
  //   
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Evitar <em>deadlock</em>s}
  //   \framesubtitle{Algoritmo del banquero (E.W.Dijkstra, 1977)}
  // 
  //   ¿Cómo determinar si es posible hacer una asignación de recursos?
  //   
  //   Input: <code>Request[i]</code>, solicitud de $P_i$
  //   \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //     assert(Request[i] <= Need[i]); /** no puede pedir mas de lo que declara **/
  //     if(Request[i] <= Available) {
  //       /** Simula una asignacion **/
  //       Available = Available - Request[i];
  //       Allocation[i] = Allocation[i] + Request[i];
  //       Need[i] = Need[i] - Request[i];
  //       if(safetyAlgorithm() == SAFE) { /** el de la slide anterior **/
  //         return ALLOCATED;
  //       }
  //       else {
  //         /** deshacer la asignacion **/
  //         return WAIT;
  //       }
  //     }
  //     else {
  //       return WAIT;
  //     }
  //   \end{minted}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Evitar <em>deadlock</em>s}
  //   \framesubtitle{Algoritmo del banquero (E.W.Dijkstra, 1977)}
  // 
  //   Ejemplo: $P=\{P_0,P_1,P_2,P_3,P_4\}, R=\{R_A,R_B,R_C\}$
  //   
  //   $|R_A|=10, |R_B|=5, |R_C|=7$
  //   
  //   Estado actual:
  //   \[
  //   \begin{array}{c|c|c|c|}
  //    \textbf{Alloc} & A & B & C \\ \hline
  //    P_0 & 0 & 1 & 0 \\ \hline
  //    P_1 & 2 & 0 & 0 \\ \hline
  //    P_2 & 3 & 0 & 2 \\ \hline
  //    P_3 & 2 & 1 & 1 \\ \hline
  //    P_4 & 0 & 0 & 2 \\ \hline
  //   \end{array}
  //   \qquad 
  //   \begin{array}{c|c|c|c|}
  //    \textbf{Max} & A & B & C \\ \hline
  //    P_0 & 7 & 5 & 3 \\ \hline
  //    P_1 & 3 & 2 & 2 \\ \hline
  //    P_2 & 9 & 0 & 2 \\ \hline
  //    P_3 & 2 & 2 & 2 \\ \hline
  //    P_4 & 4 & 3 & 3 \\ \hline
  //   \end{array}
  //   \qquad
  //    \begin{array}{c|c|c|c|}
  //    \textbf{Need} & A & B & C \\ \hline
  //    P_0 & 7 & 4 & 3 \\ \hline
  //    P_1 & 1 & 2 & 2 \\ \hline
  //    P_2 & 6 & 0 & 0 \\ \hline
  //    P_3 & 0 & 1 & 1 \\ \hline
  //    P_4 & 4 & 3 & 1 \\ \hline
  //   \end{array}
  //   \]
  //   $\textbf{Available}=\{3,3,2\}$
  //   
  //   El estado actual es <strong>safe</strong>, ¿por qué? \onslide<2->{({$\langle P_1,P_3,P_4,P_2,P_0 \rangle$})}
  //   
  //   ul
  //     li.fragment <3-> Ejecutar <em>request</em> de $P_1$: <code>Request[1]=\{1,0,2\}</code>
  //     li.fragment <3-> Ejecutar <em>request</em> de $P_4$: <code>Request[4]=\{3,3,0\}</code>
  //     li.fragment <3-> Ejecutar <em>request</em> de $P_0$: <code>Request[0]=\{0,2,0\}</code>
  //   \end{itemize}
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Detectar <em>deadlock</em>s}
  // 
  //   Si no se toma ninguna acción previa, pueden ocurrir <em>deadlocks</em>
  //   
  //   \onslide<2->{Se necesita:}
  //   
  //   ul
  //     li.fragment <3->{Algoritmo para detectar <em>deadlocks</em>}
  //     li.fragment <3->{Algoritmo para resolver <em>deadlocks</em>}
  //   \end{itemize}
  //   
  //   Costo de detectar ciclos en grafo de asignación de $n$ procesos: $O(n^2)$
  // 
  //   \begin{center}
  //     \includegraphics[width=6cm]{figs/01-7_09.pdf}
  //   \end{center}
  // 
  // \end{frame}
  // 
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Detectar <em>deadlock</em>s}
  //   \framesubtitle{Pero con múltiples instancias por recurso}
  //   
  //   Algoritmo de detección de <em>deadlock</em> basado en el banquero
  //   
  //   \onslide<2->{Estructuras: $m$ recursos, $n$ procesos}
  //   ul
  //     li.fragment <2-> <code>Available[m]</code>, cantidad disponible para cada recurso
  //     li.fragment <2-> <code>Allocation[n][m]</code>, cantidades asignadas a cada proceso.
  //       ul
  //         li.fragment  <code>Allocation[i][j]=k</code>: $P_i$ tiene $k$ instancias de $R_j$
  //       \end{itemize}
  //     li.fragment <2-> <code>Request[n][m]</code>, solicitud actual para cada proceso
  //       ul
  //         li.fragment  <code>Request[i][j]=k</code>: $P_i$ solicita $k$ instancias de $R_j$
  //       \end{itemize}
  //   \end{itemize}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame[fragile]
  //   \frametitle{Detectar <em>deadlock</em>s}
  //   \framesubtitle{Pero con múltiples instancias por recurso}
  //  
  //   Detección de <em>deadlock</em>
  //   
  //   \begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
  //     /** Deadlock detection algorithm **/
  //     int Work[m] = Available; bool Finish[n];
  //     for(i=0;i<n;i++)
  //       if(Allocation[i] != 0) Finish[i] = FALSE;
  //       else                   Finish[i] = TRUE;
  //     /** encontrar indice $i$ tal que Finish[i]==FALSE y Request[i] $\leq$ Work **/
  //     while(existe i tal que (!Finish[i] && Request[i] <= Work)) {
  //       Work = Work + Allocation[i];
  //       Finish[i] = TRUE;
  //     }
  //     /** todos pueden terminar? **/
  //     for(i=0;i<n;i++)
  //       if(Finish[i] == FALSE) return DEADLOCKED;
  //     return NOT_DEADLOCKED;
  //   \end{minted}
  //   Todos los procesos para los cuales <code>Finish[i]==FALSE</code> están en <em>deadlock</em>
  //   
  //   Tiempo de ejecución: \onslide<2->{$O(m \times n^2)$}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Detectar <em>deadlock</em>s}
  // 
  //   Ejemplo: $P=\{P_0,P_1,P_2,P_3,P_4\}, R=\{R_A,R_B,R_C\}$
  //   
  //   $|R_A|=10, |R_B|=5, |R_C|=7$
  //   
  //   Estado actual:
  //   \[
  //   \begin{array}{c|c|c|c|}
  //    \textbf{Alloc} & A & B & C \\ \hline
  //    P_0 & 0 & 1 & 0 \\ \hline
  //    P_1 & 2 & 0 & 0 \\ \hline
  //    P_2 & 3 & 0 & 3 \\ \hline
  //    P_3 & 2 & 1 & 1 \\ \hline
  //    P_4 & 0 & 0 & 2 \\ \hline
  //   \end{array}
  //   \qquad 
  //   \begin{array}{c|c|c|c|}
  //    \textbf{Req} & A & B & C \\ \hline
  //    P_0 & 0 & 0 & 0 \\ \hline
  //    P_1 & 2 & 0 & 2 \\ \hline
  //    P_2 & 0 & 0 & 0 \\ \hline
  //    P_3 & 1 & 0 & 0 \\ \hline
  //    P_4 & 0 & 0 & 2 \\ \hline
  //   \end{array}
  //   \]
  //   $\textbf{Available}=\{0,0,0\}$
  //   
  //   El estado actual es <strong>NOT DEADLOCKED</strong>, ¿por qué? \onslide<2->{({$\langle P_0,P_2,P_3,P_1,P_4 \rangle$})}
  //   
  //   ul
  //     li.fragment <3-> Ejecutar <em>request</em> de $P_2$: <code>Request[2]=\{0,0,1\}</code>
  //   \end{itemize}
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Recuperación ante <em>deadlock</em>s}
  // 
  //   p OK, hemos detectado el <em>deadlock</em> (so what?)
  //   
  //   p.fragment Dos caminos&hellip;
  //   ul
  //     li.fragment <strong>Matar un proceso</strong> ¿Cuál?
  //       ul
  //         li.fragment Todos (solución drástica)
  //         li.fragment Uno a la vez hasta resolver el <em>deadlock</em>
  //           ul
  //             li.fragment  Criterio 1: La cantidad mínima
  //             li.fragment  Criterio 2: El de menor ``costo''
  //     li.fragment <strong>Expropiar recursos</strong>
  //       ul
  //         li.fragment  ¿A quién?
  //         li.fragment  <strong>Rollback</strong>
  //       \end{itemize}
  //   \end{itemize}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Recuperación ante <em>deadlock</em>s}
  //   \framesubtitle{Algunos puntos importantes}
  // 
  //   ul
  //     li.fragment  <em>Deadlock</em>: dos o más procesos esperando indefinidamente por un evento
  //           que sólo puede ser producido por uno de ellos mismos.
  //           ul
  //             li.fragment  Requieren: recursos no compartibles, no expropiables, ``retención-y-espera'',
  //                   y espera circular.
  //             li.fragment  Si se impide una de estas condiciones, no se puede producir <em>deadlock</em>
  //           \end{itemize}
  //     li.fragment  Tres alternativas de manejo:
  //       ul
  //         li.fragment  Prevenir (que nunca pueda ocurrir), o evitar (esquivarlo antes que pase)
  //         li.fragment  Permitirlo y recuperarse. Desafío: resolver con el menor ``daño'' posible
  //         li.fragment  Ignorarlo
  //       \end{itemize}
  //     li.fragment  Algoritmo del banquero (Dijkstra, 1977), evita que el proceso llegue a un <em>estado inseguro</em>
  //     li.fragment  Sistema en <em>estado seguro</em> no puede estar en <em>deadlock</em>
  //   \end{itemize}
  // 
  // \end{frame}
  // 
  // %---------------------------------------------------------------------
/ Frame
  //   \frametitle{Administración de Procesos}
  //   \framesubtitle{¿Qué debemos recordar?}
  //  
  //   ul
  //     li.fragment  Procesos: programa+recursos, administrados por el S.O. mediante <em>syscall</em>s
  //     li.fragment  <em>Threads</em>: unidad básica de ejecución visible al programador o al S.O.
  //     li.fragment  Sincronización de <em>threads</em> permite que puedan ejecutar eficientemente, sin bloquearse,
  //           y sin provocar inconsistencias en los datos compartidos
  //     li.fragment  Algoritmos de <em>scheduling</em> permiten seleccionar eficientemente el próximo proceso/<em>thread</em> a ejecutar
  //     li.fragment  Se debe evitar caer en situación de <em>bloqueo mutuo</em>
  //   \end{itemize}
  // 
  // 
  // \end{frame}
  // 
  // \end{document}
