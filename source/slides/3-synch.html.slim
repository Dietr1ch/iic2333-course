---
title: Sincronización
layout: slide
---


section
	h2 Sincronización de Procesos
	/  --------------------------
section
	h2 Sincronización de Procesos
	/  --------------------------

	section#init
		p Cosas buenas:
		ul
			li.fragment  Tener <em>concurrencia</em> y <em>paralelismo</em>
			li.fragment  Crear <em>threads</em> livianos sobre el mismo espacio de memoria (no necesita <em>syscall</em> de <em>shared memory</em>) 

		p.fragment  Pero&hellip;
		ul
			li.fragment  Hay que coordinarlos (¿por qué?)




section#prod-cons
	h2 Regreso al Productor/Consumidor
	/  -------------------------------

	section#prod-cons-sol
		p Solución con <em>threads</em> productor y consumidor.

		pre
			code.hljs.c
				| size_t in=0, out=0;
				 /* Shared data */
				 size_t stock = 0;
				 T storage[STORAGE_SIZE];

		pre
			code.hljs.c
				| while ('v') {
				   item = produce();
				   while (stock == STORAGE_SIZE) {} /* Storage full */
				   storage[in] = item;
				   
				   in = ++in%STORAGE_SIZE;  /* rotate index */
				   stock++;
				 }

		pre
			code.hljs.c
				| while (2333) {
				   while(!stock) {} /* Wait for new items */
				   item = storage[out];
				   
				   out = ++out%STORAGE_SIZE;  /* rotate index */
				   stock--;
				   consume(item);
				 }

	section#prod-cons-sol-rc
		p ¿Qué podría salir mal?

		.fragment
			p  Considere la secuencia:
			pre
				code.hljs.c
					| /* stock=10 */
					 stock++;  /* Thread 1  */
					 stock--;  /* Thread 2 */

		p.fragment Resultado esperado: <code>stock=10</code>

		p.fragment Pero también podría ocurrir <code>9</code> o <code>11</code> (what?)


	section#prod-cons-rc-asm
		p ¿Cómo se ejecutan los cálculos en hardware?

		pre
			code.hljs.asm
				| load r1, stock  ; r1 <= stock
				 inc r1          ; (r1 += 1)
				 store stock, r1 ; stock <= r1

		pre
			code.hljs.asm
				| load r2, stock  ; r2 <= stock
				  dec r2          ; (r2 -= 1)
				  store stock, r2 ; stock <= r2

	section#prod-cons-rc-asm-fail
		p Podría ocurrir este orden de ejecución (<strike>Shit happens</strike> C'est la vie)

		a href="http://i.imgur.com/MS13CAb.gif"
			pre
				code.hljs.asm
					| load r1, stock  ; r1 = 10
					                                    load r2, stock  ; r2 = 10
					                                    dec r2          ; r2 = 9
					                                    store stock, r2 ; stock = 9   Write lost!!
					  inc r1          ; r1 = 11      Outdated!!
					  store stock, r1 ; stock = 11   Dirty write :/

		p.fragment ¿Podemos tener tan mala suerte para que ocurra a<a href="https://www.reddit.com/r/Bitcoin/comments/1wtbiu/how_i_stole_roughly_100_btc_from_an_exchange_and">sí</a>?


	section#rc
		dl
			dt Race Condition
			dd
				p Situación en que la salida de una operación depende del orden temporal de sus operaciones internas, el cual no está bajo control del programador.

		p.fragment El resultado depende de la entremezcla (<em>interleaving</em>) de sus <em>threads</em>
		h5.fragment <strong>Hay que evitarlas</strong>


section#crS
	h2 El Problema de la Sección Crítica
	/  ---------------------------------

	section#crS-def
		p  Cada proceso tiene un segmento de código llamado <strong>sección crítica</strong>

		p.fragment  Allí el proceso puede acceder a los recursos compartidos

	section#crS-def_
		p  Objetivo:
		blockquote.fragment
			| Diseñar un protocolo que no permita que dos procesos se encuentren en su sección crítica al mismo tiempo

		pre.fragment
			code.hljs.c
				| void mess_with_shared_things() {
				    entry();
				    /* do stuff with shared resources */
				    leave();
				    
				    /* moar stuff */
				 }


	section#crS-solReqs
		p Una solución al problema de la sección crítica (SC) debe cumplir 3 requisitos:

		dl
			dt.fragment Exclusión Mutua
			dd.fragment
				p <em>A lo más un</em> proceso está en su SC.

			dt.fragment Progreso
			dd.fragment
				p <em>Al menos alguien puede entrar</em>.
				p Si ningún proceso está en su SC, y hay procesos que desean entrar, entonces los que quieren entrar deben decidir quién entra, y decidirlo en un tiempo acotado.

			dt.fragment Espera acotada
			dd.fragment
				p <em>Ausencia de inanición</em>. Si un proceso quiere entrar a su SC, podrá hacerlo luego de una cantidad finita de turnos.





section#sols
	h2 Algunas soluciones al problema de la sección crítica


section#peterson
	/TODO; FIX left/right css
	.left
		pre
			code.hljs.c
				| size_t me = //?;                  /* Peterson */
				 size_t other = 1-me;
				 do {
				   flag[me] = true;  /* 'wants' */
				   turn = other;
				   
				   while(flag[other] && turn == other); {}
				   /* Critical Section */
				   flag[me] = false;
				   
				   /* ... */
				 } while('o');

	section#peterson
		h2 Solución de Peterson
		/ ---------------------

	section#peterson-init

		.right
			p Solución para 2 procesos (Gary L. Peterson, 1981)
		.right
			p.fragment Variables compartidas: <code>int turn; boolean flag[2];</code>
			p.fragment ¿En qué valor se inicializan <code>turn</code> y <code>flag</code>?




	section#peterson-a
		.right
			p ¿Cumple los requisitos?

	section#peterson-a-me
		.right
			p <strong>Exclusión Mutua</strong>

			ul
				li.fragment  $P_i$ puede entrar solamente si <code>flag[j]==false</code> ó <code>turn == i</code>
				li.fragment  Si $P_i$ y $P_j$ se encuentran ambos en la SC, entonces <code>flag[0]==flag[1]==true</code>
				li.fragment  <code>flag[0]==true</code> $\Rightarrow$ <code>turn=i</code>
				li.fragment  <code>flag[1]==true</code> $\Rightarrow$ <code>turn=j</code>
				li.fragment  Pero <code>i</code>$\neq$<code>j</code>, por lo tanto no pueden estar ambos en su SC


	section#peterson-a-p
		.right
			p <strong>Progreso</strong>

			ul
				li.fragment  Si $P_i$ desea entrar a su SC, sólo puede estar detenido en el loop (busy-wait)
				li.fragment  Entonces se cumple <code>flag[j]==true</code> y <code>turn==j</code>
				li.fragment  Si $P_j$ no desea entrar a su SC, entonces <code>flag[j]==false</code>
				li.fragment  Si $P_j$ desea entrar, entonces <code>turn==i</code> ó <code>turn==j</code>
				li.fragment  En cualquier caso, uno de los que quiere entrar, entra 


	section#peterson-a-ea
		.right
			p <strong>Espera acotada</strong>

			ul
				li.fragment  Si $P_i$ desea entrar y está esperando, entonces <code>flag[i]==true</code>, <code>flag[j]==true</code> y <code>turn==j</code>
				li.fragment  En cuanto $P_j$ sale, establece <code>flag[j]=false</code>, y $P_i$ puede entrar (si empieza a ejecutar)
				li.fragment  Si $P_j$ intenta entrar inmediatamente, deberá establecer <code>flag[j]=true</code> y <code>turn=i</code>.
				li.fragment  Se cumple entonces <code>flag[i]==true</code>, <code>flag[j]==true</code>, y <code>turn=i</code>, con lo que $P_j$ no puede entrar.    
				li.fragment  Por lo tanto después de, a lo más, 1 turno, $P_i$ puede entrar (espera acotada)



section#hwSync
	h2 Sincronización por <em>hardware</em>
	/  ------------------------------------

	section#hwSync_
		p Soluciones por <em>software</em> dependen de que existan <strong>instrucciones atómicas</strong> por <em>hardware</em>:

		p.fragment Una solución más sencilla:
		pre.fragment
			code.hljs.c
				| lock = true;
				  while (!lock);
				  /* Critical Section */
				  lock = false;
				  /* ... */

		p.fragment ¿Basta con esto?


	section#hwSync-ts
		p <code>test_and_set()</code>

		p.fragment Algunas arquitecturas proveen instrucciones atómicas del tipo <code>test_and_set</code>

		.fragment
			p  La instrucción es equivalente a:
			pre
				code.hljs.c
					| _Bool SOFTWARE_test_and_set (_Bool *target) {
					   _Bool old_value = *target;
					   *target = true;
					   
					   return old_value;
					 }

		p.fragment ¿Y si no hay soporte en la CPU?
		ul
			li.fragment  Se puede usar deshabilitando las interrupciones momentáneamente.

		p.fragment  ¿Cómo usarlo?

	section#hwSync-ts_sample
		pre.fragment
			code.hljs.c
				| _Bool lock;
				 /* ... */
				 while (test_and_set(&lock));
				 /* Critical Section */
				 lock = false;
				 
				 /* ... */

	section#hwSync-cas
		p Otra instrucción atómica: <code>compare_and_swap</code>

		pre.fragment
			code.hljs.c
				| _Bool SOFTWARE_compare_and_swap (int *value, int expected, int new_value) {
				    int previous = *value;
				    
				    if(*value == expected)
				      *value = new_value;
				    
				    return previous;
				  }

		p.fragment  ¿Cómo usarlo?


	section#hwSync-cas-sample

		pre
			code.hljs.c
				| do {
				    while (compare_and_swap(&lock, 0, 1));
				    /* Critical Section */
				    
				    lock = 0;
				    /* ... */
				 } while('~');

	section#sync-correctness
		pre style="heigth=80%;max-heigth=80%;"
			code.hljs.c style="heigth=80%;max-heigth=80%;"
				| do {
				    waiting[i] = key = true;          /* "I'm waiting and it's locked" */
				    while (waiting[i] && key)
				      key = test_and_set(&lock);
				    waiting[i] = false;               /* "I'm no longer waiting" */
				    /* Critical Section */
				    
				    j = (i+1)%N;                      /* Find waiting proc (clockwise circle) */
				    while((j != i) && !waiting[j])
				      j = ++j%N;
				    if(j == i)                          /* -Nobody was waiting */
				      lock = false;
				    else                                /* -proc_j shold go (stop waiting) */
				      waiting[j] = false;
				    /* ...  */
				 } while('-');   /* "Here I go again (on my own)" */

		p.fragment Estos algoritmos ¿cumplen con las propiedades de solución para sección crítica?

section#abstractions
	h2 Abstracciones de Sincronización
	/  -------------------------------

	section#abstractions-init
		p En general no se usan directamente soluciones por <em>hardware</em> sino que &hellip;

		p.fragment Se construyen primitivas de <em>software</em> sobre ellas.
		p.fragment Encapsulan la sincronización.
		ul
			li.fragment Algunas agregan mejoras para ciertas situaciones.
			li.fragment Pero a veces el costo de la mejora supera lo ganado.


section#abstractions-locks
	h3 Locks

	section#abstractions-locks-init
		p.fragment La más simple
		.fragment
			p <strong>Mutex Lock</strong> (<strong>mut</strong>ual <strong>ex</strong>clusion)
			ul
				li.fragment <code>Lock::acquire()</code>
				li.fragment <code>Lock::release()</code>

		pre.fragment
			code.hljs.c
				| void acquire() {     /* (Using HW support or disabling INTs) */
				    while(!available); /* busy wait */
				    available = false;
				  }
				  
				  void release() {
				    available = true;
				  }

	section#abstractions-locks-sample
		pre.fragment
			code.hljs.c
				| do {
				    acquire();
				    /* Critical Section */
				    release();
				    /* ... */
				    
				 } while('o');

section#abstractions-locks
	h3 Semáforos

	section#sema
		p En ocasiones se quiere un acceso acotado, pero mayor a 1

		.fragment
			dl
				dt Semáforo
				dd
					p Un semáforo <code>S</code> incluye un contador y dos operaciones:
					ul
						li.fragment <em>proberen</em> <code>P()</code> ó <code>wait</code>. Intenta decrementar el valor.
						li.fragment <em>verhogen</em> <code>V()</code> ó <code>signal</code>. Incrementa el valor.
			p.fragment E. Dijkstra era Holandés, pero si no saben holandés es más fácil recordar <code>Pedir</code>/'<code>Votar</code>'

		pre.fragment
			code.hljs.c
				| void P(S) {  /* wait (Using HW support or disabling INTs) */
				    while(S <= 0); /* busy wait */
				    S--;
				  }
				  void V(S) {  /* signal */
				    S++;
				  }

	section#sema-1
		p ¿Cuándo es adecuado?

		p.fragment Cuando se quiere compartir múltiples recursos

		p.fragment <em>¿Y si simplemente uso un lock por cada uno?</em>
		ul
			li.fragment Cada cliente debería intentar pedir todos.
			li.fragment Puede que obtenga más de los que necesita.
			li.fragment O que espere por recursos que no necesita.

		p.fragment Con un semáforo se tiene una interfaz única para todos los recursos.

		p.fragment Ejemplos:
		ul
			li.fragment Biblioteca: Un semáforo agrupa las copias de libros o salas.
			li.fragment WebServers: Limitar la concurrencia para que los requests en los que se invierte tiempo no den timeout.
			li.fragment Supermercados: Cola 'rápida' con varias cajas.

	section#sema-sample
		pre
			code.hljs.c
				| Semaphore* S = sema_new(K);
				 do {
				   P(S);
				   /* Critical Section */
				   V(S);
				   /* ... */
				 } while (1);



section#no-busy-wait
	h2 <strike>Busy Wait</strike>

	section#no-busy-wait_
		p Las Implementaciones propuestas de <em>Lock</em> y <em>Semaphore</em> usan <strong>busy waiting</strong>

		p.fragment Eso es malo<span class="fragment">, <strong>muy malo</strong></span>
		p.fragment Desperdicia ciclos de CPU

		p.fragment ¿Alternativas?
		ul
			ul.fragment usar una cola de espera.

	section#no-busy-wait-sema
		p Semáforo sin <em>busy waiting</em>

		pre.fragment
			code.hljs.c
				| typedef struct {
				    int value;
				    Queue<pid_t> queue;  /* (C++ notation. C needs a void* queue or a type defined by the preprocessor) */
				  } Semaphore;

		p.fragment Necesitamos soporte del SO para manipular procesos.
		ul
			li.fragment  <code>block()</code> que libera la CPU.
			li.fragment  <code>wake(p)</code> que despierta al proceso <code>p</code>.

		pre.fragment
			code.hljs.c
				| P(Semaphore *s) {  /* wait */
				    s->value--;
				    if(s->value < 0) {
				      queue_push(s->queue, currentProcess() );
				      block();
				    }
				  }
				 
				 V(Semaphore *s) {  /* signal */
				   s->value++;
				   wake( queue_pop(s->queue) );
				 }




section#block-problems
	h2 Problemas clásicos de sincronización

	section#block-problems_
		p Ahora que la espera no desperdicia CPU revisemos algunos problemas.


section#block-prodCons-sema
	p Semáforos para el buffer acotado

	section#block-prodCons_sema-data
		p ¿Cómo lo solucionamos con semáforos?

		p.fragment Variables compartidas:
		pre.fragment
			code.hljs.c
				| Item buffer[BUFFER_SIZE];
				  Semaphore missing(BUFFER_SIZE);
				  Semaphore pending(0);
				  
				  Semaphore mutex(1);     /* (lock?) */

  
	section#block-prodCons_sema-procs
		pre
			code.hljs.c
				| do {
				    wait(missing);
				    wait(mutex);
				    
				    buffer[in] = produce();  /* Store new Item */
				    in = ++in%BUFFER_SIZE;   /* Advance save target */
				    
				    signal(mutex);
				    signal(full);
				  } while(1);

		pre
			code.hljs.c
				| do {
				    wait(full);
				    wait(mutex);
				    
				    consume(  buffer[out]  );  /* Use Item */
				    out = ++out%BUFFER_SIZE;   /* Target next item */
				    
				    signal(mutex);
				    signal(empty);
				  } while(2);

		p.fragment  ¿Qué pasa si se pide el mutex antes?



section#block-rw
	p Semáforos para los lectores y escritores

	section#block-rw_
		p La sección crítica suele exigir <strong>solo un</strong> <em>thread</em> en ella.

		/ Hay situaciones en las que puede entrar más de un proceso
		/ Y más de una clase de procesos

		p.fragment  ¿Y si solo permitimos lecturas?  <span class="fragment"> OK, entonces $n$ lectores simultáneos                  </span>
		p.fragment  ¿Y si alguien quiere escribir?   <span class="fragment"> Entonces, que solo <strong>uno</strong> pueda escribir </span>
		p.fragment  Condiciones distintas para cada rol

		dl.fragment
			dt Problema de lectores y escritores
			dd
				ul
					li.fragment Permitir acceso de $n$ lectores simultáneos, pero solamente 1 escritor
					li.fragment Variantes:
					ul
						li.fragment lectores ilimitados
						li.fragment escritores con prioridad


	section#block-rw-shared
		p Variables compartidas
		pre.fragment
			code.hljs.c
				| int reading=0;
				  Semaphore rw_mutex(1);
				  Semaphore mutex(1);
  
	section#block-rw-procs
		pre.fragment
			code.hljs.c
				| do {
				    wait(rw_mutex);
				    /* write */
				    signal(rw_mutex);
				  } while('w');

		pre.fragment
			code.hljs.c
				| do {
				    wait(mutex);
				    reading++;
				    if(reading == 1)
				      wait(rw_mutex);
						signal(mutex);
				    
				    /* read */
				    
				    wait(mutex);
				    reading--;
				    if(read_count == 0)
				      signal(rw_mutex);
						signal(mutex);
				  } while('r');


section#block-phi
	p Problema de los filósofos comensales

	section#block-phi_
		p 5 filósofos se pasan la vida en dos actividades: <em>comer</em> y <em>pensar</em>
		ul
			li.fragment  Para comer deben tomar ambos palillos
			li.fragment  Sólo pueden tomar un palillo a la vez
		= image_tag 'images/figures/01-5_13.pdf.png', :style=>"float:right;"


	section#block-phi_-procs
		pre.fragment
			code.hljs.c
				| int  left =  i;
				  int right = (i+1)%N;
				  Semaphore chopstick[N];
				  
				  do {
				    wait(chopstick[ left]);
				    wait(chopstick[right]);
				    
				    /* eat */
				    
				    signal(chopstick[ left]);
				    signal(chopstick[right]);
				    
				    /* philosophise */
				    
				  } while ('p');

		p.fragment  ¿Funciona? ¿Para 2? ¿3?



	section#block-phi_-dl
		p Un uso poco cuidadoso cuando hay más de 1 recurso puede traer otro enemigo.
		p.fragment <strong>deadlock</strong> (<strong>bloqueo mutuo</strong>)
		pre.fragment
			code.hljs.c
				| /* Shared */
				  Semaphore a,b;  /* Lock fails too */
				  
				  /* Proc1 */       /* Proc 2 */
				  P(a);             P(b);
				  P(b);             P(a);
				  /* ... */         /* ... */
				  V(a);             V(b);
				  V(b);             V(a);
		p.fragment Ambos piden <code>a</code> y <code>b</code>, los usan y luego los devuelven.
		p.fragment ¿Pero qué pasa si ambos ejecutan su primer <code>wait</code> al mismo tiempo?
		p.fragment Es aún peor si internamente se usa <em>busy-wait</em> en vez de <code>block</code>.
		p.fragment ¿Cómo se soluciona esto? ¿Se puede?
		p.fragment ¿Bastará con mejores abstracciones?


section#block-mon
	h2 Monitores
	/  ---------
	/  1-252

	section#block-mon-init
		p Construcción de sincronización de (más) alto nivel

		ul
			li.fragment  Provee métodos que permiten controlar el acceso exclusivo
			li.fragment  Utiliza <strong>variables de condición</strong>, que tiene dos operaciones
			ul
				li.fragment  <code>Condition::wait()</code>   bloquea <strong>siempre</strong> el <em>thread</em>
				li.fragment  <code>Condition::signal()</code> despierta a un <em>thread</em> bloqueado, si lo hay
			li.fragment  No son iguales a semáforos (pero pueden implementarse con ellos

		p.fragment ¿Semántica para <code>signal()</code>?
		ul
			li.fragment  <strong>Signal-and-continue</strong>: el <em>caller</em> continúa ejecutando (Java, C#).
			li.fragment  <strong>Signal-and-wait</strong>:     el <em>caller</em> se bloquea inmediatamente. <span class="fragment">¿Sirve?</span>



	section#block-mon-phi
		p Filósofos Comensales Monitoreados

		pre.stretch
			code.hljs.c
				| monitor DiningPhilosophers {
				    enum {PHILOSOPHISE, HUNGRY, EATING} state[N];   /* free / waiting / using */
				    
				    condition philosopher[N];
				    int left  = (N+i-1)%N;  /* -5%2 ? */
				    int right = (  i+1)%N;
				    
				    void take(int i) {
				      state[i] = HUNGRY;
				      check(i);
				      if(state[i] != EATING)
				        philosopher[i].wait();
				    }
				    
				    void release(int i) {
				      state[i] = PHILOSOPHISE;
				      check( left);
				      check(right);
				    }
				    
				    void check(int i) {
				      if( state[ left] != EATING &&
				          state[right] != EATING &&
				          state[    i] == HUNGRY )
				        state[i] = EATING;
				        philosopher[i].signal();
				      }
				    }
				  }


  
	section#block-mon-phi-procs
		p La implementación de cada filósofo se reduce a:

		pre.fragment
			code.hljs.c
				| do {
				    FilosofosComensales.take(i);
				    /* eat */
				    FilosofosComensales.release(i);
				    /* philosophise */
				  } while('p');

		p.fragment  ¿Cómo deben inicializarse los estados?
		p.fragment  ¿Cumple todas las condiciones del problema de la sección crítica?


 

	section#block-mon-impl
		p Monitores usando semáforos
		pre.fragment
			code.hljs.c
				| struct monitor {
				    Semaphore mutex(1);
				    
				    int nextCount = 0;
				    Semaphore next(0);  /* Queue */
				    
				    struct condition {
				      Semaphore conditionSem(0); /* para bloquearse en la condicion */
				      int count = 0;             /* cuantos esperan en la condicion */
				      wait();
				      signal();
				    };
				  };


	section#block-mon-impl
		p <code>condition.wait()</code>:   <em>thread</em> se bloquea incondicionalmente

		p <code>condition.signal()</code>: despierta a algún <em>thread</em> bloqueado, si lo hay
		pre.fragment
			code.hljs.c
				| condition.wait() {
				    count++;
				    if(nextCount > 0)
				      signal(next);
				    else
				      signal(mutex);
				    wait(conditionSem);
				    count--;
				  }

		pre.fragment
			code.hljs.c
				| condition.signal() {
				    if(count > 0) {
				      nextCount++;
				      signal(conditionSem);
				      wait(next);
				      nextCount--;
				    }
				  }

		p.fragment Esta implementación utiliza la semántica <em>signal-and-wait</em>.



section#synch-mid-summary
	h3 Hasta ahora: Sincronización
	/  ---------------------------

	section#synch-summary_
		ul
			li.fragment  Necesidad de sincronizar <em>thread</em> que "compiten por datos"
			li.fragment  Problema de la sección crítica:
			ul
				li.fragment  Exclusión mutua, progreso, espera acotada
			li.fragment  Primitivas básicas de sincronización:
			ul
				li.fragment  <em>Hardware</em>: TaS, CaS
				li.fragment  <em>Software</em>: Locks, semáforos
			li.fragment  Estructuras de mayor nivel
			ul
				li.fragment  Monitores





section#deadlocks
	h2 <em>Deadlocks</em>

	section#deadlocks_
		p Hemos visto situaciones de <em>bloqueo mutuo</em> (<em>deadlock</em>)

		ul
			li.fragment  Cuando los filósofos toman los palillos de a uno
			li.fragment  Cuando los procesos toman <em>locks</em> o <em>semáforos</em> en distinto orden

  
	section#dl-transit
		blockquote.fragment
			| Ley 18290: Ley de Tránsito.
			  
			  Título XI. Derecho preferente de paso.
			  Artículo 143:

		blockquote.fragment
			| Todo vehículo que se aproxime a un cruce deberá hacerlo a velocidad razonable y prudente, deteniéndose si fuere necesario, y el de la izquierda cederá el paso al vehículo que se acerque al cruce por la derecha, el que tendrá derecho preferente de paso.

		blockquote.fragment
			| El conductor del vehículo de la izquierda reiniciará la marcha e ingresará a la intersección sólo cuando se asegure que no hay riesgos de accidente, en atención a la distancia, visibilidad y velocidad de los otros vehículos que se aproximen por la derecha.



	section#dl-transit-1
		p También se les llama <em>interbloqueo</em>

		/TODO: change deadlock fig
		= image_tag 'images/figures/01-cruces.png'

	section#dl-transit-whyyyyy
		p &hellip; u otros nombres menos favorables

		= image_tag 'images/figures/01-abrazomortal.jpg'

		h2.fragment = "#NOT!!"

  
	section#dl-codeSample
		p Puede verse así:
		pre
			code.hljs.c
				| /* Proc1 */       /* Proc 2 */
				  wait(a);
				                    wait(b);
				  wait(b);
				  /*  =( */
				                    wait(a);
				                    /*  =( */
				  
				  /* ... */         /* ... */
				  release(a);       release(b);
				  release(b);       release(a);


	section#dl-rlSample
		p O así:
		= image_tag 'images/figures/01-cruce-gridlock.jpg'


	section#dl-init
		p ¿Cuándo se producen?

		p.fragment Cuando hay <strong>competencia por recursos</strong>

		p.fragment Modelo:
		ul
			li.fragment  Cantidad finita de recursos y de procesos
			li.fragment  Distintas clases de recursos (CPU, dispositvo I/O,&hellip;)
			li.fragment  Cada proceso ejecuta en algún momento estos pasos:
			ul
				li.fragment  <strong>Solicitar</strong> recursos (<em>request</em>)
				li.fragment  <strong>Utilizar</strong> recurso (<em>use</em>)
				li.fragment  <strong>Liberar</strong> recurso (<em>release</em>)


	section#dl-nc
		p Condiciones <em>necesarias</em>

		ul
			li.fragment <strong>Exclusión mutua</strong>           Existe al menos un recurso <strong>no compartible</strong>
			li.fragment <strong>Hold and Wait</strong>             Un proceso debe poseer el recurso y esperar otro recurso
			li.fragment <strong>Ausencia de expropiación</strong>  Los recursos sólo pueden ser liberados voluntariamente
			li.fragment <strong>Espera circular</strong>           Conjunto $\{P_0, P_1,\cdots, P_n\}$ tal que $P_i$ espera a $P_{(i+1)\%N}$


section#resourceGraph
	h2 Grafo de Asignación de Recursos

	section#resourceGraph-def
		p Herramienta para determinar la ocurrencia de <em>deadlocks</em>
		p.fragment Grafo dirigido $G=(V,E)$
		ul
			li.fragment = '$V = P \cup R$'
			ul.fragment
				li = '$P=\{P_1, P_2,\cdots , P_n\}$ son los procesos activos'
				li = '$R=\{R_1, R_2,\cdots , R_m\}$ son clases de recursos en el sistema'
			li.fragment = "$E$:"
			ul
				li.fragment = '$P_i \to R_j$:   solicitud, $P_i$ está esperando un recurso de clase $R_j$'
				li.fragment = '$R_j \to P_i$:  asignación, Recurso clase $R_j$ ha sido asignado a $P_i$'


	section#resourceGraph-sample
		= image_tag 'images/figures/01-7_01.pdf.png', :width=>"25%"

		p <em>¿Deadlock?</em>&hellip; <span class="fragment">No (¿por qué?)</span>


	section#resourceGraph-dlCond
		p Condición de <em>deadlock</em>

		p.fragment  Si en el grafo de asignación de recursos:
		ul
			li.fragment  No hay ciclos $\to$ no hay <em>deadlock</em>
			li.fragment  Hay ciclos $\to$ <strong>puede</strong> haber <em>deadlock</em>

		p.fragment  ¿Y si hay una sola instancia de cada clase de recurso?
		p.fragment  Ciclo $\Leftrightarrow$ <em>deadlock</em>



	/ Graph loop samples
	/ ------------------
	section#resourceGraph-dl-sample-dl-1
		== image_tag '/images/figures/01-7_01.pdf.png', :width=>"25%"
		p.fragment  $P_3$ solicita $R_2$

	section#resourceGraph-dl-sample-dl-2
		== image_tag '/images/figures/01-7_02.pdf.png', :width=>"25%"
		p.fragment  ¡<em>Deadlock</em>!

	section#resourceGraph-dl-sample-nodl
		== image_tag 'images/figures/01-7_03.pdf.png', :width=>"25%"
		p.fragment  ¡Ciclo!<span class="fragment">&hellip; pero sin <em>deadlock</em></span>




section#dl_handling
	h2 ¿Como manejar <em>deadlock</em>s?

	section#dl_handling-
		p Tres alternativas:
		ul
			li.fragment  Prevenir o evitar llegar a un estado de <em>deadlock</em>
			li.fragment  Permitir el <em>deadlock</em>, detectarlo, y tomar medidas
			.fragment
				li  Ignorarlo
				== image_tag '/images/figures/01-avestruces.jpg'




section#dl_prev
	h2 ¿Como evitar <em>deadlocks</em>?
	/  ================================

section#dl_prev
	h2 Prohibición de <em>deadlocks</em>

	section#dl_prev-
		p Se puede asegurar que al menos una de las condiciones <strong>no se cumpla</strong>

	section#dl_prev-pol-1
		ul
			li.fragment  <strong>Impedir "Exclusión mutua"</strong>. Que todos los recursos sean compartibles.
			li.fragment  <strong>Impedir  "Hold-and-wait" </strong>. No ejecutar mientras no se tengan todos los recursos:
			ul.fragment
				li procesos deben solicitar todos los recursos antes de ejecutar
				li o bien, no permitir solicitudes a procesos que ya tengan recursos asignados
			ul
				li.fragment  -Posible subutilización de recursos
				li.fragment  -Posible inanición



	section#dl_prev-pol-2
		ul
			li.fragment  <strong>Impedir "No expropiación"</strong>. Permitir expropiación.
				|  Si el proceso tiene recursos, solicita más y no se pueden asignar, entonces
				|  debe liberar los que ya tiene.
			ul
				li.fragment  O bien, quitarle los que otro proceso necesita
				li.fragment  Aplicable a recursos cuyo estado se puede recuperar

		  li.fragment  <strong>Impedir ``Espera circular''</strong>. Que todos los recursos deban ser solicitados en el mismo orden.
			ul
				li.fragment  ¿Por qué esto es suficiente?
				li.fragment  -La regla debe ser respetada por el programador
				li.fragment  FreeBSD incluye objetos <em>witness</em> que verifican este orden
			/ Chequear ejemplo Figure 7.5!!



section#dl_prev
	h2 Prevención de <em>deadlocks</em>

	section#dl_prev-alg-1
		p Solución algorítmica

		p.fragment  En lugar de impedir alguna condición "políticamente", tomar la acción justo antes que ocurra el <em>deadlock</em>.
		p.fragment  Require examinar dinámicamente el grafo de asignación de recursos

		ul
			li.fragment  Cada procesos debe especificar la cantidad máxima de recursos que puede pedir
			ul
				li.fragment  Pero esta puede no ser conocida antes de la ejecución
				li.fragment  Y saber cuántos recursos va a pedir un programa es indecidible en general (HALTING).

	section#dl_prev-alg-2-safeState
		p <strong>Estado seguro</strong> (<em>safe state</em>)
		blockquote.fragment
			| Un estado es seguro si el sistema puede satisfacer las necesidades de todos los procesos en algún orden, y evitar el <em>deadlock</em>.
			  
			  Para un conjunto ordenado de procesos $\{P_1, P_2,\cdot, P_n\}$, el estado es seguro
			  si cada proceso $P_i$ puede satisfacer su demanda máxima usando los recursos que tiene,
			  y los que tienen los procesos $P_j$, $j<i$.
			  
			  Es decir, si el uso de recursos es serializable.


	section#dl_prev-alg-3
		p $deadlock(S) \rightarrow \not safe(S)
		ul
		  li.fragment  Un estado de <em>deadlock</em> es <em>inseguro</em>
		  li.fragment  No todo estado <em>inseguro</em> es estado de <em>deadlock</em>

		== image_tag '/images/figures/01-7_06.pdf.png'

		p.fragment  La política es mantenerse siempre en estados seguros


	section#dl_prev-alg-4-example
		p Ejemplo: $P=\{P_0,P_1,P_2\}$, $R=\{R_0\}$, $|R_0|=12$

		p Solicitud máxima: $S_M=\{10,4,9\}$
		p Solicitud actual: $S_a=\{5,2,2\}$

		br
		p ¿Está el sistema en un estado seguro?

		p.fragment  Sí, ya que existe la secuencia $\langle P_1, P_0, P_2 \rangle$
		p.fragment  ¿Y si a $P_2$ se le asigna un recurso más?  <span class="fragment"><strong>¡Estado inseguro!</strong> (¿por qué?)</span>


//	section#
//		\frametitle{Evitar <em>deadlock</em>s}
//		\framesubtitle{Volviendo al grafo de asignación de recursos}
//
//		Nuevo tipo de arista (existían de solicitud y de asignación):
//
//		\onslide<2->{Arista de <strong>demanda</strong>: $P_i\to R_j$ significa que $P_i$ <em>puede</em> solicitar 
//		             el recurso $R_j$ en el futuro.}
//
//		\begin{center}
//		  /== image_tag [width=3cm]{images/figures/01-7_07.pdf.png}
//		\end{center}
//
//		\onslide<3->{Algoritmo: satisfacer solicitud sólo si al satisfacer demanda
//		             no se obtiene un ciclo}
//
//		\onslide<4->{Costo de detectar ciclo con $n$ procesos: }\onslide<5->{$O(n^2)$}
//
//

section#dl_prev-alg-bankersAlg
	h2  El algoritmo del banquero (E. Dijkstra, 1977)

	section#dl_prev-alg-bankersAlg_
		p Analogía: el banquero entrega dinero de manera que pueda satisfacer a todos sus clientes
		ul
		  li.fragment  Cada proceso declara su demanda máxima para cada (clase de) recurso.
		  li.fragment  El algoritmo sólo asigna recursos si puede mantenerse en un estado seguro

		p.fragment Estructuras: $m$ recursos, $n$ procesos
		ul.fragment
		  li.fragment  <code>Available[m]</code>, cantidad disponible para cada recurso
		  li.fragment  <code>Max[n][m]</code>, máxima demanda para cada proceso.
		  ul
		    li.fragment  <code>Max[i][j]=k</code>: $P_i$ puede solicitar hasta $k$ instancias de $R_j$
		  li.fragment  <code>Allocation[n][m]</code>, cantidades asignadas a cada proceso.
		  ul
		    li.fragment  <code>Allocation[i][j]=k</code>: $P_i$ tiene $k$ instancias de $R_j$
		  li.fragment  <code>Need[n][m]</code>, solicitud potencial para cada proceso
		  ul
		    li.fragment  <code>Need[i][j]=k</code>: $P_i$ podría pedir hasta $k$ instancias de $R_j$
		    li.fragment  <code>Need[i][j] == Max[i][j] - Allocation[i][j]</code>



/XXX
	/section#dl_prev-alg-bankersAlg_
		p ¿Cómo saber si estamos en un estado seguro?
		pre
			code.hljs.c
				| int Work[m] = Available;
				  bool Finish[n] = FALSE;
				  
				  /* encontrar indice $i$ tal que Finish[i]==FALSE y Need[i] $\leq$ Work **/
				  while(existe i tal que (!Finish[i] && Need[i] <= Work)) {
				    Work += Allocation[i];
				    Finish[i] = TRUE;
				  }
				  
				  for(i=0;i<n;i++)
				    if(!Finish[i])
				      return UNSAFE;
				  return SAFE;
		p Tiempo de ejecución: <span class="fragment">$O(m \times n^2)$</span>



//	section#[fragile]
//		\frametitle{Evitar <em>deadlock</em>s}
//		\framesubtitle{Algoritmo del banquero (E.W.Dijkstra, 1977)}
//
//		¿Cómo determinar si es posible hacer una asignación de recursos?
//
//		Input: <code>Request[i]</code>, solicitud de $P_i$
//		\begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
//		  assert(Request[i] <= Need[i]); /** no puede pedir mas de lo que declara **/
//		  if(Request[i] <= Available) {
//		    /** Simula una asignacion **/
//		    Available = Available - Request[i];
//		    Allocation[i] = Allocation[i] + Request[i];
//		    Need[i] = Need[i] - Request[i];
//		    if(safetyAlgorithm() == SAFE) { /** el de la slide anterior **/
//		      return ALLOCATED;
//		    }
//		    else {
//		      /** deshacer la asignacion **/
//		      return WAIT;
//		    }
//		  }
//		  else {
//		    return WAIT;
//		  }
//
//  
//	section#
//		\frametitle{Evitar <em>deadlock</em>s}
//		\framesubtitle{Algoritmo del banquero (E.W.Dijkstra, 1977)}
//
//		Ejemplo: $P=\{P_0,P_1,P_2,P_3,P_4\}, R=\{R_A,R_B,R_C\}$
//
//		$|R_A|=10, |R_B|=5, |R_C|=7$
//
//		Estado actual:
//		\[
//		\begin{array}{c|c|c|c|}
//		 \textbf{Alloc} & A & B & C \\ \hline
//		 P_0 & 0 & 1 & 0 \\ \hline
//		 P_1 & 2 & 0 & 0 \\ \hline
//		 P_2 & 3 & 0 & 2 \\ \hline
//		 P_3 & 2 & 1 & 1 \\ \hline
//		 P_4 & 0 & 0 & 2 \\ \hline
//		\end{array}
//		\qquad 
//		\begin{array}{c|c|c|c|}
//		 \textbf{Max} & A & B & C \\ \hline
//		 P_0 & 7 & 5 & 3 \\ \hline
//		 P_1 & 3 & 2 & 2 \\ \hline
//		 P_2 & 9 & 0 & 2 \\ \hline
//		 P_3 & 2 & 2 & 2 \\ \hline
//		 P_4 & 4 & 3 & 3 \\ \hline
//		\end{array}
//		\qquad
//		 \begin{array}{c|c|c|c|}
//		 \textbf{Need} & A & B & C \\ \hline
//		 P_0 & 7 & 4 & 3 \\ \hline
//		 P_1 & 1 & 2 & 2 \\ \hline
//		 P_2 & 6 & 0 & 0 \\ \hline
//		 P_3 & 0 & 1 & 1 \\ \hline
//		 P_4 & 4 & 3 & 1 \\ \hline
//		\end{array}
//		\]
//		$\textbf{Available}=\{3,3,2\}$
//
//		El estado actual es <strong>safe</strong>, ¿por qué? \onslide<2->{({$\langle P_1,P_3,P_4,P_2,P_0 \rangle$})}
//
//		ul.fragment
//		  li.fragment  Ejecutar <em>request</em> de $P_1$: <code>Request[1]=\{1,0,2\}</code>
//		  li.fragment  Ejecutar <em>request</em> de $P_4$: <code>Request[4]=\{3,3,0\}</code>
//		  li.fragment  Ejecutar <em>request</em> de $P_0$: <code>Request[0]=\{0,2,0\}</code>
//
//
//  
//	section#
//		\frametitle{Detectar <em>deadlock</em>s}
//
//		Si no se toma ninguna acción previa, pueden ocurrir <em>deadlocks</em>
//
//		\onslide<2->{Se necesita:}
//
//		ul
//		  li.fragment <3->{Algoritmo para detectar <em>deadlocks</em>}
//		  li.fragment <3->{Algoritmo para resolver <em>deadlocks</em>}
//		\end{itemize}
//
//		Costo de detectar ciclos en grafo de asignación de $n$ procesos: $O(n^2)$
//
//		\begin{center}
//		  /== image_tag [width=6cm]{images/figures/01-7_09.pdf.png}
//		\end{center}
//
//
//  
//	section#
//		\frametitle{Detectar <em>deadlock</em>s}
//		\framesubtitle{Pero con múltiples instancias por recurso}
//
//		Algoritmo de detección de <em>deadlock</em> basado en el banquero
//
//		\onslide<2->{Estructuras: $m$ recursos, $n$ procesos}
//		ul
//		  li.fragment <2-> <code>Available[m]</code>, cantidad disponible para cada recurso
//		  li.fragment <2-> <code>Allocation[n][m]</code>, cantidades asignadas a cada proceso.
//		    ul
//		      li.fragment  <code>Allocation[i][j]=k</code>: $P_i$ tiene $k$ instancias de $R_j$
//		    \end{itemize}
//		  li.fragment <2-> <code>Request[n][m]</code>, solicitud actual para cada proceso
//		    ul
//		      li.fragment  <code>Request[i][j]=k</code>: $P_i$ solicita $k$ instancias de $R_j$
//
//  
//	section#[fragile]
//		\frametitle{Detectar <em>deadlock</em>s}
//		\framesubtitle{Pero con múltiples instancias por recurso}
//
//		Detección de <em>deadlock</em>
//
//		\begin{minted}[mathescape,numbersep=5pt,gobble=2,frame=lines,framesep=2mm,fontsize=\scriptsize,linenos=false]{c}
//		  /** Deadlock detection algorithm **/
//		  int Work[m] = Available; bool Finish[n];
//		  for(i=0;i<n;i++)
//		    if(Allocation[i] != 0) Finish[i] = FALSE;
//		    else                   Finish[i] = TRUE;
//		  /** encontrar indice $i$ tal que Finish[i]==FALSE y Request[i] $\leq$ Work **/
//		  while(existe i tal que (!Finish[i] && Request[i] <= Work)) {
//		    Work = Work + Allocation[i];
//		    Finish[i] = TRUE;
//		  }
//		  /** todos pueden terminar? **/
//		  for(i=0;i<n;i++)
//		    if(Finish[i] == FALSE) return DEADLOCKED;
//		  return NOT_DEADLOCKED;
//		\end{minted}
//		Todos los procesos para los cuales <code>Finish[i]==FALSE</code> están en <em>deadlock</em>
//
//		Tiempo de ejecución: \onslide<2->{$O(m \times n^2)$}
//
//
//	section#
//		\frametitle{Detectar <em>deadlock</em>s}
//
//		Ejemplo: $P=\{P_0,P_1,P_2,P_3,P_4\}, R=\{R_A,R_B,R_C\}$
//
//		$|R_A|=10, |R_B|=5, |R_C|=7$
//
//		Estado actual:
//		\[
//		\begin{array}{c|c|c|c|}
//		 \textbf{Alloc} & A & B & C \\ \hline
//		 P_0 & 0 & 1 & 0 \\ \hline
//		 P_1 & 2 & 0 & 0 \\ \hline
//		 P_2 & 3 & 0 & 3 \\ \hline
//		 P_3 & 2 & 1 & 1 \\ \hline
//		 P_4 & 0 & 0 & 2 \\ \hline
//		\end{array}
//		\qquad 
//		\begin{array}{c|c|c|c|}
//		 \textbf{Req} & A & B & C \\ \hline
//		 P_0 & 0 & 0 & 0 \\ \hline
//		 P_1 & 2 & 0 & 2 \\ \hline
//		 P_2 & 0 & 0 & 0 \\ \hline
//		 P_3 & 1 & 0 & 0 \\ \hline
//		 P_4 & 0 & 0 & 2 \\ \hline
//		\end{array}
//		\]
//		$\textbf{Available}=\{0,0,0\}$

//		El estado actual es <strong>NOT DEADLOCKED</strong>, ¿por qué? \onslide<2->{({$\langle P_0,P_2,P_3,P_1,P_4 \rangle$})}

//		ul
//		  li.fragment <3-> Ejecutar <em>request</em> de $P_2$: <code>Request[2]=\{0,0,1\}</code>


//	section#
//		\frametitle{Recuperación ante <em>deadlock</em>s}

//		p OK, hemos detectado el <em>deadlock</em> (so what?)

//		p.fragment Dos caminos&hellip;
//		ul
//		  li.fragment <strong>Matar un proceso</strong> ¿Cuál?
//		    ul
//		      li.fragment Todos (solución drástica)
//		      li.fragment Uno a la vez hasta resolver el <em>deadlock</em>
//		        ul
//		          li.fragment  Criterio 1: La cantidad mínima
//		          li.fragment  Criterio 2: El de menor ``costo''
//		  li.fragment <strong>Expropiar recursos</strong>
//		    ul
//		      li.fragment  ¿A quién?
//		      li.fragment  <strong>Rollback</strong>


//	section#
//		\frametitle{Recuperación ante <em>deadlock</em>s}
//		\framesubtitle{Algunos puntos importantes}
//
//		ul
//		  li.fragment  <em>Deadlock</em>: dos o más procesos esperando indefinidamente por un evento
//		        que sólo puede ser producido por uno de ellos mismos.
//		        ul
//		          li.fragment  Requieren: recursos no compartibles, no expropiables, ``retención-y-espera'',
//		                y espera circular.
//		          li.fragment  Si se impide una de estas condiciones, no se puede producir <em>deadlock</em>
//		        \end{itemize}
//		  li.fragment  Tres alternativas de manejo:
//		    ul
//		      li.fragment  Prevenir (que nunca pueda ocurrir), o evitar (esquivarlo antes que pase)
//		      li.fragment  Permitirlo y recuperarse. Desafío: resolver con el menor ``daño'' posible
//		      li.fragment  Ignorarlo
//		  li.fragment  Algoritmo del banquero (Dijkstra, 1977), evita que el proceso llegue a un <em>estado inseguro</em>
//		  li.fragment  Sistema en <em>estado seguro</em> no puede estar en <em>deadlock</em>






section#summary
	h2  Administración de Procesos

	section#summary_
		p  ¿Qué debemos recordar?

		ul
		  li.fragment  Procesos: programa+recursos, administrados por el S.O. mediante <em>syscall</em>s
		  li.fragment  <em>Threads</em>: unidad básica de ejecución visible al programador o al S.O.
		  li.fragment  Sincronización de <em>threads</em> permite que puedan ejecutar eficientemente, sin bloquearse, y sin provocar inconsistencias en los datos compartidos
		  li.fragment  Algoritmos de <em>scheduling</em> permiten seleccionar eficientemente el próximo proceso/<em>thread</em> a ejecutar
		  li.fragment  Se debe evitar caer en situación de <em>bloqueo mutuo</em>


