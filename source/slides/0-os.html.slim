---
title: 0 - Caracterización de Sistemas Operativos
layout: slide
---



section
	h2 Estructura de un Sistema Operativo
	/  ----------------------------------

	section data-transition="fade"
		div ¿Dónde vive el Sistema Operativo?
		div.fragment == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		/	== image_tag '/images/figures/00-ComponentesSistComp.png', :width=>"50%"

	section data-transition="fade"
		div Sistema Operativo <b>es</b> <i>software</i>
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"

	section data-transition="fade"
		div Sistema Operativo <b>habla con</b> el <i>hardware</i>
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment ¿Qué pasaría si no hubiese sistema operativo? ... <span class="fragment">Antes no había</span>

	section data-transition="fade"
		div ¿Interactuamos con el Sistema Operativo?
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment Normalmente interactuamos con <b>interfaces de usuario</b>: <span class="fragment"><b>shell</b>, <b>GUI</b></span>

	section data-transition="fade"
		div ¿User mode?, ¿kernel mode?
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment Solo el Sistema Operativo utiliza el <i>kernel mode</i> ... <span class="fragment"><i>(a.k.a. monitor, privileged, system, supervised)</i></span>
		

section
	h2 ¿Qué es un Sistema Operativo?
	/  -------------------------------

	section
		p.fragment <i>Software</i> ... <span class="fragment">que corre en <i>kernel mode</i></span>
		p.fragment No hace mucho por sí mismo (es como el gobierno)
		p.fragment Pero es fundamental
		p.fragment Sería inútil sin programas/aplicaciones/usuarios (personas)

	section
		h3 ¿Qué hace el sistema operativo?
		ul
			li.fragment data-fragment-index="1" Para el usuario:
			blockquote.fragment data-fragment-index="3" style="background: #F4C7C3;" Permite <strong>utilizar los recursos</strong> del computador (el <i>hardware</i>)
			<span class="fragment" data-fragment-index="4">Ejecutar programas, leer archivos, efectuar cálculos ... de manera limpia, fácil y rápida</span>
			br
			br
			br
			li.fragment data-fragment-index="2" Para el sistema computacional:
			blockquote.fragment data-fragment-index="5" style="background: #F4C7C3;" Permite <b>administrar los recursos</b>
			<span class="fragment" data-fragment-index="6">Permite <b>multiplexar</b> el uso de los recursos (escasos) entre múltiples programas.</span>
			ul
				li.fragment Multiplexión en tiempo: turnos. Ejemplo: uso de CPU(s), uso de impresora
				li.fragment Multiplexión en espacio: división del recurso. Ejemplo: procesos cargados en memoria, programas almacenados en disco

section
	h2 Historia de los Sistemas Operativos

	section

		p Érase una vez ...

		/div == image_tag '/images/figures/00-babbage.jpg', :width=>"10%"  

		div.fragment style="display:inline-block; width=50px"
			div Charles Babbage (1791-1871)
			div
				img src='/images/figures/00-babbage.jpg' width="20%"  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
				img src='/images/figures/00-babbage-analytical.jpg' width="20%" 
		div.fragment style="display:inline-block; width=50px"
			div style="display:inline-block;" and the Analytical Engine  


	section 
		
		div style="display:inline-block; width=50px"
			div Ada Lovelace (1815-1852)
			div
				img src='/images/figures/00-AdaLovelace.jpg' width="20%" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
				img src='/images/figures/00-AdaLovelace-algorithm.jpg' width="20%" 
		div.fragment style="display:inline-block; width=50px"
			div style="display:inline-block;" and the First Algorithm  		


	section
		h3 Primera Generación (1945-55): Tubos de vacío

		p Colossus Mark 2 @ Bletchley Park (incluyendo a Alan Turing)
		div
			img src='/images/figures/00-colossus.jpg' width="60%"

	section data-transition="fade"
		h3 Primera Generación (1945-55): Tubos de vacío

		p ENIAC @ U.Pennsylvania
		div
			img src='/images/figures/00-ENIAC.jpg' width="40%"

	section data-transition="fade"
		/h3 Primera Generación (1945-55): Tubos de vacío

		ul
			li Programación via conexión de cables (y luego, tarjetas perforadas)
			li No existían los lenguajes de programación (ni siquiera assembler)
			li Aprox. 20000 tubos de vacío

	section 
		h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

		p Separación de roles: diseñador, constructor, programador, operador, mantenedor

		p <b>Mainframes</b>

		div
			img src='/images/figures/00-ibm1401.jpg' width="30%"

		p IBM1402 (card reader), IBM1401 (processing), IBM1403 (printer)


	section data-transition="fade"
		/h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

		p Modo de operación: ejecución de un <b>job</b>
		ul
			li Programador escribe en FORTRAN (tarjetas perforadas) y entrega a operador
			li IBM1401 pasa tarjetas a cinta (operador lleva cinta a IBM7094)
			li IBM7094 procesa cinta (operador lleva cinta a IBM1403)
			li IBM1403 imprime resultados

		div
			img src='/images/figures/00-ibm7094.jpg' width="30%"
		p IBM7094

	section data-transition="fade"
		/h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

		p Proceso de <i>trabajo por lotes</i>, <b>batch</b>
		ul
			li Uso de lenguajes: assembler y FORTRAN
			li Sistema Operativo: FMS (Fortran Monitor System)
			li Sistema Operativo: IBSYS (para el IBM7094)


	section
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p IBM unifica sus <i>mainframes</i> en System/360. Misma arquitectura e instruction set.

		blockquote Primeros en utilizar <b>circuitos integrados</b>

		div
			img src='/images/figures/00-ibms360.jpg' width="40%"


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p Si el <i>hardware</i> está unificado, ¿por qué no el <i>software</i>?

		p.fragment <b>OS/360</b> (Fred Brooks)

		p.fragment Mientras se procesa I/O, la CPU no realizaba trabajo

		blockquote.fragment style="background: #F4C7C3;" OS/360 introduce la <b>multiprogramación</b>

		ul
			li.fragment Particionamiento de la memoria
			li.fragment Si un proceso no está ocupando la CPU, se entrega a otro

	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p Posibilidad de cargar un programa de tarjeta a memoria en el momento que un espacio queda libre

		blockquote.fragment style="background: #F4C7C3;" Simultaneous Peripheral Operation On Line <b>SPOOLing</b>


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p Usuarios aún deben esperar horas para obtener un resultado. <span class="fragment">¿Y si hay error de compilación?</span>

		p.fragment Solución: que múltiples usuarios puedan utilizar el computador simultáneamente

		blockquote.fragment style="background: #F4C7C3;" <b>Timesharing</b>

		p.fragment Cada usuario posee un terminal para entregar comandos al computador.

		ul.fragment
			li CTSS (Compatible Time Sharing System), MIT.
			li Primer sistema de timesharing de propósito general.
			li Problema: usuarios deben tener cuidado de no alterar el trabajo de otros

	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p MIT, Bell Labs, General Electric, deciden crear un sistema que soporte cientos de usuarios.

		ul
			li.fragment MULTICS (MULTIplexed Information and Computing Service)
			li.fragment Escrito en lenguaje PL/I (poco popular y con un compilador deficiente)
			li.fragment Bell Labs y General Electric abandonan

		p.fragment Visión de MULTICS: sistema de computación que pueda ser accedido por múltiples usuarios, en que el <i>mainframe</i> ejecuta todo, y usuarios acceden a través de terminales "livianos"


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p DEC (Digital Equipment Corporation) produjo su propia seria de minicomputadores, desde PDP-1 al PDP-11

		p.fragment 1970. Ken Thompson y Dennis Ritchie escriben una versión reducida de MULTICS para un PDP-7 abandonado.

		blockquote.fragment style="background: #F4C7C3;" Al ser un MULTICS reducido, lo llaman UNICS, y finalmente <b>UNIX</b>

		ul
			li.fragment 1972. Dennis Ritchie reescribe el código de Unix en C
			li.fragment Surgen muchas versiones (incompatibles entre sí), pero dos sobreviven
			li.fragment <b>System V</b>, de AT&T, y <b>BSD</b> (Berkeley Software Distribution) de U.C.Berkeley.
			li.fragment IEEE desarrolla una interfaz estándar: <b>POSIX</b>


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p 1987. Andrew Tanenbaum desarrolla una versión simplificada con objetivos educacionales: MINIX

		p.fragment 1991. Linus Torvalds, inspirado en MINIX, escribe su propia versión: <b>LINUX</b>


	section 
		h3 Cuarta Generación (1980-): Computadores Personales

		p LSI (Large Scale Integration) posibilita la construcción de miles de transistores en 1cm2. <span class="fragment">Surgen los computadores personales, o <b>microcomputadores</b></span>

		ul
			li.fragment 1974. Intel 8080. Primera CPU de propósito general de 8-bit. No tiene S.O.
			li.fragment Gary Kildall, consultor, escriben <b>CP/M</b> (Control Program for Microcomputers) en un diskette de 8''.
			li.fragment Intel no se interesa, y entrega CP/M de vuelta a Gary Kildall.
			li.fragment 1977. Gary Kildall funda Digital Research y adapta CP/M para otras CPU.
			li.fragment 1980. IBM crea el IBM PC. Para probarlo obtienen un intérprete BASIC de <span class="fragment">Bill Gates</span>
			li.fragment IBM PC no tiene Sistema Operativo. Bill Gates sugiere que contacten a Gary Kildall
			li.fragment Kildall rechaza a IBM. IBM solicita un Sistema Operativo a Bill Gates.
			li.fragment Bill Gates compra <b>DOS</b> a Seatlle Computer Products, y lo ofrece a IBM.
			li.fragment Bill Gates contrata a Tim Patterson en su nueva compañía, Microsoft, y producen <b>MS-DOS</b>
			li.fragment MS-DOS se populariza al ser ofrecido a empresas de computación y no a usuarios.


	section data-transition="fade"
		h3 Cuarta Generación (1980-): Computadores Personales

		p GUIs atraen a usuarios que no saben (ni les interesa) el funcionamiento del computador.

		ul
			li.fragment 1983. IBM PC/AT, con Intel 80286 y MS-DOS.
			li.fragment MS-DOS ampliamente usado con Intel 80386 y 80486.
			li.fragment Tanto CP/M como MS-DOS usaban una <b>shell</b> (línea de comandos) como interacción.
			li.fragment 1960s. Doug Engelbart inventa las <b>GUI</b> (Graphical User Interface), que empiezan a ser usadas en XEROX PARC.
			li.fragment Steve Jobs conoce la GUI en XEROX PARC y la incorpora su siguiente computador Apple: <span class="fragment">Macintosh</span>


	section data-transition="fade" 
		h3 Cuarta Generación (1980-): Computadores Personales

		p Microsoft adopta GUIs: Windows

		ul
			li.fragment 1985-1995. MS-DOS ejecuta Windows como una aplicación de usuario.
			li.fragment 1995. Windows 95 reemplaza a MS-DOS.
			li.fragment Windows 95 y Windows 98 aún mantienen código assembler Intel 16-bit.
			li.fragment Microsoft reescribe Windows completamente para 32-bit. Windows New Technology: <span class="fragment">Windows NT</span>
			li.fragment 1999. Windows NT 4.0 y Windows 2000 se posicionan en el ámbito corporativo.
			li.fragment Windows Me termina con la línea de Windows 95/98.
			li.fragment 2001. Windows 2000 evoluciona a Windows XP.
			li.fragment Línea server. Windows 2003 Server, Windows 2008.
			li.fragment Línea client. Windows Vista, Windows 7, Windows 8, Windows 10.

	section data-transition="fade" 
		h3 Cuarta Generación (1980-): Computadores Personales

		p Evolución de UNIX

		ul
			li.fragment UNIX popular en ambiente de servidores. 
			li.fragment Linux crece en computadores personales.
			li.fragment <b>FreeBSD</b> deriva de BSD. OSX es una versión modificada de FreeBSD.
			li.fragment MIT produce un sistema de ventanas para UNIX: X Windows System (luego X11).
			li.fragment UNIX adopta GUIs que funcionan sobre X11 (Gnome, KDE, XFCE, etc)
			li.fragment Windows Me termina con la línea de Windows 95/98.


	section 
		h3 Quinta Generación (1980-): Computadores Móviles

		p Evolución de dispositivos móviles

		ul
			li.fragment 1946. Primer teléfono móvil. 40 kg.
			li.fragment 1970. Teléfono móvil de 1 kg. (ladrillo)
			li.fragment 1990s. Nokia N9000 combina teléfono con PDA (Personal Digital Assistant)
			li.fragment Primeros sistemas operativos para móviles: SymbianOS
			li.fragment 2002. RIM. Blackberry OS
			li.fragment 2007. Apple. iOS.
			li.fragment 2008. Google. Android. Basado en Linux.
			li.fragment 2011. Nokia cambia SymbianOS por Windows Phone.


section
	h2 ¿Qué es un Sistema Operativo?
	/  -----------------------------

	section
		p ¿Qué incluye?
		ul
			li.fragment ¿Interfaz gráfica?
			li.fragment ¿Editores?
			li.fragment ¿Línea de comando?
		p.fragment ¿De qué tamaño es? <a href="http://www.informationisbeautiful.net/visualizations/million-lines-of-code">(¿Megas? ¿Kilos? ¿Gigas?)</a>
		ul
			li.fragment Windows 7: \( \sim 40\times 10^6 \) líneas de código
			li.fragment Linux: \( \sim 15 \times 10^6 \) líneas de código
		p.fragment Entonces, el S.O. es "lo que hay" disponible
		ul
			li.fragment Lo que obtenemos de Microsoft/Apple
			li.fragment Lo que bajamos de Linux


	section
		p Lo comúnmente aceptado:
		ul
			li.fragment Sistema Operativo

			blockquote.fragment
				| Sistema Operativo = Kernel + Programas del Sistema

			li.fragment Kernel

			blockquote.fragment
				| Un programa que <strong>siempre</strong> se está ejecutando.
				| <br/>Provee funcionalidad mínima: acceso a CPU, memoria, dispositivos.
			li.fragment Programas del sistema

			blockquote.fragment
				| Extienden las funciones del kernel.



section
	h2 ¿Sobre qué <em>hardware</em>?
	/  -----------------------------

	section
		p Distintas arquitecturas
		ul
			div.fragment
				li Single-core
				ul
					li Un procesador de propósito general
					li Algunas funciones delegadas a procesadores especializados
			div.fragment
				li Multi-core
				ul
					li Mayor rendimiento: ¿\(N\)?
					li Economía de escala
					li Mayor confiabilidad (reliability)
			div.fragment
				li Arquitectura en <em>cluster</em>
				ul
					li Múltiples procesadores conectados por red
					li Mayor potencia de cómputo (HPC)
					li Es necesario manejar balance de carga y consistencia de datos
		blockquote.fragment
			| Sistema operativo debe ser capaz de explotar las características de cada arquitectura



section
	h2 ¿Por qué estudiar Sistemas Operativos?
	/  --------------------------------------
	h6
		small
			| (o ¿por qué no?)

	section
		ul
			div.fragment
				li Piezas de software complejas
				ul
					li Años de estudio y evolución
					li ¿Cuántos sistemas operativos distintos manejan?
					li ¿Cuántos sistemas operativos distintos usarán?

			div.fragment
				li Un Sistema Operativo tiene múltiples desafíos:
				ul
					li ¿Cómo proveer sistemas de alto rendimiento?
					li ¿Cómo consumir la menor cantidad de energía?
					li ¿Cómo asegurar que un usuario no altere datos o programas privados?



section
	h2 Evolución de Sistemas Operativos
	/  --------------------------------



section
	h2 Versión 1.0
	/  -----------

	section
		p Objetivo: acceder transparentemente a <em>hardware</em>
		ul
			div.fragment
				li ¿Cómo?: API para acceder a instrucción de <em>hardware</em> y conjunto de <em>drivers</em> para dispositivos.

			div.fragment
				li Supuestos:
				ul
					li Sólo un usuario accede simultáneamente al computador
					li Ningún usuario/programa hace uso malicioso del <em>hardware</em>

			div.fragment
				li Problemas:
				ul
					li Baja utilización de <em>hardware</em>: CPU inutilizada mientras se accede a disco
					li Usuario debe esperar que un programa termine antes de utilizar otro



section
	h2 Versión 2.0
	/  -----------

	section
		p Objetivo: ejecutar múltiples programas simultáneamente. <strong>Multiprogramación</strong>

		ul
			div.fragment
				li ¿Cómo?: Si un proceso se bloquea, ejecutar otro.

			div.fragment
				li Supuestos:
				ul
					li Ningún programa utilizará la CPU demasiado tiempo (programas cooperativos)
					li Ningún programa sobreescribirá datos de otro programa

			div.fragment
				li Métodos:
				ul
					li <em>Preemption</em>: capacidad de <em>expropiar</em> la CPU a un programa
					li <em>Protección de memoria</em>: definir secciones de memoria para cada programa



section
	h2 Versión 3.0
	/  -----------

	section
		p Objetivo: que más de un usuario pueda utilizar simultáneamente el computador

		ul
			div.fragment
				li ¿Cómo?: Dándole un tiempo a cada usuario (<em>multitasking</em>)
			div.fragment
				li Problemas:
				ul
					li Cada usuario quiere el mayor tiempo posible: <em>planificación y políticas de uso</em>
					li Cada usuario quiere usar la mayor cantidad de memoria disponible: <em>virtualización de memoria</em>
					li ¿Hasta cuántos usuarios/programas aceptar? (<em>thrashing</em>)

			div.fragment
				li Método: niveles de privilegio
				ul
					li Programas de usuario (aplicaciones) son <em>no privilegiados</em>
					li Programas de <em>kernel</em> son <em>privilegiados</em>
					li Solo programas de <em>kernel</em> pueden modificar el sistema



/ %!
/ %section
	/ % h2 ¿Qué se le pide a un Sistema Operativo?
	/ % explicarlos de manera natural

// %	ul
// %		ul.fragment Capacidad de ejecutar <strong>procesos</strong> definidos por el usuario
// %		ul.fragment Capacidad de <strong>multiprogramación</strong>
// %			ul
// %				ul.fragment Múltiples procesos en memoria (¿y si no caben?)
// %				ul.fragment Mover algunos a disco (¿cuáles?)
// %				ul.fragment Mantener siempre uno en ejecución (¿cuál?)
// %				ul.fragment Debe hacer planificación: <strong>job+CPU scheduling</strong>
// %				%li Ejemplo vida real
// %
// %		ul.fragment Capacidad de <strong>time-sharing} o {\bf multitasking</strong>
// %			ul
// %				ul.fragment Cambio frecuentes entre programas
// %				ul.fragment Permite que múltiples usuarios utilicen el sistema
// %				ul.fragment Permite aplicaciones interactivas
// %
// %		ul.fragment Capacidad de administrar la <strong>memoria</strong> del sistema
// %			ul
// %				ul.fragment Cada proceso requiere memoria, pero ésta es limitada
// %				ul.fragment Swapping ... \onslide<13-> memoria virtual
// %
// %		ul.fragment Capacidad de utilizar <strong>almacenamiento no-volátil</strong>
// %
// %



section
	h2 ¿Cómo funciona el Sistema Operativo?
	/  ------------------------------------
	/ explicarlos de manera natural

	blockquote
		| Si está siempre ejecutando, ¿cuándo le toca al usuario?
		| <br/><span class="fragment">Los Sistemas Operativos son manejados por <em>interrupciones</em> / <em>traps.</em></span>

	p.fragment Mientras nadie (usuario/programa) lo llame, el S.O. no hace nada.
	ul
		li.fragment <em>Trap</em>: interrupción generada por software
		ul
			li.fragment Error o solicitud de un programa
			li.fragment Por cada solicitud, el S.O. toma una acción

		li.fragment S.O. debe asegurar que errores en un programa no afecten a otro
		ul
			li.fragment ¿Qué pasa si un programa entra en un loop infinito?
			li.fragment ¿Si un programa trata de modificar memoria de otro programa? ¿o del S.O.?
			li.fragment Habría que asegurar que solo un proceso puede estar en modo ejecutable

		li.fragment Pero el S.O. sí debería poder modificar la memoria de otro programa, para cargarlo/descargarlo



section
	h2 Modos de operación de un Sistema Operativo
	/  ------------------------------------------

	section
		br
		= image_tag "/images/figures/00-1_10.pdf.png", :width=>"60%"

		p Modo dual suportado por hardware: mode bit (0=kernel/1=user)

		p.fragment <strong>Solo puede ser modificado por el S.O.</strong> (¿por qué?)
		p.fragment Kernel mode, a.k.a. (Privileged | Supervised | Monitor | System) mode

		blockquote.fragment
			| Instrucciones privilegiadas solo pueden ejecutar en modo kernel <br/>
			| Si se intenta ejecutar en mode=1, el hardware no la ejecuta y genera una interrupción para el S.O. Evita acceso indebido de otros usuarios

		p.fragment Ej: cambio mode bit, llamada I/O, manejo timer, manejo de interrupciones


	section
		p Multi-modos: Más de dos modos de operación, ¿para qué?

		ul
			li.fragment Útil para virtualización
			li.fragment VMM (<em>Virtual Machine Manager</em>) opera en modo intermedio
			ul.fragment
				li Menos privilegios que S.O.
				li Más privilegios que cada <em>Virtual Machine</em>

		.fragment
			== image_tag "images/figures/00-1_20.pdf.png", :width=>"40%"


	section
		p Programas de usuario hacen llamadas al S.O para que ejecute acciones a nombre de ellos

		ul
			li.fragment <em>syscall</em>, <em>trap</em>

		br
		br
		p.fragment ¿Qué puede pasar si no hay bit mode? (Intel 8088 no lo tenía)
		/ caso de 8088 y MS-DOS. Un proceso en MS-DOS podía echarse el SO

		ul
			li.fragment Mode bit permite protección de hardware
			li.fragment Si un programa comete un acceso indebido o error, trap al S.O.
			ul
				li.fragment S.O. termina el programa <em>abnormally</em>

			li.fragment ¿Cómo evitar que un programa no devuelva el control al SO?
			ul
				li.fragment S.O. usa un timer que genera un trap a intervalo definido
				li.fragment Timer también debe ser establecido en modo Kernel



section
	h2 Entonces...
	/  -----------

	section
		p 3 tareas fundamentales para un Sistema Operativo:

		ul
			li Administración de procesos
			li Administración de memoria
			li Administración de dispositivos de I/O



// %section
// %	\frametitle{Tarea: Administración de Procesos}
// %
// %	Administración de la unidad principal de trabajo: <strong>proceso</strong>.
// %
// %	\onslide<2->{Un proceso necesita diversos recursos:}
// %	ul
// %		ul.fragment CPU, memoria, archivos, dispositivos IO
// %		ul.fragment Más que un programa (programa es pasivo, proceso es activo)
// %
// %
// %	\onslide<4->{Hay procesos de usuario y procesos de sistema}
// %
// %	\begin{block}<5->{<strong>SO es responsable de:}</strong>
// %	ul
// %		ul.fragment Planificar procesos y threads en la CPU
// %		ul.fragment Crear y borrar procesos de usuario y de sistema
// %		ul.fragment Suspender y continuar procesos
// %		ul.fragment Proveer mecanismos de sincronización
// %		ul.fragment Proveer mecanismos de comunicación



// %section
// %	\frametitle{Tarea: Administración de Memoria}
// %
// %	La interacción de la CPU es principalmente con la memoria.
// %
// %	<strong>Memoria:}\onslide<2->{ Un arreglo contínuo de bytes, cada uno con su propia dirección.</strong>
// %
// %	ul
// %		ul.fragment Instruction-fetch y data-fetch ocurren con la memoria
// %		ul.fragment Aún las lecturas de disco o de IO deben pasar por memoria
// %		ul.fragment Las direcciones de un programa deben ser mapeadas a direcciones absolutas
// %		ul.fragment Un uso eficiente requiere que haya múltiples procesos con su memoria listos para ejecutar
// %
// %
// %	\begin{block}<5->{<strong>SO es responsable de:}</strong>
// %	ul
// %		ul.fragment Mantener un registro de los sectores de memoria utilizados y por quién
// %		ul.fragment Determinar qué procesos o parte de ellos deben ser cargados y descargados
// %		ul.fragment Asignar y deasignar espacios de memoria



// %section
// %	\frametitle{Tarea: Administración de Almacenamiento}
// %
// %	== image_tag '/images/figures/00-1_09.pdf.png'
// %
// %	Distribución de memoria en un sistema de multiprogramación
// %

// %---------------------------------------------------------------------
// %section
// %	\frametitle{Tarea: Administración de Almacenamiento}
// %
// %	Los sistemas de almacenamiento abstraen las propiedades físicas del medio
// %	usando una unidad lógica de almacenamiento llamada \ldots \onslide<2->{<strong>archivo}</strong>
// %
// %	\onslide<2->{<strong>Archivo:}}\onslide<3->{ colección de datos relacionados, definida por su creador</strong>
// %	\onslide<4->{(sí, es algo muy general)}
// %
// %	\onslide<5->{S.O. mapea archivos a ubicaciones dentro de medios físicos}
// %
// %	ul
// %		ul.fragment Distintos medios: discos magnéticos, ópticos, estado sólido, cintas
// %		ul.fragment Distintas propiedades: velocidad de acceso, de transferencia, método de acceso (seq/aleatorio)
// %		ul.fragment Debe definir quién puede acceder un archivo
// %
// %
// %	\begin{block}<6->{<strong>SO es responsable de:}</strong>
// %	ul
// %		ul.fragment Crear y borrar archivos, y directorios que permitan organizar archivos
// %		ul.fragment Proveer primitivas para manipulación de archivos y directorios
// %		ul.fragment Mapear archivos a almacenamiento secundario
// %		ul.fragment Almacenar archivos en medios no-volátiles



// %section
// %	\frametitle{Tarea: Administración de Almacenamiento}
// %
// %	El almacenamiento secundario debe ser utilizado eficientemente
// %
// %	ul
// %		ul.fragment Su acceso suele limitar la velocidad de ejecución
// %
// %
// %	\begin{block}<3->{<strong>SO es responsable de:}</strong>
// %	ul
// %		li Administrar espacio disponible
// %		li Asignación de destino de almacenamiento
// %		li Planificación de disco



// %---------------------------------------------------------------------
// %section
// %	\frametitle{Caching}
// %	\framesubtitle{El problema de la jerarquía de memoria}
// %
// %	Fundamental para asegurar un funcionamiento eficiente.
// %
// %	Existe por la diferencia en los accesos a la jerarquía de memoria
// %
// %	\begin{center}
// %		/== image_tag [width=6cm]{images/figures/00-1_04.pdf.png}
// %	\end{center}

// %section
// %	\frametitle{Caching}
// %
// %	ul
// %		li Datos viven en memoria principal
// %		li Al usarla se copia en almacenamiento más rápido
// %		li Al buscarla, se busca primero en caché
// %		li Si no se encuentra, se lee de memoria principal y se copia en caché
// %
// %	\onslide<2->{Caché}
// %	ul
// %		ul.fragment Registros: caché más cercano, administrado por programador/compilador
// %		ul.fragment Cachés implementados en hardware, fuera del control de SO
// %		ul.fragment Algunos datos deben ser borrados del caché, ¿cuáles?
// %		ul.fragment Administración de caché es importante
// %
// %
// %	\onslide<3->{¿Qué pasa cuando hay múltiples copias? ¿Con más de un proceso?}
// %
// %	\onslide<4->{<strong>Coherencia de caché}} \onslide<5->{\ldots ¿Y en un ambiente distribuido?</strong>


// %section
// %	\frametitle{Caching}
// %
// %	Tiempos de acceso
// %
// %	\begin{center}
// %		/== image_tag [width=10cm]{images/figures/00-1_11.pdf.png}
// %	\end{center}


// %section
// %	\frametitle{Protección y Seguridad}
// %
// %	Ante múltiples usuarios, el acceso a datos debe ser regulado
// %
// %	\onslide<2->{Hasta ahora \ldots}
// %	ul
// %		ul.fragment Hardware asegura que procesos solo pueden acceder memoria dentro de su espacio
// %		ul.fragment Timer asegura que ningún proceso se quede sin devolver la CPU
// %		ul.fragment Registros de control de dispositivos no son accesibles por usuarios
// %
// %
// %	\onslide<4->{Sistemas de <strong>protección} controlan el acceso de procesos o usuarios a los recursos computacionales</strong>
// %
// %	ul
// %		ul.fragment Un buen sistema de protección también puede sufrir de accesos indebidos
// %
// %
// %	\onslide<6->{Un sistema de <strong>seguridad} debe defender de ataques externos e internos</strong>


// %section
// %	\frametitle{Protección y Seguridad}
// %
// %	Algunos requisitos de los sistemas de protección y seguridad
// %
// %	ul
// %		ul.fragment Distinción entre usuarios: nombre e identificador (userID, securityID)
// %		ul.fragment Grupos de usuarios e identificadores de grupos
// %		ul.fragment Asociación de privilegios/permisos
// %		ul.fragment Métodos seguros para escalar privilegios (setuid)



section
	h2 Elementos y Servicios de un Sistema Operativo
	/  ---------------------------------------------

	section
		p At a glance...

		= image_tag '/images/figures/00-2_01.pdf.png', :width => "80%"



section
	h2 Interfaces de Usuario (UI)
	/  --------------------------

	section
		p Varias alternativas...
		ul
			li.fragment <em>Command-Line Inteface (CLI):</em> Comandos se ingresan por teclado
			li.fragment <em>Batch interface:</em> Comandos se ingresan en archivos
			li.fragment <em>Graphical User Interface (GUI):</em> Sistema de ventanas + <em>pointing-device</em>

	section
		h4 Command-Line (línea de comandos) <span class="fragment">(<strong>shells</strong>)</span>

		p.fragment Para UNIX
		div.fragment
			ul
				li <em>Bourne shell</em>: Stephen Bourne, 1977, UNIX, <code>sh</code>
				li <em>C shell</em>: Bill Joy, 1978, BSD UNIX, <code>csh</code>
				li <em>TENEX C Shell</em>: Ken Greer, 1983, <code>tcsh</code>
				li <em>Korn shell</em>: David Korn, 1983, <code>ksh</code>
				li <em>Bourne-Again shell</em>: Brian Fox, 1989, <code>bash</code>
				li <em>Z shell</em>: Paul Fastad, 1990, <code>zsh</code>

		p.fragment En windows
		div.fragment
			ul
				li <em>MS-DOS prompt</em>: MS-DOS, Win95/98/Me, <code>COMMAND.COM</code>
				li <em>Command Prompt</em>: <code>cmd.exe</code>
				li <em>PowerShell</em>


	section
		h4 Command-Line (línea de comandos)

		p Uso común:
		ul
			li Solicitar comando/instrucción al usuario y ejecutarlo
			li Formato: <code>prompt comando [parametros]</code>

		div.fragment
			p <em>Command Prompt</em> (símbolo del sistema)
			ul
				li.fragment Indica que el sistema está lista para recibir un comando
				li.fragment Usualmente un texto terminado en <code>$, %, #, :, ></code>

		div.fragment
			pre
				code.hljs
					| cruz$ ls
					 
					 jabaier@grima$ cp clase-01.tex backup/
					 
					 jnavon@www[15:35]:> rm tareaSistOp.*
					 
					 dietr1ch@nb ~/SO/Tareas 
					 ls -d */ | parallel --tag 'cd {} && make'


	section
		h4 Graphical User Interface (GUI)

		p Interfaz gráfica (para quienes no les gusta escribir comandos)
		div.fragment
			ul
				li Usualmente con un <em>pointing-device</em> y ventanas
				li Métaforas: escritorio, íconos, carpetas, menúes
				li Más allá de <em>pointing-device</em>: gestos y acciones visuales

		p.fragment Vienen de los \(\sim\) 1970's
		div.fragment
			ul
				li Investigación de Xerox Palo Alto Research Center (PARC)
				li Primera interfaz gráfica: 1973
				li Popularizados en 1980s: Apple Macintosh (Mac OS)
				li Windows 1.0 agregó GUI a MS-DOS


	section
		h4 Graphical User Interface (GUI)

		p Tradicionalmente UNIX/Linux han sido manejados por CLI,
		p.fragment pero se han desarrollado muchas GUIs

		ul
			li.fragment CDE (<em>Common Desktop Environment</em>): Unix, OpenVMS
			li.fragment X-Windows Systems: Xfce, KDE, GNOME (Unix/Linux)
			li.fragment <a href="https://wayland.freedesktop.org/">Wayland</a>: Nueva API de GUI (Linux)

		= image_tag "/images/figures/00-Xwindows.png", :style => "max-width:50%;float:right;"


	section
		= image_tag "/images/figures/00-CDE.png", :style => 'max-width:50%; max-height:50%'
		p CDE (Common Desktop Environment)


	section
		= image_tag "/images/figures/00-XFCE.png", :style => 'max-width:50%; max-height:50%'
		p Xfce


	section
		= image_tag "/images/figures/00-GNOME.png", :style => 'max-width:50%; max-height:50%'
		p GNOME


	section
		= image_tag "/images/figures/00-KDE.png", :style => 'max-width:50%; max-height:50%'
		p KDE (K Desktop Environment)



section
	h2 Llamadas al sistema
	/  -------------------

	section
		h4 System Calls
		p Programas utilizan llamadas al sistemas frecuentemente
		p Ej: <code>copy source.txt dest.txt</code>... ¿qué requiere?

		ul
			div.fragment
				li Abrir <code>source.txt</code>
				ul
					li ¿Existe?
					li ¿Tiene permisos?

			div.fragment
				li Abrir <code>dest.txt</code>
				ul
					li ¿Existe? ¿se reemplaza?
					li ¿Se puede escribir?

			li.fragment Lectura/escritura en disco requiere llamadas al sistema
			li.fragment Terminar el programa en caso de error, requiere llamadas al sistema

		p.fragment ...pero el programador no quiere programar todas las llamadas


	section
		h4 API: Application Programming Interface

		p Sistemas Operativos proveen una API para el programador.
		ul
			li.fragment Windows API
			li.fragment POSIX API (UNIX, Linux, MacOS X), a través de {\tt libc}
			li.fragment Java API (para la JVM)

		br
		p.fragment ¿Cómo usarla?
		div.fragment
			p eg:
			pre style="width:50%;"
				code.hljs
					| man read


	section
		= image_tag "/images/figures/00-2_06.pdf.png", :style => 'max-width:60%; max-height:60%'


	section
		= image_tag "/images/figures/00-syscalls.png", :style => 'max-width:50%; max-height:50%'



// %\section{Decisiones de diseño}

// %section
// %	\frametitle{Decisiones de diseño}
// %	¿Cuál es la mejor forma de diesñar un Sistema Operativo?
// %
// %	\onslide<2->{(si se supiera no habrían <em>OS wars})</em>
// %
// %	ul
// %		ul.fragment Uso de <strong>estructuras de datos</strong> apropiadas
// %		ul.fragment Aplicando principios de <strong>ingeniería de software</strong>
// %		ul.fragment Aprovechando las capacidades que permite la <strong>arquitectura del hardware</strong>


// %section
// %	\frametitle{Decisiones de diseño}
// %
// %%	ul
// %%		li <strong>Mecanismo}: {\em cómo</strong> se implementa una funcionalidad (decisión estática)
// %%			ul
// %%				li Ej: Mecanismo para asignar prioridades a procesos.
// %%
// %%		li <strong>Política}: {\em qué</strong> decisión se va a implementar
// %%			ul
// %%				li Ej: Bajo qué criterio se asignan prioridades
// %%
// %%
// %	\onslide<2->{
// %	Principio de <strong>separación de preocupaciones} ({\em separation of concerns</strong>)
// %	ul
// %		li <em>Microkernels</em> definen un conjunto pequeño de primitivas
// %		li Mecanismo deberían <em>de propósito general</em>
// %	}


// %---------------------------------------------------------------------
// %section
// %	\frametitle{¿En qué lo programo?}
// %
// %	¿En qué se programa un sistema operativo?
// %	ul
// %		ul.fragment Los primeros ... en <em>assembler</em>
// %		ul.fragment Más modernos en C, C++ (Windows, Linux)
// %		ul.fragment Actuales incluyen muchos lenguajes
// %			ul
// %				li Bajo nivel en assembler
// %				li Interacciones principales en C
// %				li Utilidades de alto nivel en lenguaje interpretado (python, perl)
// %
// %	\onslide<5->{Al usar un lenguaje de alto nivel es más fácil hacer un <strong>port}</strong>
// %	ul
// %		li <6-> MS-DOS fue escrito en Assembler de Intel 8088
// %		li <6-> Para otras arquitecturas se requiere un <strong>emulador</strong>



section
	h2 Estructura: MS-DOS
	/  ------------------

	section
		p ¿Sistemas <strong>monolíticos</strong> o sistemas <strong>modulares</strong>?
		p.fragment Algunos ni siquiera tienen estructura
		ul
			li.fragment MS-DOS: sistema monolítico simple
			li.fragment Nadie pensó que sería tan popular
			li.fragment Intel 8088 no tenía protección de <em>dual mode</em>
			li.fragment ¿Problemas? <span class="fragment">Seguridad</span>

		br
		= image_tag "/images/figures/00-2_11.pdf.png", :style=>"float;right;", :height=>"25%", :width=>"25%"



section
	h2 Estructura: UNIX
	/  ----------------

	section
		p UNIX: Estructura monolítica diseñada de acuerdo al <em>hardware</em>

		= image_tag "/images/figures/00-2_12.pdf.png", :width => '50%'

		p.fragment ¿Problemas? <span class="fragment">Dificultad de mantenimiento</span>



section
	h2 Estructura: diseño por capas
	/  ----------------------------

	section
		p Capas se diseñan por niveles más <em>abstractos</em> de funcionalidad

		ul
			li          Capa \(M\) invoca llamadas sobre capa \(M-1\)
			li.fragment Ventaja: Facilidad de <em>debugging</em>
			li.fragment Desventaja: dificultad de definición de capas (¿a qué nivel va qué funcionalidad?)
			li.fragment Desventaja: eficiencia (¿cuántas capas?)

		= image_tag "/images/figures/00-2_13.pdf.png", :width => '25%'



section
	h2 Estructura: <em>microkernels</em>
	/  ---------------------------------

	section
		p <strong>Mach</strong>: versión de UNIX usando diseño de <em>microkernel</em> (CMU)

		ul
			li.fragment Set de funcionalidades mínimas
			li.fragment Otras funcionalidades agregadas como programas de usuario ¿dónde poner el límite?
			li.fragment Ventaja: Sistemas pequeño y fácil de portar
			li.fragment Desventaja: Mucha más interacción a través de <em>syscalls</em>!
			li.fragment <strong>Darwin</strong> (MacOS X kernel) basado parcialmente en modelo Mach
			li.fragment <strong>Windows NT</strong> usaba microkernel pero era más lento que Win95.
			li.fragment <strong>GNU/Hurd</strong> es más lento que Linux.

		= image_tag "/images/figures/00-2_14.pdf.png", :width=>'50%'



section
	h2 Estructura: <em>módulos</em>
	/  ----------------------------

	section
		p Lo más común: <strong>loadable kernel modules</strong>

		ul
			li Kernel tiene un conjunto de componentes principales (<em>core</em>)
			li Módulos necesarios se agregan durante ejecución
			li Evita recompilar el kernel para cada nueva funcionalidad
			li Solaris, Linux, MacOS X, Windows
			li Ej: kernel con soporte de manejo de archivo + módulos por cada <em>filesystem</em>

		= image_tag "/images/figures/00-2_15.pdf.png", :width=>'50%'



section
	h2 Al final: Estructuras híbridas
	/  ------------------------------

	section
		p En la práctica, pocos sistemas pueden ser encasillados

		ul
			li Linux, Solaris, Windows tienen características monolíticas (performance!)
			li Pero algunas funcionalidades siguen el diseño de <em>microkernel</em>
			li ¡Y además permiten cargar módulos dinámicamente!



// %section
// %	\frametitle{Ejemplo: Apple Mac OS X}
// %
// %	ul
// %		li <strong>Cocoa</strong>: API para Objective-C
// %		li Kernel: Mach microkernel + BSD Unix Kernel
// %		ul
// %			li Mach: manejo de memoria, RPC, IPC, paso de mensajes, <em>threads</em>
// %			li BSD: CLI, networking, sistemas de archivos, API POSIX
// %		li Módulos cargables: <strong>kernel extensions</strong>
// %
// %	== image_tag 'images/figures/00-2_16.pdf.png'



// %section
// %	\frametitle{Ejemplo: Apple iOS}
// %
// %	ul
// %		li <strong>Cocoa Touch</strong> = Cocoa + soporte para gestos
// %		li Media: soporte gráfico + audio + video
// %		li Core: kernel basado en Mac OS X
// %
// %	== image_tag 'images/figures/00-2_17.pdf.png'



// %section
// %	\frametitle{Ejemplo: Android}
// %
// %	ul
// %		li Modelo por capas + kernel Linux
// %		li Implementación de máquina virtual <strong>Dalvik</strong>
// %		li Frameworks para desarrollo: webkit, SQLite, libc
// %
// %	== image_tag 'images/figures/00-2_18.pdf.png'

