---
title: 0 - Caracterización de Sistemas Operativos
layout: slide
---



section
	h2 Estructura de un Sistema Operativo
	/  ----------------------------------

	section data-transition="fade"
		div ¿Dónde vive el Sistema Operativo?
		div.fragment == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		/	== image_tag '/images/figures/00-ComponentesSistComp.png', :width=>"50%"

	section data-transition="fade"
		div Sistema Operativo <b>es</b> <i>software</i>
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"

	section data-transition="fade"
		div Sistema Operativo <b>habla con</b> el <i>hardware</i>
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment ¿Qué pasaría si no hubiese sistema operativo? ... <span class="fragment">Antes no había</span>

	section data-transition="fade"
		div ¿Interactuamos con el Sistema Operativo?
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment Normalmente interactuamos con <b>interfaces de usuario</b>: <span class="fragment"><b>shell</b>, <b>GUI</b></span>

	section data-transition="fade"
		div ¿User mode?, ¿kernel mode?
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment Solo el Sistema Operativo utiliza el <i>kernel mode</i> ... <span class="fragment"><i>(a.k.a. monitor, privileged, system, supervised)</i></span>
		

section
	h2 ¿Qué es un Sistema Operativo?
	/  -------------------------------

	section
		p.fragment <i>Software</i> ... <span class="fragment">que corre en <i>kernel mode</i></span>
		p.fragment No hace mucho por sí mismo (es como el gobierno)
		p.fragment Pero es fundamental
		p.fragment Sería inútil sin programas/aplicaciones/usuarios (personas)

	section
		h3 ¿Qué hace el sistema operativo?
		ul
			li.fragment data-fragment-index="1" Para el usuario:
			blockquote.fragment data-fragment-index="3" style="background: #F4C7C3;" Permite <strong>utilizar los recursos</strong> del computador (el <i>hardware</i>)
			<span class="fragment" data-fragment-index="4">Ejecutar programas, leer archivos, efectuar cálculos ... de manera limpia, fácil y rápida</span>
			br
			br
			br
			li.fragment data-fragment-index="2" Para el sistema computacional:
			blockquote.fragment data-fragment-index="5" style="background: #F4C7C3;" Permite <b>administrar los recursos</b>
			<span class="fragment" data-fragment-index="6">Permite <b>multiplexar</b> el uso de los recursos (escasos) entre múltiples programas.</span>
			ul
				li.fragment Multiplexión en tiempo: turnos. Ejemplo: uso de CPU(s), uso de impresora
				li.fragment Multiplexión en espacio: división del recurso. Ejemplo: procesos cargados en memoria, programas almacenados en disco

section
	h2 Historia de los Sistemas Operativos

	section

		p Érase una vez ...

		/div == image_tag '/images/figures/00-babbage.jpg', :width=>"10%"  

		div.fragment style="display:inline-block; width=50px"
			div Charles Babbage (1791-1871)
			div
				img src='/images/figures/00-babbage.jpg' width="20%"  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
				img src='/images/figures/00-babbage-analytical.jpg' width="20%" 
		div.fragment style="display:inline-block; width=50px"
			div style="display:inline-block;" and the Analytical Engine  


	section 
		
		div style="display:inline-block; width=50px"
			div Ada Lovelace (1815-1852)
			div
				img src='/images/figures/00-AdaLovelace.jpg' width="20%" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
				img src='/images/figures/00-AdaLovelace-algorithm.jpg' width="20%" 
		div.fragment style="display:inline-block; width=50px"
			div style="display:inline-block;" and the First Algorithm  		


	section
		h3 Primera Generación (1945-55): Tubos de vacío

		p Colossus Mark 2 @ Bletchley Park (incluyendo a Alan Turing)
		div
			img src='/images/figures/00-colossus.jpg' width="60%"

	section data-transition="fade"
		h3 Primera Generación (1945-55): Tubos de vacío

		p ENIAC @ U.Pennsylvania
		div
			img src='/images/figures/00-ENIAC.jpg' width="40%"

	section data-transition="fade"
		/h3 Primera Generación (1945-55): Tubos de vacío

		ul
			li Programación via conexión de cables (y luego, tarjetas perforadas)
			li No existían los lenguajes de programación (ni siquiera assembler)
			li Aprox. 20000 tubos de vacío

	section 
		h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

		p Separación de roles: diseñador, constructor, programador, operador, mantenedor

		p <b>Mainframes</b>

		div
			img src='/images/figures/00-ibm1401.jpg' width="30%"

		p IBM1402 (card reader), IBM1401 (processing), IBM1403 (printer)


	section data-transition="fade"
		/h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

		p Modo de operación: ejecución de un <b>job</b>
		ul
			li Programador escribe en FORTRAN (tarjetas perforadas) y entrega a operador
			li IBM1401 pasa tarjetas a cinta (operador lleva cinta a IBM7094)
			li IBM7094 procesa cinta (operador lleva cinta a IBM1403)
			li IBM1403 imprime resultados

		div
			img src='/images/figures/00-ibm7094.jpg' width="30%"
		p IBM7094

	section data-transition="fade"
		/h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

		p Proceso de <i>trabajo por lotes</i>, <b>batch</b>
		ul
			li Uso de lenguajes: assembler y FORTRAN
			li Sistema Operativo: FMS (Fortran Monitor System)
			li Sistema Operativo: IBSYS (para el IBM7094)


	section
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p IBM unifica sus <i>mainframes</i> en System/360. Misma arquitectura e instruction set.

		blockquote Primeros en utilizar <b>circuitos integrados</b>

		div
			img src='/images/figures/00-ibms360.jpg' width="40%"


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p Si el <i>hardware</i> está unificado, ¿por qué no el <i>software</i>?

		p.fragment <b>OS/360</b> (Fred Brooks)

		p.fragment Mientras se procesa I/O, la CPU no realizaba trabajo

		blockquote.fragment style="background: #F4C7C3;" OS/360 introduce la <b>multiprogramación</b>

		ul
			li.fragment Particionamiento de la memoria
			li.fragment Si un proceso no está ocupando la CPU, se entrega a otro

	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p Posibilidad de cargar un programa de tarjeta a memoria en el momento que un espacio queda libre

		blockquote.fragment style="background: #F4C7C3;" Simultaneous Peripheral Operation On Line <b>SPOOLing</b>


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p Usuarios aún deben esperar horas para obtener un resultado. <span class="fragment">¿Y si hay error de compilación?</span>

		p.fragment Solución: que múltiples usuarios puedan utilizar el computador simultáneamente

		blockquote.fragment style="background: #F4C7C3;" <b>Timesharing</b>

		p.fragment Cada usuario posee un terminal para entregar comandos al computador.

		ul.fragment
			li CTSS (Compatible Time Sharing System), MIT.
			li Primer sistema de timesharing de propósito general.
			li Problema: usuarios deben tener cuidado de no alterar el trabajo de otros

	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p MIT, Bell Labs, General Electric, deciden crear un sistema que soporte cientos de usuarios.

		ul
			li.fragment MULTICS (MULTIplexed Information and Computing Service)
			li.fragment Escrito en lenguaje PL/I (poco popular y con un compilador deficiente)
			li.fragment Bell Labs y General Electric abandonan

		p.fragment Visión de MULTICS: sistema de computación que pueda ser accedido por múltiples usuarios, en que el <i>mainframe</i> ejecuta todo, y usuarios acceden a través de terminales "livianos"


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p DEC (Digital Equipment Corporation) produjo su propia seria de minicomputadores, desde PDP-1 al PDP-11

		p.fragment 1970. Ken Thompson y Dennis Ritchie escriben una versión reducida de MULTICS para un PDP-7 abandonado.

		blockquote.fragment style="background: #F4C7C3;" Al ser un MULTICS reducido, lo llaman UNICS, y finalmente <b>UNIX</b>

		ul
			li.fragment 1972. Dennis Ritchie reescribe el código de Unix en C
			li.fragment Surgen muchas versiones (incompatibles entre sí), pero dos sobreviven
			li.fragment <b>System V</b>, de AT&T, y <b>BSD</b> (Berkeley Software Distribution) de U.C.Berkeley.
			li.fragment IEEE desarrolla una interfaz estándar: <b>POSIX</b>


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p 1987. Andrew Tanenbaum desarrolla una versión simplificada con objetivos educacionales: MINIX

		p.fragment 1991. Linus Torvalds, inspirado en MINIX, escribe su propia versión: <b>LINUX</b>


	section 
		h3 Cuarta Generación (1980-): Computadores Personales

		p LSI (Large Scale Integration) posibilita la construcción de miles de transistores en 1cm2. <span class="fragment">Surgen los computadores personales, o <b>microcomputadores</b></span>

		ul
			li.fragment 1974. Intel 8080. Primera CPU de propósito general de 8-bit. No tiene S.O.
			li.fragment Gary Kildall, consultor, escriben <b>CP/M</b> (Control Program for Microcomputers) en un diskette de 8''.
			li.fragment Intel no se interesa, y entrega CP/M de vuelta a Gary Kildall.
			li.fragment 1977. Gary Kildall funda Digital Research y adapta CP/M para otras CPU.
			li.fragment 1980. IBM crea el IBM PC. Para probarlo obtienen un intérprete BASIC de <span class="fragment">Bill Gates</span>
			li.fragment IBM PC no tiene Sistema Operativo. Bill Gates sugiere que contacten a Gary Kildall
			li.fragment Kildall rechaza a IBM. IBM solicita un Sistema Operativo a Bill Gates.
			li.fragment Bill Gates compra <b>DOS</b> a Seatlle Computer Products, y lo ofrece a IBM.
			li.fragment Bill Gates contrata a Tim Patterson en su nueva compañía, Microsoft, y producen <b>MS-DOS</b>
			li.fragment MS-DOS se populariza al ser ofrecido a empresas de computación y no a usuarios.


	section data-transition="fade"
		h3 Cuarta Generación (1980-): Computadores Personales

		p GUIs atraen a usuarios que no saben (ni les interesa) el funcionamiento del computador.

		ul
			li.fragment 1983. IBM PC/AT, con Intel 80286 y MS-DOS.
			li.fragment MS-DOS ampliamente usado con Intel 80386 y 80486.
			li.fragment Tanto CP/M como MS-DOS usaban una <b>shell</b> (línea de comandos) como interacción.
			li.fragment 1960s. Doug Engelbart inventa las <b>GUI</b> (Graphical User Interface), que empiezan a ser usadas en XEROX PARC.
			li.fragment Steve Jobs conoce la GUI en XEROX PARC y la incorpora su siguiente computador Apple: <span class="fragment">Macintosh</span>


	section data-transition="fade" 
		h3 Cuarta Generación (1980-): Computadores Personales

		p Microsoft adopta GUIs: Windows

		ul
			li.fragment 1985-1995. MS-DOS ejecuta Windows como una aplicación de usuario.
			li.fragment 1995. Windows 95 reemplaza a MS-DOS.
			li.fragment Windows 95 y Windows 98 aún mantienen código assembler Intel 16-bit.
			li.fragment Microsoft reescribe Windows completamente para 32-bit. Windows New Technology: <span class="fragment">Windows NT</span>
			li.fragment 1999. Windows NT 4.0 y Windows 2000 se posicionan en el ámbito corporativo.
			li.fragment Windows Me termina con la línea de Windows 95/98.
			li.fragment 2001. Windows 2000 evoluciona a Windows XP.
			li.fragment Línea server. Windows 2003 Server, Windows 2008.
			li.fragment Línea client. Windows Vista, Windows 7, Windows 8, Windows 10.

	section data-transition="fade" 
		h3 Cuarta Generación (1980-): Computadores Personales

		p Evolución de UNIX

		ul
			li.fragment UNIX popular en ambiente de servidores. 
			li.fragment Linux crece en computadores personales.
			li.fragment <b>FreeBSD</b> deriva de BSD. OSX es una versión modificada de FreeBSD.
			li.fragment MIT produce un sistema de ventanas para UNIX: X Windows System (luego X11).
			li.fragment UNIX adopta GUIs que funcionan sobre X11 (Gnome, KDE, XFCE, etc)
			li.fragment Windows Me termina con la línea de Windows 95/98.


	section 
		h3 Quinta Generación (1980-): Computadores Móviles

		p Evolución de dispositivos móviles

		ul
			li.fragment 1946. Primer teléfono móvil. 40 kg.
			li.fragment 1970. Teléfono móvil de 1 kg. (ladrillo)
			li.fragment 1990s. Nokia N9000 combina teléfono con PDA (Personal Digital Assistant)
			li.fragment Primeros sistemas operativos para móviles: SymbianOS
			li.fragment 2002. RIM. Blackberry OS
			li.fragment 2007. Apple. iOS.
			li.fragment 2008. Google. Android. Basado en Linux.
			li.fragment 2011. Nokia cambia SymbianOS por Windows Phone.


section
	h2 ¿De qué tamaño es un Sistema Oprerativo?
	/  -----------------------------

	section
		p.fragment <a href="http://www.informationisbeautiful.net/visualizations/million-lines-of-code">(¿Megas? ¿Kilos? ¿Gigas?)</a>
		ul
			li.fragment Windows 7: \( \sim 40\times 10^6 \) líneas de código
			li.fragment Linux: \( \sim 15 \times 10^6 \) líneas de código
		

	section
		h3 ¿Qué incluye?
		ul
			li.fragment Sistema Operativo

			blockquote.fragment
				| Sistema Operativo = Kernel + Programas del Sistema

			li.fragment Kernel

			blockquote.fragment
				| Un programa que <strong>siempre</strong> se está ejecutando.
				| <br/>Provee funcionalidad mínima: acceso a CPU, memoria, dispositivos.
			li.fragment Programas del sistema

			blockquote.fragment
				| Extienden las funciones del kernel.



/ section
/ 	h2 ¿Sobre qué <em>hardware</em>?
/ 	/  -----------------------------

/ 	section
/ 		p Distintas arquitecturas
/ 		ul
/ 			div.fragment
/ 				li Single-core
/ 				ul
/ 					li Un procesador de propósito general
/ 					li Algunas funciones delegadas a procesadores especializados
/ 			div.fragment
/ 				li Multi-core
/ 				ul
/ 					li Mayor rendimiento: ¿\(N\)?
/ 					li Economía de escala
/ 					li Mayor confiabilidad (reliability)
/ 			div.fragment
/ 				li Arquitectura en <em>cluster</em>
/ 				ul
/ 					li Múltiples procesadores conectados por red
/ 					li Mayor potencia de cómputo (HPC)
/ 					li Es necesario manejar balance de carga y consistencia de datos
/ 		blockquote.fragment
/ 			| Sistema operativo debe ser capaz de explotar las características de cada arquitectura



section
	h2 ¿Por qué estudiar Sistemas Operativos?
	/  --------------------------------------
	h6
		small
			| (o ¿por qué no?)

	section
		ul
			div.fragment
				li Piezas de software complejas
				ul
					li Años de estudio y evolución
					li ¿Cuántos sistemas operativos distintos manejan?
					li ¿Cuántos sistemas operativos distintos usarán?

			div.fragment
				li Un Sistema Operativo tiene múltiples desafíos:
				ul
					li ¿Cómo proveer sistemas de alto rendimiento?
					li ¿Cómo consumir la menor cantidad de energía?
					li ¿Cómo asegurar que un usuario no altere datos o programas privados?



/ section
/ 	h2 Evolución de Sistemas Operativos
/ 	/  --------------------------------



/ section
/ 	h2 Versión 1.0
/ 	/  -----------

/ 	section
/ 		p Objetivo: acceder transparentemente a <em>hardware</em>
/ 		ul
/ 			div.fragment
/ 				li ¿Cómo?: API para acceder a instrucción de <em>hardware</em> y conjunto de <em>drivers</em> para dispositivos.

/ 			div.fragment
/ 				li Supuestos:
/ 				ul
/ 					li Sólo un usuario accede simultáneamente al computador
/ 					li Ningún usuario/programa hace uso malicioso del <em>hardware</em>

/ 			div.fragment
/ 				li Problemas:
/ 				ul
/ 					li Baja utilización de <em>hardware</em>: CPU inutilizada mientras se accede a disco
/ 					li Usuario debe esperar que un programa termine antes de utilizar otro



/ section
/ 	h2 Versión 2.0
/ 	/  -----------

/ 	section
/ 		p Objetivo: ejecutar múltiples programas simultáneamente. <strong>Multiprogramación</strong>

/ 		ul
/ 			div.fragment
/ 				li ¿Cómo?: Si un proceso se bloquea, ejecutar otro.

/ 			div.fragment
/ 				li Supuestos:
/ 				ul
/ 					li Ningún programa utilizará la CPU demasiado tiempo (programas cooperativos)
/ 					li Ningún programa sobreescribirá datos de otro programa

/ 			div.fragment
/ 				li Métodos:
/ 				ul
/ 					li <em>Preemption</em>: capacidad de <em>expropiar</em> la CPU a un programa
/ 					li <em>Protección de memoria</em>: definir secciones de memoria para cada programa



/ section
/ 	h2 Versión 3.0
/ 	/  -----------

/ 	section
/ 		p Objetivo: que más de un usuario pueda utilizar simultáneamente el computador

/ 		ul
/ 			div.fragment
/ 				li ¿Cómo?: Dándole un tiempo a cada usuario (<em>multitasking</em>)
/ 			div.fragment
/ 				li Problemas:
/ 				ul
/ 					li Cada usuario quiere el mayor tiempo posible: <em>planificación y políticas de uso</em>
/ 					li Cada usuario quiere usar la mayor cantidad de memoria disponible: <em>virtualización de memoria</em>
/ 					li ¿Hasta cuántos usuarios/programas aceptar? (<em>thrashing</em>)

/ 			div.fragment
/ 				li Método: niveles de privilegio
/ 				ul
/ 					li Programas de usuario (aplicaciones) son <em>no privilegiados</em>
/ 					li Programas de <em>kernel</em> son <em>privilegiados</em>
/ 					li Solo programas de <em>kernel</em> pueden modificar el sistema


section
	h2 Conceptos de Sistemas Operativos

	p.fragment <b>Administración de procesos</b>
	ul
		li.fragment Proceso
		li.fragment Tablas (árbol) de proceso
		li.fragment Comunicación entre procesos

	p.fragment <b>Administración de memoria</b>
	ul
		li.fragment Espacios de direcciones
		li.fragment Memoria Virtual


	p.fragment <b>Administración de almacenamiento</b>
	ul
		li.fragment Archivos
		li.fragment Directorios
		li.fragment Rutas absolutas y relativas



section
	h2 ¿Cómo funciona el Sistema Operativo?
	/  ------------------------------------
	
	p El Sistema Operativo está siempre en ejecución <span class="fragment">¿y el usuario?</span>

	blockquote.fragment
		| Los Sistemas Operativos son manejados por <b>interrupciones</b> / <b>traps</b>.

	p.fragment Mientras nadie (usuario/programa) lo llame, el S.O. no hace nada.
	ul
		li.fragment <em>Trap</em>: interrupción generada por software
		ul.fragment
			li Error o solicitud de un programa
			li Por cada solicitud, el S.O. toma una acción

		li.fragment S.O. debe asegurar que errores en un programa no afecten a otro
		ul.fragment
			li ¿Qué pasa si un programa entra en un loop infinito?
			li ¿Si un programa trata de modificar memoria de otro programa? ¿o del S.O.?
			li Habría que asegurar que solo un proceso puede estar en modo ejecutable

		li.fragment Pero el S.O. sí debería poder modificar la memoria de otro programa, para cargarlo/descargarlo



section
	h2 Modos de operación de un Sistema Operativo
	/  ------------------------------------------

	section
		br
		= image_tag "/images/figures/00-1_10.pdf.png", :width=>"60%"

		p Modo dual suportado por hardware: mode bit (0=kernel/1=user)

		p.fragment <strong>Solo puede ser modificado por el S.O.</strong> (¿por qué?)
		p.fragment Kernel mode, a.k.a. (Privileged | Supervised | Monitor | System) mode

		blockquote.fragment
			| Instrucciones privilegiadas solo pueden ejecutar en modo kernel <br/>
			| Si se intenta ejecutar en mode=1, el hardware no la ejecuta y genera una interrupción para el S.O. Evita acceso indebido de otros usuarios

		p.fragment Ej: cambio mode bit, llamada I/O, manejo timer, manejo de interrupciones


	section
		p Multi-modos: Más de dos modos de operación, ¿para qué?

		ul
			li.fragment Útil para virtualización
			li.fragment VMM (<em>Virtual Machine Manager</em>) opera en modo intermedio
			ul.fragment
				li Menos privilegios que S.O.
				li Más privilegios que cada <em>Virtual Machine</em>

		.fragment
			== image_tag "images/figures/00-1_20.pdf.png", :width=>"40%"


	section
		p Programas de usuario hacen llamadas al S.O para que ejecute acciones a nombre de ellos

		ul
			li.fragment <em>syscall</em>, <em>trap</em>

		br
		br
		p.fragment ¿Qué puede pasar si no hay bit mode? (Intel 8088 no lo tenía)
		/ caso de 8088 y MS-DOS. Un proceso en MS-DOS podía echarse el SO

		ul
			li.fragment Mode bit permite protección de hardware
			li.fragment Si un programa comete un acceso indebido o error, trap al S.O.
			/ul
			/	li.fragment S.O. termina el programa <em>abnormally</em>

			li.fragment ¿Cómo evitar que un programa no devuelva el control al SO?
			/ul
			/	li.fragment S.O. usa un timer que genera un trap a intervalo definido
			/	li.fragment Timer también debe ser establecido en modo Kernel




// %section
// %	\frametitle{Protección y Seguridad}
// %
// %	Ante múltiples usuarios, el acceso a datos debe ser regulado
// %
// %	\onslide<2->{Hasta ahora \ldots}
// %	ul
// %		ul.fragment Hardware asegura que procesos solo pueden acceder memoria dentro de su espacio
// %		ul.fragment Timer asegura que ningún proceso se quede sin devolver la CPU
// %		ul.fragment Registros de control de dispositivos no son accesibles por usuarios
// %
// %
// %	\onslide<4->{Sistemas de <strong>protección} controlan el acceso de procesos o usuarios a los recursos computacionales</strong>
// %
// %	ul
// %		ul.fragment Un buen sistema de protección también puede sufrir de accesos indebidos
// %
// %
// %	\onslide<6->{Un sistema de <strong>seguridad} debe defender de ataques externos e internos</strong>


// %section
// %	\frametitle{Protección y Seguridad}
// %
// %	Algunos requisitos de los sistemas de protección y seguridad
// %
// %	ul
// %		ul.fragment Distinción entre usuarios: nombre e identificador (userID, securityID)
// %		ul.fragment Grupos de usuarios e identificadores de grupos
// %		ul.fragment Asociación de privilegios/permisos
// %		ul.fragment Métodos seguros para escalar privilegios (setuid)


section
	h2 Llamadas al sistema
	/  -------------------

	section
		h4 System Calls
		p Programas utilizan llamadas al sistemas frecuentemente
		p Ej: <code>copy source.txt dest.txt</code>... ¿qué requiere?

		ul
			div.fragment
				li Abrir <code>source.txt</code>
				ul
					li ¿Existe? ¿Tiene permisos?

			div.fragment
				li Abrir <code>dest.txt</code>
				ul
					li ¿Existe? ¿se reemplaza? ¿Se puede escribir?

			li.fragment Lectura/escritura en disco requiere llamadas al sistema
			li.fragment Terminar el programa en caso de error, requiere llamadas al sistema

		/p.fragment ...pero el programador no quiere programar todas las llamadas


	section
		h4 API: Application Programming Interface

		p Sistemas Operativos proveen una API para el programador.
		ul
			li.fragment Windows API
			li.fragment POSIX API (UNIX, Linux, MacOS X), a través de <span style="font-family:'Lucida Console', monospace">libc</span>
			li.fragment Java API (para la JVM)

		br
		p.fragment ¿Cómo usarla?
		div.fragment
			p eg:
			pre style="width:50%;"
				code.hljs
					| count = read(fd, buffer, nbytes);

	section
		= image_tag "/images/figures/00-2_06.pdf.png", :style => 'max-width:60%; max-height:60%'

	section
		= image_tag "/images/figures/00-syscall-read.png", :style => 'max-width:60%; max-height:60%'


	section
		= image_tag "/images/figures/00-syscalls-posix.png", :style => 'max-width:50%; max-height:50%'

	section
		= image_tag "/images/figures/00-syscalls-posix-win32.png", :style => 'max-width:50%; max-height:50%'


section
	h2 Elementos y Servicios de un Sistema Operativo
	/  ---------------------------------------------

	section
		p At a glance...

		= image_tag '/images/figures/00-2_01.pdf.png', :width => "80%"



section
	h2 Interfaces de Usuario (UI)
	/  --------------------------

	section
		p Varias alternativas...
		ul
			li.fragment <em>Command-Line Inteface (CLI):</em> Comandos se ingresan por teclado
			li.fragment <em>Batch interface:</em> Comandos se ingresan en archivos
			li.fragment <em>Graphical User Interface (GUI):</em> Sistema de ventanas + <em>pointing-device</em>

	section
		h4 Command-Line (línea de comandos) <span class="fragment">(<strong>shells</strong>)</span>

		p.fragment Para UNIX
		div.fragment
			ul
				li <em>Bourne shell</em>: Stephen Bourne, 1977, UNIX, <code>sh</code>
				li <em>C shell</em>: Bill Joy, 1978, BSD UNIX, <code>csh</code>
				li <em>TENEX C Shell</em>: Ken Greer, 1983, <code>tcsh</code>
				li <em>Korn shell</em>: David Korn, 1983, <code>ksh</code>
				li <em>Bourne-Again shell</em>: Brian Fox, 1989, <code>bash</code>
				li <em>Z shell</em>: Paul Fastad, 1990, <code>zsh</code>

		p.fragment En windows
		div.fragment
			ul
				li <em>MS-DOS prompt</em>: MS-DOS, Win95/98/Me, <code>COMMAND.COM</code>
				li <em>Command Prompt</em>: <code>cmd.exe</code>
				li <em>PowerShell</em>


	section
		h4 Command-Line (línea de comandos)

		p Uso común:
		ul
			li Solicitar comando/instrucción al usuario y ejecutarlo
			li Formato: <code>prompt comando [parametros]</code>

		div.fragment
			p <em>Command Prompt</em> (símbolo del sistema)
			ul
				li.fragment Indica que el sistema está lista para recibir un comando
				li.fragment Usualmente un texto terminado en <code>$, %, #, :, ></code>

		div.fragment
			pre
				code.hljs
					| cruz$ ls
					 
					 jabaier@grima$ cp clase-01.tex backup/
					 
					 jnavon@www[15:35]:> rm tareaSistOp.*
					 
					 dietr1ch@nb ~/SO/Tareas 
					 ls -d */ | parallel --tag 'cd {} && make'


	section
		h4 Graphical User Interface (GUI)

		p Interfaz gráfica (para quienes no les gusta escribir comandos)
		div.fragment
			ul
				li Usualmente con un <em>pointing-device</em> y ventanas
				li Métaforas: escritorio, íconos, carpetas, menúes
				li Más allá de <em>pointing-device</em>: gestos y acciones visuales

		p.fragment Vienen de los \(\sim\) 1970's
		div.fragment
			ul
				li Investigación de Xerox Palo Alto Research Center (PARC)
				li Primera interfaz gráfica: 1973
				li Popularizados en 1980s: Apple Macintosh (Mac OS)
				li Windows 1.0 agregó GUI a MS-DOS


	section
		h4 Graphical User Interface (GUI)

		p Tradicionalmente UNIX/Linux han sido manejados por CLI,
		p.fragment pero se han desarrollado muchas GUIs

		ul
			li.fragment CDE (<em>Common Desktop Environment</em>): Unix, OpenVMS
			li.fragment X-Windows Systems: Xfce, KDE, GNOME (Unix/Linux)
			li.fragment <a href="https://wayland.freedesktop.org/">Wayland</a>: Nueva API de GUI (Linux)

		= image_tag "/images/figures/00-Xwindows.png", :style => "max-width:50%;float:right;"


	section
		= image_tag "/images/figures/00-CDE.png", :style => 'max-width:50%; max-height:50%'
		p CDE (Common Desktop Environment)


	section
		= image_tag "/images/figures/00-XFCE.png", :style => 'max-width:50%; max-height:50%'
		p Xfce


	section
		= image_tag "/images/figures/00-GNOME.png", :style => 'max-width:50%; max-height:50%'
		p GNOME


	section
		= image_tag "/images/figures/00-KDE.png", :style => 'max-width:50%; max-height:50%'
		p KDE (K Desktop Environment)








section
	h2 Estructura: MS-DOS
	/  ------------------

	section
		p ¿Sistemas <strong>monolíticos</strong> o sistemas <strong>modulares</strong>?
		p.fragment Algunos ni siquiera tienen estructura
		ul
			li.fragment MS-DOS: sistema monolítico simple
			li.fragment Nadie pensó que sería tan popular
			li.fragment Intel 8088 no tenía protección de <em>dual mode</em>
			li.fragment ¿Problemas? <span class="fragment">Seguridad</span>

		br
		= image_tag "/images/figures/00-2_11.pdf.png", :style=>"float;right;", :height=>"25%", :width=>"25%"



section
	h2 Estructura: UNIX
	/  ----------------

	section
		p UNIX: Estructura monolítica diseñada de acuerdo al <em>hardware</em>

		= image_tag "/images/figures/00-2_12.pdf.png", :width => '50%'

		p.fragment ¿Problemas? <span class="fragment">Dificultad de mantenimiento</span>



section
	h2 Estructura: diseño por capas
	/  ----------------------------

	section
		p Capas se diseñan por niveles más <em>abstractos</em> de funcionalidad

		ul
			li          Capa \(M\) invoca llamadas sobre capa \(M-1\)
			li.fragment Ventaja: Facilidad de <em>debugging</em>
			li.fragment Desventaja: dificultad de definición de capas, eficiencia


		= image_tag "/images/figures/00-2_13.pdf.png", :width => '25%'


		p.fragment THE (Technische Hogeschool Eindhoven), E. W. Dijkstra (1968) y estudiantes. 6 capas.


section
	h2 Estructura: <em>microkernels</em>
	/  ---------------------------------

	section
		p <b>Mach</b>: versión de UNIX usando diseño de <em>microkernel</em> (CMU)

		ul
			li.fragment Set de funcionalidades mínimas
			li.fragment Otras funcionalidades agregadas como programas de usuario ¿dónde poner el límite?
			li.fragment Ventaja: Sistemas pequeño y fácil de portar
			li.fragment Desventaja: Mucha más interacción a través de <em>syscalls</em>!
			li.fragment <b>Darwin</b> (MacOS X kernel) basado parcialmente en modelo Mach
			li.fragment <b>Windows NT</b> usaba microkernel pero era más lento que Win95.
			li.fragment <b>GNU/Hurd</b> es más lento que Linux.

		= image_tag "/images/figures/00-2_14.pdf.png", :width=>'50%'


section
	h2 Estructura: <i>Monolíticos</i> vs <i>microkernels</i>
	/  ---------------------------------

	section

		= image_tag "/images/figures/00-mono-micro.png", :width=>'100%'



section
	h2 Estructura: <em>módulos</em>
	/  ----------------------------

	section
		p Lo más común: <strong>loadable kernel modules</strong>

		ul
			li Kernel tiene un conjunto de componentes principales (<em>core</em>)
			li Módulos necesarios se agregan durante ejecución
			li Evita recompilar el kernel para cada nueva funcionalidad
			li Solaris, Linux, MacOS X, Windows
			li Ej: kernel con soporte de manejo de archivo + módulos por cada <em>filesystem</em>

		= image_tag "/images/figures/00-2_15.pdf.png", :width=>'50%'



section
	h2 Al final: Estructuras híbridas
	/  ------------------------------

	section
		p En la práctica, pocos sistemas pueden ser encasillados

		ul
			li Linux, Solaris, Windows tienen características monolíticas (performance!)
			li Pero algunas funcionalidades siguen el diseño de <em>microkernel</em>
			li ¡Y además permiten cargar módulos dinámicamente!



// %section
// %	\frametitle{Ejemplo: Apple Mac OS X}
// %
// %	ul
// %		li <strong>Cocoa</strong>: API para Objective-C
// %		li Kernel: Mach microkernel + BSD Unix Kernel
// %		ul
// %			li Mach: manejo de memoria, RPC, IPC, paso de mensajes, <em>threads</em>
// %			li BSD: CLI, networking, sistemas de archivos, API POSIX
// %		li Módulos cargables: <strong>kernel extensions</strong>
// %
// %	== image_tag 'images/figures/00-2_16.pdf.png'



// %section
// %	\frametitle{Ejemplo: Apple iOS}
// %
// %	ul
// %		li <strong>Cocoa Touch</strong> = Cocoa + soporte para gestos
// %		li Media: soporte gráfico + audio + video
// %		li Core: kernel basado en Mac OS X
// %
// %	== image_tag 'images/figures/00-2_17.pdf.png'



// %section
// %	\frametitle{Ejemplo: Android}
// %
// %	ul
// %		li Modelo por capas + kernel Linux
// %		li Implementación de máquina virtual <strong>Dalvik</strong>
// %		li Frameworks para desarrollo: webkit, SQLite, libc
// %
// %	== image_tag 'images/figures/00-2_18.pdf.png'

