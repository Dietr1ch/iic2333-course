---
title: Administración de Memoria
layout: slide
---


section
  h2 Direccionamiento de Memoria

section
  h2 Direccionamiento de Memoria

  section#memory0
    div <b>MEMORIA</b> 
    ul
      li Un gran arreglo de <i>bytes</i>
      li Cada uno con su propia <b>dirección</b>

    div == image_tag '/images/figures/04-memory1.png', :width=>"50%"

    ul.fragment
      li  PC lee instrucciones desde una dirección de memoria
      li  Instrucciones pueden requerir leer operandos desde otra dirección de memoria
      li  Resultados suelen ser almacenados en alguna dirección de memoria

  section#memory1
    div <b>Velocidad</b>
    ul.fragment
      li Registro: acceso en un ciclo de CPU
      li Memoria: requiere acceso al <i>bus de memoria</i>
      li ¿Solución? <span class="fragment">caché</span>

  section#memory2
    div.fragment <b>Protección</b>
    ul.fragment
      li Multiprogramación. Procesos no deben acceder a memoria de otro procesos
      li ¿Si hay dos procesos que hagan referencia a la misma dirección?

    div == image_tag '/images/figures/04-spaces.png', :width=>"35%"
    div.fragment Referencias absolutas

  section#memory3
    div Procesos poseen registros <i>base</i> y <i>limit</i>

    div == image_tag '/images/figures/02-8_01.pdf.png', :width=>"30%"

    ul.fragment
      li ¿S.O. verifica cada acceso? <span class="fragment">leeeento</span>
      li.fragment ¿Solución? <span class="fragment">Verificación por <i>hardware</i></span>

  section#memory4
    div Registros <i>base</i> y <i>limit</i> se cargan, y son verificados por <i>hardware</i>.

    div == image_tag '/images/figures/02-8_02.pdf.png', :width=>"70%"

    div ¿Quién hace esto? <span class="fragment">MMU: <i>Memory Manager Unit</i></span>
    div.fragment Referencias relativas:  <b>JMP 28 + base</b>, en lugar de <b>JMP 28</b>

  section#memory5
    div Procesos piden una dirección de memoria ... <span class="fragment"> pero MMU les entrega otra</span>
    ul.fragment
      li <b>Dirección lógica o virtual</b>: solicitado por el proceso (JMP 28)
      li <b>Dirección física</b>: accedida en la memoría física (JMP 16384+28)

    div == image_tag '/images/figures/04-twoprocs.png', :width=>"25%"

    div.fragment ¿Cuándo se determina la dirección física? (1) Compilación (2) Ejecución (3) Carga

section#spaces0
  h2 Cargando procesos

  section#spaces1
    div Procesos pueden ser cargados y descargados de la memoria

    div == image_tag '/images/figures/02-8_05.pdf.png', :width=>"50%"

  section#spaces2
    div Espacio libre se modifica en cada carga/<i>swap-in</i> o descarga/<i>swap-out</i>

    div == image_tag '/images/figures/04-loadprocs.png', :width=>"70%"

  section#spaces3
    div Direcciones deben ajustarse ante cada carga

    div == image_tag '/images/figures/02-8_06.pdf.png', :width=>"70%"

  section#spaces4
    div <b>¿Dónde ubicar un proceso nuevo?</b>

    div Estrategias
    ul
      li.fragment <strong>First-fit</strong>. En el primer lugar disponible.
      li.fragment <strong>Best-fit</strong>. En el que deja menos espacio libre (el más pequeño posible).
      li.fragment <strong>Worst-fit</strong>. En el que deja más (el más grande).

    div.framgent ¿Cuál es mejor?

  section#spaces5
    div <b>Problema: FRAGMENTACION</b>

    div En dos variedades

    ul
      li.fragment <b>Fragmentación Externa</b>: Hay espacio para otro proceso, pero no contiguo.
      li.fragment <b>Fragmentación Interna</b>: Espacio sobre-asignado a un proceso.

  section#spaces6
    div <b>¿Cómo evitar la fragmentación externa?</b>

    div.fragment <b>Compactación</b>: fusionar huecos
    div.fragment == image_tag '/images/figures/02-fusion.png', :width=>"20%"

    div.framgment ¿Pero?
    ul
      li.fragment Es <b>costoso</b>. No voy esperar que mis 16GB se reacomoden.
      li.fragment ¿Otras soluciones? <span class="fragment">Técnicas de <i>memoria virtuual</i>: <span class="fragment"><b>segmentación</b>, </span><span class="fragment"><b>paginación</b>

section#seg
  h2 Segmentación

  section#seg1
    div Espacio de direcciones se divide en segmentos lógicos
    ul
      li.fragment  Código
      li.fragment  Variables globales
      li.fragment  <em>Heap</em> (para asignación dinámica de memoria)
      li.fragment  <em>Stacks</em> para cada <em>thread</em>
      li.fragment  Código de la librería estándar de C

    div == image_tag '/images/figures/02-8_07.pdf.png', :width=>"20%"


  section#seg2

    div Cada <b>segmento</b> se puede cargar en regiones distintas de memoria.

    div Segmentos poseen: identificador y longitud

    div == image_tag '/images/figures/02-8_07.pdf.png', :width=>"20%"

    div Una dirección de memoria específica en memoria segmentada está formada por una tupla con dos datos (un par):
      $\langle$ <code>numeroDeSegmento</code>, <code>offset</code> $\rangle$

  section#seg3

    div Una dirección lógica es: $\langle$ <code>segmento</code>, <code>offset</code> $\rangle$

    div Información de segmentos cargados se almacena en: <b>Tabla de segmentos</b>

    div == image_tag '/images/figures/02-8_09.pdf.png', :width=>"40%"

  section#seg4

    div Una dirección lógica es: $\langle$ <code>segmento</code>, <code>offset</code> $\rangle$

    div MMU usa la <b>Tabla de segmentos</b> para obtener la <b>dirección física</b>

    div == image_tag '/images/figures/02-8_08.pdf.png', :width=>"50%"





/---------------------------------------------------------------------
/ Frame
  \frametitle{Direccionamiento}
  \framesubtitle{Otros conceptos comunes}
/
  \begin{description}
 //   li.fragment [<strong>Carga dinámica</strong>] Cargar sólo parte del proceso. Cuando una rutina se necesita,
                                se carga la sección necesaria de código.
 //   li.fragment [<strong>Bibliotecas</strong>] Conjunto de rutinas de uso común que se <em>agregan</em> al programa
      ul
        li.fragment  <strong>Enlace Estático</strong> (<code>.lib</code>, <code>.a</code>). Rutinas se enlazan dentro del binario final.
            ul
              li.fragment  +Rápido
              li.fragment  -Binario de mayor tamaño
              li.fragment  Modificación requiere re-compilación
            
        li.fragment  <strong>Enlace Dinámico</strong> (<code>.dll</code>, <code>.so</code>). Rutinas se enlazan con un <em>stub</em>: 
                              código representante de la rutina. Rutina se carga al llamarla.
            ul
              li.fragment  -Lento, pero sólo al primer acceso
              li.fragment  +Binario más pequeño
              li.fragment  Pueden reemplazarse <em>en caliente</em> (con un esquema de versiones)
            
                              
  /    
  //\end{description}
  
/

/---------------------------------------------------------------------
/\subsection{Paginación}

/ Frame
  \frametitle{Paginación}

/  Dos divisiones en unidades de tamaño fijo:
  ul
    li.fragment  Memoria física se divide en <strong>frames</strong> (marcos)
    li.fragment  Memoria lógica se divide en <strong>páginas</strong>
  
  
  Memoria se carga en trozos de tamaño fijo
  
  ul
    li.fragment  Permite separar el espacio de direcciones lógico ($\mathcal{L}$) del espacio de direcciones físico ($\mathcal{F}$).
    li.fragment  Permite que $|\mathcal{L}| > |\mathcal{F}|$
      ul
        li.fragment  No es menor. Sistema con $2^{32}$ (4G) direcciones de memoria física
              puede albergar procesos con direcciones de 64-bit.
      
  
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Paginación}

/  Dirección de memoria paginada contiene:
  \begin{center}
    $\langle$ <code>numeroDePagina</code>, <code>offset</code> $\rangle$
  \end{center}

/  \begin{center}
    \includegraphics[width=9cm]{figs/02-8_10.pdf}
  \end{center}


 
/---------------------------------------------------------------------
/ Frame
  \frametitle{Ejemplo de Paginación}

/  \begin{center}
    \includegraphics[width=8cm]{figs/02-8_11.pdf}
  \end{center}
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Tamaños de páginas y frames}

/  ul
    li.fragment  Tamaño de páginas y frames determinado por <em>hardware</em>
    li.fragment  Típicamente potencia de 2. Entre 512 bytes a 1GB por página.
    li.fragment  ¿Por qué potencia de 2? &hellip; Hace todo más fácil
      ul
        li.fragment  Transformación se hace reemplazando bits de la dirección lógica
        li.fragment  No requiere operaciones adicionales
      
  
  Ejemplo:
  ul
    li.fragment  Direcciones lógicas de $m$-bit
    li.fragment  Tamaño de página de $2^n$ bytes
      \begin{center}
        \includegraphics[width=7cm]{figs/02-in-8_1.pdf}
      \end{center}
  
  

/---------------------------------------------------------------------
/ Frame
  \frametitle{Ejemplo de paginación}

/  Páginas de $2^n$ bytes, $n=2$. Direcciones lógicas de $m$-bit, $m=4$.
  
  Memoria física de 32 bytes == 8 páginas.
  
  \begin{center}
    \includegraphics[width=5.2cm]{figs/02-8_12.pdf}
  \end{center}


/---------------------------------------------------------------------
/ Frame
  \frametitle{Límites de la paginación}

/  ul
    li.fragment  ¿Fragmentación externa? \onslide<2->{&hellip; ¡0!}
    li.fragment <2-> Se produce fragmentación interna
      ul
        li.fragment  Páginas de 4KB.
        li.fragment <3-> Si el proceso necesita $20\times 4\text{KB} + 512\text{B}$,
              se asignan 21 páginas.
        li.fragment <4-> Se pierden $4096 - 512 = 3584$ bytes
        li.fragment <5-> Peor caso: solicitud de $N$ páginas más $1$ byte 
                  asigna $N+1$ páginas.
      
  
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Tamaño de la tabla de páginas}

/  Ejemplo: DEC PDP-11. Máquina de 16-bit, $1970\sim 1990$

/  \includegraphics[width=5cm]{figs/02-PDP-11-70-DDS570.png}
  \hfill
  \includegraphics[width=5cm]{figs/02-Pdp-11-70-panel.png}
  
  Páginas de 8KB. ¿Tamaño de la tabla de páginas?
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Tamaño de la tabla de páginas}

/ Otro ejemplo: 32-bit. Páginas de 4KB.

/  ¿Tamaño de la tabla de páginas?  
  \onslide<2->{¡$2^{20}$ entradas!}
  ul
    li.fragment  <3->{Accesos pueden hacerse lentos}
    li.fragment  <4->{¿Solución? Otro tipo de <em>caché</em>}
  
  
  \onslide<5->{
  <strong>Translation Look-aside Buffer</strong> (TLB)
  ul
    li.fragment  Subconjunto de tabla de páginas en registro de rápido acceso
    li.fragment  Entre 32 a 1024 entradas
  
  }


/---------------------------------------------------------------------
/ Frame
  \frametitle{<em>Translation Look-aside Buffer</em>}

/  \begin{center}
    \includegraphics[width=9cm]{figs/02-8_14.pdf}
  \end{center}



/---------------------------------------------------------------------
/\subsection{Tablas de Páginas}

/ Frame
  \frametitle{Tablas de Páginas}

/  Tablas de páginas pueden implementarse de distintas maneras
  
  \onslide<2->{Tamaños comunes:}
  ul
    li.fragment <3-> Direcciones lógicas de 32-bit. \onslide<4->{$2^{32}=4G$ direcciones}
    li.fragment <5-> Páginas de $4\text{KB}=2^{12}$
    li.fragment <6-> Tabla puede tener hasta $2^{20}$ entradas. 
    li.fragment <7-> Si cada entrada ocupa 4 bytes, la tabla de páginas ocupa $4\text{MB}$
    li.fragment <8-> ¡La tabla de páginas no cabe en una página!
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Tablas de Páginas Jerárquicas}

/  Ejemplo: esquema de dos niveles

/  \begin{center}
    \includegraphics[width=6cm]{figs/02-8_17.pdf}
  \end{center}
  
  

/---------------------------------------------------------------------
/ Frame
  \frametitle{Tablas de Páginas Jerárquicas}

/  Direccionamiento de dos niveles

/  \begin{center}
    \includegraphics[width=9cm]{figs/02-8_18.pdf}
  \end{center}
  
  \begin{center}
    \includegraphics[width=6cm]{figs/02-in-8_2.pdf}
  \end{center}
  



/---------------------------------------------------------------------
/ Frame
  \frametitle{Tablas de Páginas Jerárquicas}

/  ¿Cuántos niveles? 
  
/  Ejemplo: Direcciones de 64-bit

/  \begin{center}
    \includegraphics[width=6cm]{figs/02-in-8_4.pdf}
  \end{center}

/  \onslide<2->{Otro nivel de paginación &hellip;}
  
  \onslide<3->{
  \begin{center}
    \includegraphics[width=6cm]{figs/02-in-8_5.pdf}
  \end{center}  
  }

/  \onslide<4->{64-bit UltraSPARC poseía 7 niveles de paginación}
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Tablas de Páginas con <em>hash</em>}

/  \begin{center}
    \includegraphics[width=9cm]{figs/02-8_19.pdf}
  \end{center}

/  Apropiadas para espacios de direcciones <em>sparse</em> (ralos)



/---------------------------------------------------------------------
/ Frame
  \frametitle{Tablas de Páginas invertidas}

/  ul
    li.fragment  Una entrada por frame (en lugar de página)
    li.fragment  Sólo una tabla en el sistema (no por proceso)
  

/  \begin{center}
    \includegraphics[width=8cm]{figs/02-8_20.pdf}
  \end{center}

/  Usada en 64-bit UltraSPARC, y PowerPC


/---------------------------------------------------------------------
/\section{Memoria Virtual}

/\subsection{Funcionamiento}

/ Frame
  \frametitle{Funcionamiento}

/  Estrategias de direccionamiento
  
  ul
    li.fragment  Orientadas a dar ilusión de que todo el programa se encuentra en memoria contínua
    li.fragment  Pero &hellip; aún se necesita al programa completo cargado en memoria
    li.fragment  ¿Y la carga dinámica?
      ul
        li.fragment  Hace la carga más rápida, pero una vez cargado debe seguir en memoria
        li.fragment  A menos que se haga <em>swap</em>
      
  

/  \onslide<2->{
  Pero mantener todo el programa en memoria es muy restrictivo
  }
  ul
    li.fragment <3-> No todas las partes del código se requieren simultáneamente
    li.fragment <3-> Un proceso que solicita más memoria que la memoria física disponible no podría cargarse
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Funcionamiento}

/  <strong>Memoria Virtual</strong> aumenta la separación entre la memoria visible por el programador,
  y la memoria física de la máquina en que se ejecuta el programa.
  
  \begin{center}
    \includegraphics[width=8cm]{figs/02-9_01.pdf}
  \end{center}



/---------------------------------------------------------------------
/ Frame
/  \frametitle{Funcionamiento}
/
/  Bibliotecas compartidas se asigna a <em>frames</em> ya cargados
/  
/  \begin{center}
/    \includegraphics[width=8cm]{figs/02-9_03.pdf}
/  \end{center}
/
/
/---------------------------------------------------------------------
/\subsection{Paginación por demanda}

/ Frame
  \frametitle{Paginación por demanda}

/  Primera etapa: mantener registro de páginas cargadas
  ul
    li.fragment  Bit adicional en tabla de páginas
      ul
        li.fragment  <em>Valid</em>: Página en memoria
        li.fragment  <em>Invalid</em>: Página almacenada en disco, pero no en memoria
      
    li.fragment  Al detectar un acceso a una página <em>inválida</em>, ésta se carga dinámicamente
          y se establece el bit a <em>valid</em>
  

/  \begin{center}
    \includegraphics[width=5cm]{figs/02-9_05.pdf}
  \end{center}
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Paginación por demanda}

/  Segunda etapa: cargar páginas que se necesiten
  
  ul
    li.fragment  Proceso de carga se activa ante un <strong>page-fault</strong>
  

/  \begin{center}
    \includegraphics[width=6cm]{figs/02-9_06.pdf}
  \end{center}

  ul
    li.fragment  Proceso podría empezar con una única página en memoria: <strong>paginación por demanda pura</strong>
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Paginación por demanda}

/  Rendimiento de la paginación por demanda
  ul
    li.fragment  $p$, probabilidad de <em>page fault</em>
    li.fragment  $t_{ma}$, tiempo de acceso a memoria, $\sim 200 \times 10^{-9}s$
    li.fragment  $t_{pf}$, tiempo generado por <em>page fault</em>
  
  
  \onslide<2->{
  Tiempo efectivo de acceso a memoria, $t_e$
  \[ t_e = (1-p) \times t_{ma} + p \times t_{pf} \]
  }
  
  \onslide<3->{
  Con $t_{pf} = 8 \text{ms}$:
  \[ t_{e} = 200 + 7999800 p \]
  }
  
  \onslide<4->{  
  Si queremos que la degradación no sea mayor a $10\%$:
  \[ 220 > 200 + 7999800p \Rightarrow p < 0.0000025 \]
  }

/---------------------------------------------------------------------
/\subsection{<em>Copy-on-Write</em>}

/ Frame
  \frametitle{<em>Copy-on-Write</em>}

/  Al hacer un <code>fork()</code> se <em>copia</em> la memoria del padre al hijo.
  
  ul
    li.fragment  ¿Y si el hijo no escribe en su memoria?
    li.fragment  ¿Y si el hijo hace inmediatemente <code>exec()</code>?
  
  
  Estrategia <strong>copy-on-write</strong> mantiene las páginas del padre como
  <em>región compartida para el hijo</em>
  
  \begin{center}
    \includegraphics[width=5.5cm]{figs/02-9_07.pdf}
    \,\,\,\,\,\,
    \includegraphics[width=5.5cm]{figs/02-9_08.pdf}
  \end{center}

/  Instrucción <code>vfork()</code> implementa <code>fork</code> sin copia de páginas (ni con <em>copy-on-write</em>)
  


/---------------------------------------------------------------------
/\subsection{Reemplazo de páginas}

/ Frame
  \frametitle{Reemplazo de páginas}

/  Si sólo se carga la mitad de la memoria de un proceso, podemos cargar
  más en memoria $\to$ más multiprogramación

/  Si no hay más espacio en memoria, se debe pasar a <em>swap</em> una de las páginas
  actualmente asignadas.

/  \begin{center}
    \includegraphics[width=7cm]{figs/02-9_09.pdf}
  \end{center}
  
  



/---------------------------------------------------------------------
/ Frame
  \frametitle{Reemplazo de páginas}

/  Sistema Operativo necesita <strong>reemplazar</strong> una página existente,
  hacer <em>swap</em> y cargar otra

/  \begin{center}
    \includegraphics[width=7cm]{figs/02-9_10.pdf}
  \end{center}

/  Algoritmos para elegir una página <em>víctima</em>  
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Reemplazo de páginas}

/  \begin{center}
    \includegraphics[width=6cm]{figs/02-9_10.pdf}
  \end{center}

/  Dos transferencias de páginas (pasos 1 y 3)
  ul
    li.fragment  Páginas que no han sido modificadas no necesitan escribirse
          a disco
    li.fragment  <strong>Modify bit</strong> o <strong>Dirty bit</strong> indican si la página ha sido modificada
          desde la última vez que se cargó
    li.fragment  Páginas <em>read-only</em> nunca modifican su <strong>dirty bit</strong>
  



/---------------------------------------------------------------------
/ Frame
  \frametitle{Reemplazo de páginas}

/  Algoritmos para decidir <em>qué página reemplazar</em>
  ul
    li.fragment  ¿Cuál es mejor?
    li.fragment  Uno que genere pocos <em>page faults</em>
  
  
  Comparables usando una misma secuencia de acceso a memoria
  ul
    li.fragment  Ej: Con esta secuencia de accesos a memoria
      ul
        li.fragment  0145, 0400, 0102, 0670, 0110, 0672, 0112, 0198, 0153, 0602, 0170
      
    li.fragment  Y con páginas que almacenen 100 direcciones, la secuencia de acceso es:
      ul
        li.fragment  1,4,1,6,1,6,1,6,1
      
  



/---------------------------------------------------------------------
/ Frame
  \frametitle{Reemplazo de páginas}

/  \begin{center}
    \includegraphics[width=6cm]{figs/02-9_11.pdf}
  \end{center}
  
  Tasa de <em>page faults</em> también depende de la cantidad de <em>frame</em> disponibles
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Reemplazo FIFO}

/  \begin{block}{<strong>FIFO</strong>}
    Reemplazar la página que fue cargada hace más tiempo
  \end{block}

/  \begin{center}
    \includegraphics[width=10cm]{figs/02-9_12.pdf}
  \end{center}

/  Se reemplaza la página más antigua en haber sido cargada
  ul
    li.fragment  +Fácil de implementar
    li.fragment  -Compartamiento impredecible
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Reemplazo FIFO}

/  Aumentar la cantidad de <em>frames</em> debe disminuir la cantidad de <em>page faults</em>
  
  ul
    li.fragment  Ejemplo. Secuencia 1,2,3,4,1,2,5,1,2,3,4,5
    li.fragment  Con 3 frames genera 9 <em>page faults</em>
    li.fragment  Con 4 frames genera 10 <em>page faults</em> (¿?)
  
  
  \begin{center}
    \includegraphics[width=5.5cm]{figs/02-9_13.pdf}
  \end{center}

/  Este problema se conoce como <strong>anomalía de Bélády</strong>\footnote{Planteada por el húngaro László Bélády, 1969} 



/---------------------------------------------------------------------
/ Frame
  \frametitle{Reemplazo Óptimo}

/  \begin{block}{<strong>OPT</strong> ó <strong>MIN</strong>}
    Reemplazar la página que no será usada por mayor tiempo
  \end{block}

/  No sufre la anomalía de Bélády.

/  \begin{center}
    \includegraphics[width=8cm]{figs/02-9_14.pdf}
  \end{center}

/  ul
    li.fragment  +Óptimo
    li.fragment  -Difícil de implementar, pues requiere conocimiento futuro (como SJF)
  


/---------------------------------------------------------------------
/ Frame
  \frametitle{Reemplazo LRU (<em>Least Recently Used</em>)}
  \framesubtitle{Si no puedes obtener el óptimo, aproxímalo}

/  \begin{block}{<strong>LRU</strong>}
    Reemplazar la página que no ha sido usada por más tiempo
  \end{block}
  
  \begin{center}
    \includegraphics[width=8cm]{figs/02-9_15.pdf}
  \end{center}

/  Parece un buen compromiso. ¿Cómo implementarlo?
  ul
    li.fragment  Contadores, actualizado con valor de <em>timer</em>
    li.fragment  <em>Stack</em>, el último acceso avanza al tope del <em>stack</em>
  

/  En cualquier caso se requiere ayuda de <em>hardware</em>

/---------------------------------------------------------------------
/ Frame
  \frametitle{Aproximación a LRU}

/  Si no hay soporte de <em>hardware</em>, se puede aproximar el comportamiento de LRU
  
  ul
    li.fragment  <strong>Reference bit</strong> se marca para indicar páginas referenciadas
    li.fragment  Permite determinar qué páginas se han usado y cuáles no (sin orden)
  

/  Una técnica para incorporar orden:
  ul
    li.fragment  8-bit reference (<em>reference byte</em>) funcionan como ``bit de historia''
    li.fragment  A intervalo $r$ ($\sim 100$ms) se hace <em>right shift</em>
          del <em>reference bit</em>
    li.fragment  Frame con mayor <em>reference byte</em> es el usado más recientemente    
  
  
  Valores pueden no ser únicos. Entre ellos se decide de manera FIFO.
  

/---------------------------------------------------------------------
/ Frame
  \frametitle{Aproximación a LRU: Algoritmo de segunda oportunidad}
  \framesubtitle{Otra oportunidad, otra oportunidad, &hellip;}

/  Inicialmente, algoritmo FIFO, ordenado por tiempo de carga
  ul
    li.fragment  Al ser elegida, se observa su <em>reference bit</em>
      ul
        li.fragment  Reference bit 0: se reemplaza
        li.fragment  Reference bit 1: 2da oportunidad. Se cambia a 0, se establece tiempo de carga al tiempo actual, 
              y se pasa a la siguiente página
      
  

/  \begin{center}
    \includegraphics[width=4cm]{figs/02-9_17.pdf}
  \end{center}
  
  ¿Qué pasa si todos los bit están marcados como 1?


/---------------------------------------------------------------------
/ Frame
  \frametitle{Aproximación a LRU: Segunda oportunidad mejorada}

/  2da oportunidad considerando el par (<em>reference bit</em>, <em>dirty bit</em>)
  
  ul
    li.fragment  (0,0), no usado recientemente ni modificada
      ul
        li.fragment  Buena víctima
      
    li.fragment  (0,1), no usada recientemente, pero modificada
      ul
        li.fragment  Casi buena víctima. Requiere escribirla.
      
    li.fragment  (1,0), recientemente usada, pero no modificada
      ul
        li.fragment  Probablemente será leída pronto
      
    li.fragment  (1,1), recienemente usada, y modificada
      ul
        li.fragment  Probablemente será leída pronto
      
  



/---------------------------------------------------------------------
/ Frame
  \frametitle{Otros algoritmos}
  
  Con contador de accesos (costoso de implementar)
  ul
    li.fragment  <strong>Least Frequently Used</strong>. Una página muy accedida debe tener alto contador.
       ul
         li.fragment  ¿Y si se usó solo al inicio?
         li.fragment  Se puede complementar haciendo <em>shift</em> del contador periæodicamente
       
    li.fragment  <strong>Most Frequently Used</strong>. La página que tiene pocos accesos probablemente fue cargada recientemente
          y aún no ha sido muy usada
  


/---------------------------------------------------------------------
/\subsection{Asignación de <em>Frames</em> y <em>Thrashing</em>}

/ Frame
  \frametitle{Asignación de <em>Frames</em>}

/  La pregunta: ¿cuántos <em>frames</em> asignar a cada proceso?
  
  <strong>Mínimo</strong>
  ul
    li.fragment  Puede ser definido por la arquitectura
    li.fragment  O bien, depender de la cantidad de direcciones referenciables en una instrucción
      ul
        li.fragment  <code>load r1, 0x0160</code>. Dos frames: para la instrucción y para la dirección.
        li.fragment  Más complejo cuando se permiten indirecciones
  
  <strong>Máximo</strong>
  ul
    li.fragment  ¿Cómo dividir $m$ <em>frames</em> entre $n$ procesos?
  



/---------------------------------------------------------------------
/ Frame
  \frametitle{Asignación de <em>Frames</em>}

/  $m$ <em>frames</em> y $n$ procesos
  ul
    li.fragment  <strong>Asignación equitativa</strong>: $\lfloor m/n \rfloor$ a cada uno. 
    li.fragment  <strong>Asignación proporcional</strong>: sea $s_i$ el tamaño de la memoria virtual del proceso $p_i$,
          cada proceso recibe $a_i$ <em>frames</em>: 
          \[ a_i = \frac{s_i}{\sum{s_i}} \times m \]
          Proporción también puede estar relacionada a la prioridad del proceso
          
  



/---------------------------------------------------------------------
/ Frame
  \frametitle{<em>Thrashing</em>}

/  Cada <em>page fault</em> genera tráfico entre disco y memoria de <em>al menos</em> una página.
  
  \vspace{1em}

/  \onslide<2->{Con alta tasa de <em>page fault</em> el sistema gasta más tiempo copiando <em>frames</em>
               entre disco y memoria}
  \vspace{1em}        

/  \onslide<3->{Se produce <strong>thrashing</strong>}


/---------------------------------------------------------------------
/ Frame
  \frametitle{<em>Thrashing</em>}

/  \begin{center}
    \includegraphics[width=6cm]{figs/02-9_18.pdf}
  \end{center}

/  ul
    li.fragment  Baja utilización de CPU
    li.fragment  <em>Scheduler</em> incrementa nivel de multiprogramación
    li.fragment  Procesos nuevos requieren <em>frames</em>.
    li.fragment  S.O. quita <em>frames</em> a procesos en ejecución
    li.fragment  Procesos en ejecución aumentan su tasa de <em>page fault</em>
    li.fragment  S.O. gasta más tiempo cargando <em>frames</em>
    li.fragment  Baja utilización de CPU
  



/---------------------------------------------------------------------
/ Frame
  \frametitle{Localidad de referencia}

/  Estrategia para evitar <em>thrashing</em>: aprovechar la <strong>localidad de referencia</strong>
  
  ul
    li.fragment  Teoría: procesos saltan de una localidad a otra
    li.fragment  Referencias se dan principalmente en una localidad de memoria y,
          con baja frecuencia, saltan a otro localidad
  
  
  \begin{center}
    \includegraphics[width=4cm]{figs/02-9_19.pdf}
  \end{center}




/---------------------------------------------------------------------
/ Frame
  \frametitle{Modelo de <em>Working Set</em>}

/  \begin{block}<strong>Working Set</strong>
    Conjunto de páginas usadas en los últimos $\Delta$ accesos
  \end{block}

/  \begin{center}
    \includegraphics[width=9cm]{figs/02-9_20.pdf}
  \end{center}

/  $\Delta$ determina el tamaño del <em>working set</em> del proceso $i$: $\text{WSS}_i$
  
  \vspace{1em}
  
  Demanda por páginas: $D=\sum{\text{WSS}_i}$
  
  \vspace{1em}
  
  Si hay $m$ frames, y $D > m$, entonces habrá <em>thrashing</em>



/---------------------------------------------------------------------
/ Frame
  \frametitle{Modelo de <em>Working Set</em>}
  \framesubtitle{¿Cómo implementarlo?}

/  Aprovechar los <em>reference bit</em>
  
  ul
    li.fragment  Observar <em>reference bit</em> a intervalos regulares, cada $R$ referencias
    li.fragment  <em>Reference bit</em> se copian y se borran
    li.fragment  En la siguiente observación se comparan los valores copiados
          y los nuevos <em>reference bit</em>.
    li.fragment  Páginas modificadas se mantienen dentro del <em>working set</em>
  
  Permite aproximar el <em>working set</em>, a menor costo que analizar todas las referencias


/---------------------------------------------------------------------

/ Frame
  \frametitle{Resumen}

/  ul
    li.fragment  Direccionamiento de memoria
      ul
        li.fragment  Transformaciones de dirección lógica a física
        li.fragment  Tipos de asignacioens: contigua, segmentada, paginada
      
    li.fragment  Memoria Virtual
      ul
        li.fragment  Permite direccionar más memoria que la memoria física disponible
        li.fragment  Páginas se asignan a <em>frames</em> en la medida que se necesiten
        li.fragment  Si no hay <em>frames</em> disponibles se debe reemplazar alguna página
        li.fragment  Reemplaza FIFO, OPT, LRU
        li.fragment  Cantidad de <em>frames</em> asignados a cada proceso debe ser el apropiado,
              de lo contrario se puede producir <em>thrashing</em>
