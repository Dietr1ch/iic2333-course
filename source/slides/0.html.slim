---
title: Caracterización de un Sistema Operativo
layout: slide
---



section
	h2 Estructura de un Sistema Operativo
	/  ----------------------------------

// section
//	 \frametitle{El Sistema Operativo en un Sistema Computacional}
//	 \framesubtitle{<em>Software}</em>

//	 \begin{center}
//		 \includegraphics[width=9cm]{figs/00-ComponentesSistComp.png}
//	 \end{center}



section
	h2 ¿Qué hace un Sistema Operativo?
	/  -------------------------------

	section
		p.fragment No hace mucho por sí mismo (es como el gobierno)
		ul
			li.fragment Y a la vez es fundamental
			li.fragment Sería inútil sin programas/aplicaciones/usuarios (personas)


	section
		h3 Un Sistema Operativo tiene múltiples roles
		ul
			li.fragment Para el usuario
			ul
				li.fragment Le permite <strong>utilizar los recursos</strong> del computador
				li.fragment Ejecutar programas, leer archivos, efectuar cálculos... <span class="fragment"> de manera fácil y rápida</span>
			li.fragment Para el sistema computacional:
			ul
				li.fragment Un <strong>administrador de recursos</strong>
				ul
					li.fragment Selecciona y provee los recursos necesarios
					li.fragment Permite que se usen de manera eficiente
					li.fragment ¿Qué es <em>eficiente</em> para: mainframe, virtual manager, sistema móvil?
				li.fragment Un <strong>programa de control</strong>... <span class="fragment">que evita el uso indebido</span>
				ul
					li.fragment No "botar" otros programas en ejecución
					li.fragment No sobreescribir por error el sistema operativo
					li.fragment Evitar que un usuario se apropie del sistema



section
	h2 ¿Qué es un Sistema Operativo?
	/  -----------------------------

	section
		p ¿Qué incluye?
		ul
			li.fragment ¿Interfaz gráfica?
			li.fragment ¿Editores?
			li.fragment ¿Línea de comando?
		p.fragment ¿De qué tamaño es? <a href="http://www.informationisbeautiful.net/visualizations/million-lines-of-code">(¿Megas? ¿Kilos? ¿Gigas?)</a>
		ul
			li.fragment Windows 7: \( \sim 40\times 10^6 \) líneas de código
			li.fragment Linux: \( \sim 15 \times 10^6 \) líneas de código
		p.fragment Entonces, el S.O. es "lo que hay" disponible
		ul
			li.fragment Lo que obtenemos de Microsoft/Apple
			li.fragment Lo que bajamos de Linux


	section
		p Lo comúnmente aceptado:
		ul
			li.fragment Sistema Operativo

			blockquote.fragment
				| Sistema Operativo = Kernel + Programas del Sistema

			li.fragment Kernel

			blockquote.fragment
				| Un programa que <strong>siempre</strong> se está ejecutando.
				| <br/>Provee funcionalidad mínima: acceso a CPU, memoria, dispositivos.
			li.fragment Programas del sistema

			blockquote.fragment
				| Extienden las funciones del kernel.



section
	h2 ¿Sobre qué <em>hardware</em>?
	/  -----------------------------

	section
		p Distintas arquitecturas
		ul
			div.fragment
				li Single-core
				ul
					li Un procesador de propósito general
					li Algunas funciones delegadas a procesadores especializados
			div.fragment
				li Multi-core
				ul
					li Mayor rendimiento: ¿\(N\)?
					li Economía de escala
					li Mayor confiabilidad (reliability)
			div.fragment
				li Arquitectura en <em>cluster</em>
				ul
					li Múltiples procesadores conectados por red
					li Mayor potencia de cómputo (HPC)
					li Es necesario manejar balance de carga y consistencia de datos
		blockquote.fragment
			| Sistema operativo debe ser capaz de explotar las características de cada arquitectura



section
	h2 ¿Por qué estudiar Sistemas Operativos?
	/  --------------------------------------
	h6
		small
			| (o ¿por qué no?)

	section
		ul
			div.fragment
				li Piezas de software complejas
				ul
					li Años de estudio y evolución
					li ¿Cuántos sistemas operativos distintos manejan?
					li ¿Cuántos sistemas operativos distintos usarán?

			div.fragment
				li Un Sistema Operativo tiene múltiples desafíos:
				ul
					li ¿Cómo proveer sistemas de alto rendimiento?
					li ¿Cómo consumir la menor cantidad de energía?
					li ¿Cómo asegurar que un usuario no altere datos o programas privados?



section
	h2 Evolución de Sistemas Operativos
	/  --------------------------------



section
	h2 Versión 1.0
	/  -----------

	section
		p Objetivo: acceder transparentemente a <em>hardware</em>
		ul
			div.fragment
				li ¿Cómo?: API para acceder a instrucción de <em>hardware</em> y conjunto de <em>drivers</em> para dispositivos.

			div.fragment
				li Supuestos:
				ul
					li Sólo un usuario accede simultáneamente al computador
					li Ningún usuario/programa hace uso malicioso del <em>hardware</em>

			div.fragment
				li Problemas:
				ul
					li Baja utilización de <em>hardware</em>: CPU inutilizada mientras se accede a disco
					li Usuario debe esperar que un programa termine antes de utilizar otro



section
	h2 Versión 2.0
	/  -----------

	section
		p Objetivo: ejecutar múltiples programas simultáneamente. <strong>Multiprogramación</strong>

		ul
			div.fragment
				li ¿Cómo?: Si un proceso se bloquea, ejecutar otro.

			div.fragment
				li Supuestos:
				ul
					li Ningún programa utilizará la CPU demasiado tiempo (programas cooperativos)
					li Ningún programa sobreescribirá datos de otro programa

			div.fragment
				li Métodos:
				ul
					li <em>Preemption</em>: capacidad de <em>expropiar</em> la CPU a un programa
					li <em>Protección de memoria</em>: definir secciones de memoria para cada programa



section
	h2 Versión 3.0
	/  -----------

	section
		p Objetivo: que más de un usuario pueda utilizar simultáneamente el computador

		ul
			div.fragment
				li ¿Cómo?: Dándole un tiempo a cada usuario (<em>multitasking</em>)
			div.fragment
				li Problemas:
				ul
					li Cada usuario quiere el mayor tiempo posible: <em>planificación y políticas de uso</em>
					li Cada usuario quiere usar la mayor cantidad de memoria disponible: <em>virtualización de memoria</em>
					li ¿Hasta cuántos usuarios/programas aceptar? (<em>thrashing</em>)

			div.fragment
				li Método: niveles de privilegio
				ul
					li Programas de usuario (aplicaciones) son <em>no privilegiados</em>
					li Programas de <em>kernel</em> son <em>privilegiados</em>
					li Solo programas de <em>kernel</em> pueden modificar el sistema



/ %!
/ %section
	/ % h2 ¿Qué se le pide a un Sistema Operativo?
	/ % explicarlos de manera natural

// %	ul
// %		ul.fragment Capacidad de ejecutar <strong>procesos</strong> definidos por el usuario
// %		ul.fragment Capacidad de <strong>multiprogramación</strong>
// %			ul
// %				ul.fragment Múltiples procesos en memoria (¿y si no caben?)
// %				ul.fragment Mover algunos a disco (¿cuáles?)
// %				ul.fragment Mantener siempre uno en ejecución (¿cuál?)
// %				ul.fragment Debe hacer planificación: <strong>job+CPU scheduling</strong>
// %				%li Ejemplo vida real
// %
// %		ul.fragment Capacidad de <strong>time-sharing} o {\bf multitasking</strong>
// %			ul
// %				ul.fragment Cambio frecuentes entre programas
// %				ul.fragment Permite que múltiples usuarios utilicen el sistema
// %				ul.fragment Permite aplicaciones interactivas
// %
// %		ul.fragment Capacidad de administrar la <strong>memoria</strong> del sistema
// %			ul
// %				ul.fragment Cada proceso requiere memoria, pero ésta es limitada
// %				ul.fragment Swapping ... \onslide<13-> memoria virtual
// %
// %		ul.fragment Capacidad de utilizar <strong>almacenamiento no-volátil</strong>
// %
// %



section
	h2 ¿Cómo funciona el Sistema Operativo?
	/  ------------------------------------
	/ explicarlos de manera natural

	blockquote
		| Si está siempre ejecutando, ¿cuándo le toca al usuario?
		| <br/><span class="fragment">Los Sistemas Operativos son manejados por <em>interrupciones</em> / <em>traps.</em></span>

	p.fragment Mientras nadie (usuario/programa) lo llame, el S.O. no hace nada.
	ul
		li.fragment <em>Trap</em>: interrupción generada por software
		ul
			li.fragment Error o solicitud de un programa
			li.fragment Por cada solicitud, el S.O. toma una acción

		li.fragment S.O. debe asegurar que errores en un programa no afecten a otro
		ul
			li.fragment ¿Qué pasa si un programa entra en un loop infinito?
			li.fragment ¿Si un programa trata de modificar memoria de otro programa? ¿o del S.O.?
			li.fragment Habría que asegurar que solo un proceso puede estar en modo ejecutable

		li.fragment Pero el S.O. sí debería poder modificar la memoria de otro programa, para cargarlo/descargarlo



section
	h2 Modos de operación de un Sistema Operativo
	/  ------------------------------------------

	section
		br
		br
		= tag :img, :src => "/images/404td.jpg", :maxwidth => "60%"

		p Modo dual suportado por hardware: mode bit (0=kernel/1=user)

		p.fragment <strong>Solo puede ser modificado por el S.O.</strong> (¿por qué?)
		p.fragment Kernel mode, a.k.a. (Privileged | Supervised | Monitor | System) mode

		blockquote.fragment
			| Instrucciones privilegiadas<br/>
			| Solo pueden ejecutar en modo kernel <br/>
			| Si se intenta ejecutar en mode=1, el hardware no la ejecuta y genera una interrupción para el S.O. Evita acceso indebido de otros usuarios

		p.fragment Ej: cambio mode bit, llamada I/O, manejo timer, manejo de interrupciones


	section
		h4 Multi-modos

		p Más de dos modos de operación, ¿para qué?

		ul
			li.fragment Útil para virtualización
			li.fragment VMM (<em>Virtual Machine Manager</em>) opera en modo intermedio
			div.fragment
				ul
					li Menos privilegios que S.O.
					li Más privilegios que cada <em>Virtual Machine</em>

		br
		div.fragment
			// figs/00-1_20.pdf
			= tag :img, :src => "/images/404td.jpg", :maxwidth => "60%"


	section
		p Programas de usuario hacen llamadas al S.O para que ejecute acciones a nombre de ellos

		ul
			li.fragment <em>syscall</em>, <em>trap</em>

		br
		br
		p.fragment ¿Qué puede pasar si no hay bit mode? (Intel 8088 no lo tenía)
		/ caso de 8088 y MS-DOS. Un proceso en MS-DOS podía echarse el SO

		ul
			li.fragment Mode bit permite protección de hardware
			li.fragment Si un programa comete un acceso indebido o error, trap al S.O.
			ul
				li.fragment S.O. termina el programa <em>abnormally</em>

			li.fragment ¿Cómo evitar que un programa no devuelva el control al SO?
			ul
				li.fragment S.O. usa un timer que genera un trap a intervalo definido
				li.fragment Timer también debe ser establecido en modo Kernel



section
	h2 Entonces...
	/  -----------

	section
		p 3 tareas fundamentales para un Sistema Operativo:

		ul
			li Administración de procesos
			li Administración de memoria
			li Administración de dispositivos de E/S



// %section
// %	\frametitle{Tarea: Administración de Procesos}
// %
// %	Administración de la unidad principal de trabajo: <strong>proceso</strong>.
// %
// %	\onslide<2->{Un proceso necesita diversos recursos:}
// %	ul
// %		ul.fragment CPU, memoria, archivos, dispositivos IO
// %		ul.fragment Más que un programa (programa es pasivo, proceso es activo)
// %
// %
// %	\onslide<4->{Hay procesos de usuario y procesos de sistema}
// %
// %	\begin{block}<5->{<strong>SO es responsable de:}</strong>
// %	ul
// %		ul.fragment Planificar procesos y threads en la CPU
// %		ul.fragment Crear y borrar procesos de usuario y de sistema
// %		ul.fragment Suspender y continuar procesos
// %		ul.fragment Proveer mecanismos de sincronización
// %		ul.fragment Proveer mecanismos de comunicación



// %section
// %	\frametitle{Tarea: Administración de Memoria}
// %
// %	La interacción de la CPU es principalmente con la memoria.
// %
// %	<strong>Memoria:}\onslide<2->{ Un arreglo contínuo de bytes, cada uno con su propia dirección.</strong>
// %
// %	ul
// %		ul.fragment Instruction-fetch y data-fetch ocurren con la memoria
// %		ul.fragment Aún las lecturas de disco o de IO deben pasar por memoria
// %		ul.fragment Las direcciones de un programa deben ser mapeadas a direcciones absolutas
// %		ul.fragment Un uso eficiente requiere que haya múltiples procesos con su memoria listos para ejecutar
// %
// %
// %	\begin{block}<5->{<strong>SO es responsable de:}</strong>
// %	ul
// %		ul.fragment Mantener un registro de los sectores de memoria utilizados y por quién
// %		ul.fragment Determinar qué procesos o parte de ellos deben ser cargados y descargados
// %		ul.fragment Asignar y deasignar espacios de memoria



// %section
// %	\frametitle{Tarea: Administración de Almacenamiento}
// %
// %	\begin{center}
// %		\includegraphics[width=3cm]{figs/00-1_09.pdf}
// %	\end{center}
// %
// %	Distribución de memoria en un sistema de multiprogramación
// %

// %---------------------------------------------------------------------
// %section
// %	\frametitle{Tarea: Administración de Almacenamiento}
// %
// %	Los sistemas de almacenamiento abstraen las propiedades físicas del medio
// %	usando una unidad lógica de almacenamiento llamada \ldots \onslide<2->{<strong>archivo}</strong>
// %
// %	\onslide<2->{<strong>Archivo:}}\onslide<3->{ colección de datos relacionados, definida por su creador</strong>
// %	\onslide<4->{(sí, es algo muy general)}
// %
// %	\onslide<5->{S.O. mapea archivos a ubicaciones dentro de medios físicos}
// %
// %	ul
// %		ul.fragment Distintos medios: discos magnéticos, ópticos, estado sólido, cintas
// %		ul.fragment Distintas propiedades: velocidad de acceso, de transferencia, método de acceso (seq/aleatorio)
// %		ul.fragment Debe definir quién puede acceder un archivo
// %
// %
// %	\begin{block}<6->{<strong>SO es responsable de:}</strong>
// %	ul
// %		ul.fragment Crear y borrar archivos, y directorios que permitan organizar archivos
// %		ul.fragment Proveer primitivas para manipulación de archivos y directorios
// %		ul.fragment Mapear archivos a almacenamiento secundario
// %		ul.fragment Almacenar archivos en medios no-volátiles



// %section
// %	\frametitle{Tarea: Administración de Almacenamiento}
// %
// %	El almacenamiento secundario debe ser utilizado eficientemente
// %
// %	ul
// %		ul.fragment Su acceso suele limitar la velocidad de ejecución
// %
// %
// %	\begin{block}<3->{<strong>SO es responsable de:}</strong>
// %	ul
// %		li Administrar espacio disponible
// %		li Asignación de destino de almacenamiento
// %		li Planificación de disco



// %---------------------------------------------------------------------
// %section
// %	\frametitle{Caching}
// %	\framesubtitle{El problema de la jerarquía de memoria}
// %
// %	Fundamental para asegurar un funcionamiento eficiente.
// %
// %	Existe por la diferencia en los accesos a la jerarquía de memoria
// %
// %	\begin{center}
// %		\includegraphics[width=6cm]{figs/00-1_04.pdf}
// %	\end{center}

// %section
// %	\frametitle{Caching}
// %
// %	ul
// %		li Datos viven en memoria principal
// %		li Al usarla se copia en almacenamiento más rápido
// %		li Al buscarla, se busca primero en caché
// %		li Si no se encuentra, se lee de memoria principal y se copia en caché
// %
// %	\onslide<2->{Caché}
// %	ul
// %		ul.fragment Registros: caché más cercano, administrado por programador/compilador
// %		ul.fragment Cachés implementados en hardware, fuera del control de SO
// %		ul.fragment Algunos datos deben ser borrados del caché, ¿cuáles?
// %		ul.fragment Administración de caché es importante
// %
// %
// %	\onslide<3->{¿Qué pasa cuando hay múltiples copias? ¿Con más de un proceso?}
// %
// %	\onslide<4->{<strong>Coherencia de caché}} \onslide<5->{\ldots ¿Y en un ambiente distribuido?</strong>


// %section
// %	\frametitle{Caching}
// %
// %	Tiempos de acceso
// %
// %	\begin{center}
// %		\includegraphics[width=10cm]{figs/00-1_11.pdf}
// %	\end{center}


// %section
// %	\frametitle{Protección y Seguridad}
// %
// %	Ante múltiples usuarios, el acceso a datos debe ser regulado
// %
// %	\onslide<2->{Hasta ahora \ldots}
// %	ul
// %		ul.fragment Hardware asegura que procesos solo pueden acceder memoria dentro de su espacio
// %		ul.fragment Timer asegura que ningún proceso se quede sin devolver la CPU
// %		ul.fragment Registros de control de dispositivos no son accesibles por usuarios
// %
// %
// %	\onslide<4->{Sistemas de <strong>protección} controlan el acceso de procesos o usuarios a los recursos computacionales</strong>
// %
// %	ul
// %		ul.fragment Un buen sistema de protección también puede sufrir de accesos indebidos
// %
// %
// %	\onslide<6->{Un sistema de <strong>seguridad} debe defender de ataques externos e internos</strong>


// %section
// %	\frametitle{Protección y Seguridad}
// %
// %	Algunos requisitos de los sistemas de protección y seguridad
// %
// %	ul
// %		ul.fragment Distinción entre usuarios: nombre e identificador (userID, securityID)
// %		ul.fragment Grupos de usuarios e identificadores de grupos
// %		ul.fragment Asociación de privilegios/permisos
// %		ul.fragment Métodos seguros para escalar privilegios (setuid)



section
	h2 Elementos y Servicios de un Sistema Operativo
	/  ---------------------------------------------

	section
		p At a glance...

		br
		/ figs/00-2_01.pdf
		= tag :img, :src => "/images/404td.jpg", :maxwidth => "60%"



section
	h2 Interfaces de Usuario (UI)
	/  --------------------------

	section
		p Varias alternativas...
		ul
			li.fragment <em>Command-Line Inteface (CLI):</em> Comandos se ingresan por teclado
			li.fragment <em>Batch interface:</em> Comandos se ingresan en archivos
			li.fragment <em>Graphical User Interface (GUI):</em> Sistema de ventanas + <em>pointing-device</em>

	section
		h4 Command-Line (línea de comandos) <span class="fragment">(<strong>shells</strong>)</span>

		p.fragment Para UNIX
		div.fragment
			ul
				li <em>Bourne shell</em>: Stephen Bourne, 1977, UNIX, <code>sh</code>
				li <em>C shell</em>: Bill Joy, 1978, BSD UNIX, <code>csh</code>
				li <em>TENEX C Shell</em>: Ken Greer, 1983, <code>tcsh</code>
				li <em>Korn shell</em>: David Korn, 1983, <code>ksh</code>
				li <em>Bourne-Again shell</em>: Brian Fox, 1989, <code>bash</code>
				li <em>Z shell</em>: Paul Fastad, 1990, <code>zsh</code>

		p.fragment En windows
		div.fragment
			ul
				li <em>MS-DOS prompt</em>: MS-DOS, Win95/98/Me, <code>COMMAND.COM</code>
				li <em>Command Prompt</em>: <code>cmd.exe</code>


	section
		h4 Command-Line (línea de comandos)

		p Uso común:
		ul
			li Solicitar comando/instrucción al usuario y ejecutarlo
			li Formato: <code>prompt comando [parametros]</code>

		div.fragment
			p <em>Command Prompt</em> (símbolo del sistema)
			ul
				li.fragment Indica que el sistema está lista para recibir un comando
				li.fragment Usualmente un texto terminado en <code>$, %, #, :, ></code>

		div.fragment
			pre
				code.hljs
					| cruz$ ls
					 
					 jabaier@grima$ cp clase-01.tex backup/
					 
					 jnavon@www[15:35]:> rm tareaSistOp.*
					 
					 dietr1ch@nb ~/SO/Tareas 
					 ls -d */ | parallel --tag 'cd {} && make'


	section
		h4 Graphical User Interface (GUI)

		p Interfaz gráfica (para quienes no les gusta escribir comandos)
		div.fragment
			ul
				li Usualmente con un <em>pointing-device</em> y ventanas
				li Métaforas: escritorio, íconos, carpetas, menúes
				li Más allá de <em>pointing-device</em>: gestos y acciones visuales

		p.fragment Vienen de los \(\sim\) 1970's
		div.fragment
			ul
				li Investigación de Xerox Palo Alto Research Center (PARC)
				li Primera interfaz gráfica: 1973
				li Popularizados en 1980s: Apple Macintosh (Mac OS)
				li Windows 1.0 agregó GUI a MS-DOS


	section
		h4 Graphical User Interface (GUI)

		p Tradicionalmente UNIX/Linux han sido manejados por CLI,
		p.fragment pero se han desarrollado muchas GUIs

		ul
			li.fragment CDE (<em>Common Desktop Environment</em>): Unix, OpenVMS
			li.fragment X-Windows Systems: Xfce, KDE, GNOME (Unix/Linux)

		= tag :img, :src => "/images/figures/00-Xwindows.png", :style => "max-width:50%;float:right;"


	section
		= tag :img, :src => "/images/figures/00-CDE.png", :style => 'max-width:50%; max-height:50%'
		p CDE (Common Desktop Environment)


	section
		= tag :img, :src => "/images/figures/00-XFCE.png", :style => 'max-width:50%; max-height:50%'
		p Xfce


	section
		= tag :img, :src => "/images/figures/00-GNOME.png", :style => 'max-width:50%; max-height:50%'
		p GNOME


	section
		= tag :img, :src => "/images/figures/00-KDE.png", :style => 'max-width:50%; max-height:50%'
		p KDE (K Desktop Environment)



section
	h2 Llamadas al sistema
	/  -------------------

	section
		h4 System Calls
		p Programas utilizan llamadas al sistemas frecuentemente
		p Ej: <code>copy source.txt dest.txt</code>... ¿qué requiere?

		ul
			div.fragment
				li Abrir <code>source.txt</code>
				ul
					li ¿Existe?
					li ¿Tiene permisos?

			div.fragment
				li Abrir <code>dest.txt</code>
				ul
					li ¿Existe? ¿se reemplaza?
					li ¿Se puede escribir?

			li.fragment Lectura/escritura en disco requiere llamadas al sistema
			li.fragment Terminar el programa en caso de error, requiere llamadas al sistema

		p.fragment ...pero el programador no quiere programar todas las llamadas


	section
		h4 API: Application Programming Interface

		p Sistemas Operativos proveen una API para el programador.
		ul
			li.fragment Windows API
			li.fragment POSIX API (UNIX, Linux, MacOS X), a través de {\tt libc}
			li.fragment Java API (para la JVM)

		br
		p.fragment ¿Cómo usarla?
		div.fragment
			p eg:
			pre style="width:50%;"
				code.hljs
					| man read


	section
		/  figs/00-2_06.pdf
		= tag :img, :src => "/images/404td.jpg", :style => 'max-width:60%; max-height:60%'


	section
		= tag :img, :src => "/images/figures/00-syscalls.png", :style => 'max-width:60%; max-height:60%'



// %\section{Decisiones de diseño}

// %section
// %	\frametitle{Decisiones de diseño}
// %	¿Cuál es la mejor forma de diesñar un Sistema Operativo?
// %
// %	\onslide<2->{(si se supiera no habrían <em>OS wars})</em>
// %
// %	ul
// %		ul.fragment Uso de <strong>estructuras de datos</strong> apropiadas
// %		ul.fragment Aplicando principios de <strong>ingeniería de software</strong>
// %		ul.fragment Aprovechando las capacidades que permite la <strong>arquitectura del hardware</strong>


// %section
// %	\frametitle{Decisiones de diseño}
// %
// %%	ul
// %%		li <strong>Mecanismo}: {\em cómo</strong> se implementa una funcionalidad (decisión estática)
// %%			ul
// %%				li Ej: Mecanismo para asignar prioridades a procesos.
// %%
// %%		li <strong>Política}: {\em qué</strong> decisión se va a implementar
// %%			ul
// %%				li Ej: Bajo qué criterio se asignan prioridades
// %%
// %%
// %	\onslide<2->{
// %	Principio de <strong>separación de preocupaciones} ({\em separation of concerns</strong>)
// %	ul
// %		li <em>Microkernels</em> definen un conjunto pequeño de primitivas
// %		li Mecanismo deberían <em>de propósito general</em>
// %	}


// %---------------------------------------------------------------------
// %section
// %	\frametitle{¿En qué lo programo?}
// %
// %	¿En qué se programa un sistema operativo?
// %	ul
// %		ul.fragment Los primeros ... en <em>assembler</em>
// %		ul.fragment Más modernos en C, C++ (Windows, Linux)
// %		ul.fragment Actuales incluyen muchos lenguajes
// %			ul
// %				li Bajo nivel en assembler
// %				li Interacciones principales en C
// %				li Utilidades de alto nivel en lenguaje interpretado (python, perl)
// %
// %	\onslide<5->{Al usar un lenguaje de alto nivel es más fácil hacer un <strong>port}</strong>
// %	ul
// %		li <6-> MS-DOS fue escrito en Assembler de Intel 8088
// %		li <6-> Para otras arquitecturas se requiere un <strong>emulador</strong>



section
	h2 Estructura: MS-DOS
	/  ------------------

	section
		p ¿Sistemas <strong>monolíticos</strong> o sistemas <strong>modulares</strong>?
		p.fragment Algunos ni siquiera tienen estructura
		ul
			li.fragment MS-DOS: sistema monolítico simple
			li.fragment Nadie pensó que sería tan popular
			li.fragment Intel 8088 no tenía protección de <em>dual mode</em>
			li.fragment ¿Problemas? <span class="fragment">Seguridad</span>

		/ 00-2_11.pdf
		= tag :img, :src => "/images/404td.jpg", :style => 'max-width:60%; max-height:60%'



section
	h2 Estructura: UNIX
	/  ----------------

	section
		p UNIX: Estructura monolítica diseñada de acuerdo al <em>hardware</em>

		/ 00-2_12.pdf
		= tag :img, :src => "/images/404td.jpg", :style => 'max-width:60%; max-height:60%'

		p.fragment ¿Problemas? <span class="fragment">Dificultad de mantenimiento</span>



section
	h2 Estructura: diseño por capas
	/  ----------------------------

	section
		p Capas se diseñan por niveles más <em>abstractos</em> de funcionalidad

		ul
			li          Capa \(M\) invoca llamadas sobre capa \(M-1\)
			li.fragment Ventaja: Facilidad de <em>debugging</em>
			li.fragment Desventaja: dificultad de definición de capas (¿a qué nivel va qué funcionalidad?)
			li.fragment Desventaja: eficiencia (¿cuántas capas?)

		/ 00-2_13.pdf
		= tag :img, :src => "/images/404td.jpg", :style => 'max-width:60%; max-height:60%'



section
	h2 Estructura: <em>microkernels</em>
	/  ---------------------------------

	section
		p <strong>Mach</strong>: versión de UNIX usando diseño de <em>microkernel</em> (CMU)

		ul
			li          Set de funcionalidades mínimas
			li          Otras funcionalidades agregadas como programas de usuario ¿dónde poner el límite?
			li.fragment Ventaja: Sistemas pequeño y fácil de portar
			li.fragment Desventaja: Más interacción a través de <em>syscalls</em>!
			li.fragment <strong>Darwin</strong> (MacOS X kernel) basado parcialmente en modelo Mach
			li.fragment <strong>Windows NT</strong> usaba microkernel pero era más lento que Win95.
			li.fragment <strong>GNU/Hurd</strong> aún es más lento que Linux.

		/ 00-2_14.pdf
		= tag :img, :src => "/images/404td.jpg", :style => 'max-width:60%; max-height:60%'



section
	h2 Estructura: <em>módulos</em>
	/  ----------------------------

	section
		p Lo más común: <strong>loadable kernel modules</strong>

		ul
			li Kernel tiene un conjunto de componentes principales (<em>core</em>)
			li Módulos necesarios se agregan durante ejecución
			li Evita recompilar el kernel para cada nueva funcionalidad
			li Solaris, Linux, MacOS X, Windows
			li Ej: kernel con soporte de manejo de archivo + módulos por cada <em>filesystem</em>

		/ 00-2_15.pdf
		= tag :img, :src => "/images/404td.jpg", :style => 'max-width:60%; max-height:60%'



section
	h2 Al final: Estructuras híbridas
	/  ------------------------------

	section
		p En la práctica, pocos sistemas pueden ser encasillados

		ul
			li Linux, Solaris, Windows tienen características monolíticas (performance!)
			li Pero algunas funcionalidades siguen el diseño de <em>microkernel</em>
			li ¡Y además permiten cargar módulos dinámicamente!



// %section
// %	\frametitle{Ejemplo: Apple Mac OS X}
// %
// %	ul
// %		li <strong>Cocoa</strong>: API para Objective-C
// %		li Kernel: Mach microkernel + BSD Unix Kernel
// %			ul
// %				li Mach: manejo de memoria, RPC, IPC, paso de mensajes, <em>threads</em>
// %				li BSD: CLI, networking, sistemas de archivos, API POSIX
// %
// %		li Módulos cargables: <strong>kernel extensions</strong>
// %
// %	\begin{center}
// %		\includegraphics[width=7cm]{figs/00-2_16.pdf}
// %	\end{center}



// %section
// %	\frametitle{Ejemplo: Apple iOS}
// %
// %	ul
// %		li <strong>Cocoa Touch</strong> = Cocoa + soporte para gestos
// %		li Media: soporte gráfico + audio + video
// %		li Core: kernel basado en Mac OS X
// %
// %	\begin{center}
// %		\includegraphics[width=4cm]{figs/00-2_17.pdf}
// %	\end{center}



// %section
// %	\frametitle{Ejemplo: Android}
// %
// %	ul
// %		li Modelo por capas + kernel Linux
// %		li Implementación de máquina virtual <strong>Dalvik</strong>
// %		li Frameworks para desarrollo: webkit, SQLite, libc
// %
// %	\begin{center}
// %		\includegraphics[width=6cm]{figs/00-2_18.pdf}
// %	\end{center}

