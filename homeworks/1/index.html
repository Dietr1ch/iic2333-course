<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>Tarea 1</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta content="Dietrich Daroch" name="author" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.min.css" rel="stylesheet" /><link href="//cdnjs.cloudflare.com/ajax/libs/jasny-bootstrap/3.1.3/css/jasny-bootstrap.min.css" rel="stylesheet" /><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/zenburn.min.css" rel="stylesheet" /><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js" type="text/javascript"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/contrib/auto-render.min.js"></script><script>hljs.initHighlightingOnLoad();</script><style type="text/css">pre code.hljs {
  display: block;
}
code.hljs {
  display: inline;
}

// Hover stuff
code:hover>div {
  display: block;
}
code>div {
  display: none;
}
table {
  margin: auto;
  //border-collapse: separate;
  //border-spacing: 0 0.1em;
}
tr.sep {
  margin-top: 0.2em;
}
td {
  min-width:4em;
}
td.r2 {
  rowspan: 2;
}
td.full {
  color: #ddd;
  background-color: #282;
}
td.empty {
  color: #ddd;
  background-color: #333;
}

// Fix dl/ dd-dt
dl.inline dd {
  display: inline;
  margin: 0;
}
dl.inline dd:after{
  display: block;
  content: '';
}
dl.inline dt{
  display: inline-block;
  min-width: 100px;
}

section {
  padding-top: 2em;
}
h1, h2, h3, h4, h5, h6 {
  padding-top: 0.4em;
}
.top {
  padding-top: 0.2em;
}
.container {
  display: flex;
  justify-content: center;
}
.container-col {
  display: flex;
  justify-content: center;
  flex-direction: column;
}
.container > img {
  align-content: center;
}
.container-col > img {
  align-content: center;
}</style></head><body><header class="col-xs-12 col-md-8 col-md-offset-2"><h2>Sistemas Operativos y Redes</h2></header><div class="col-xs-12 col-md-8 col-md-offset-2"><section><h1>Tarea 1</h1></section><article><section class="top"><p>En esta tarea van a preparar el stack de llamadas para los programas.</p><p>La tarea se divide en 2 partes independientes,</p><ul><li> Preparar un stack en un programa pequeño.</li><li> Preparar el stack de Pintos, un SO educacional.</li></ul></section><section><h2>El stack de llamadas</h2><p>Es usual ver el stack de llamadas en la terminación abrupta de algún programa, así que es seguro decir que ya han visto muchos de ellos.</p><p>Consideremos el siguiente programa,</p><pre><code class="hljs">int factorial(int n) {
  if(n<=0)
    return 1;
  return n * factorial(n-1);
}

int main() {
  return factorial(5);
}</code></pre><h4>¿Cómo se ejecuta?</h4><p>Primero veamos una versión no-comprimida de lo que hay que calcular.</p><pre><code class="hljs">/* -- */  int factorial(int n) {
/* 02 */    if(n<=0)
/* 03 */      return 1;  /* <-- */
/* 04 */    int r = factorial(n-1);
/* 05 */    return n*r;
/* -- */  }
/* -- */  
/* -- */  int main() {
/* 09 */    int r = factorial(4);
/* 10 */    return r;
/* -- */  }</code></pre><p>Supongamos que queremos llegar hasta la línea 3.</p><p>Como todo programa, se comienza a calcular <code>main()</code></p><ul><li><pre><code class="hljs c">main() /* ... */</code></pre><p>Pero mientras calculamos <code>main()</code> hay que calcular otra función,</p><pre></pre></li><ul><li><pre><code class="hljs c">factorial(n=4) /* ... */</code></pre><p>y otra&hellip;</p></li><ul><li><pre><code class="hljs c">factorial(n=3) /* ... */</code></pre></li><ul><li><pre><code class="hljs c">factorial(n=2) /* ... */</code></pre></li><ul><li><pre><code class="hljs c">factorial(n=1) /* ... */</code></pre></li><ul><li><pre><code class="hljs c">factorial(n=0) /* ... */
/* 03 */    return 1;</code></pre></li></ul></ul></ul></ul></ul></ul><p>Mientras se computa una función hay que ser capaces de pausar el cálculo mientras se computa otra.</p><p>Y hay que reanudar el cálculo una vez que se conozca el valor de la función.</p><h4>¿Cómo hacemos todos los cálculos en memoria?</h4><p>Primero hay que notar que todas las llamadas asignan a <code>r</code>, pero esa variable es local para cada cálculo. Hay más variables de las que parece tener el programa.</p><ul><li><pre><code class="hljs c">main() /* ... */
/* 09 */    int r = factorial(4);</code></pre></li><ul><li><pre><code class="hljs c">factorial(n=4) /* ... */
/* 04 */    int r = factorial(n-1);</code></pre></li><ul><li><pre><code class="hljs c">factorial(n=3) /* ... */
/* 04 */    int r = factorial(n-1);</code></pre></li><ul><li><pre><code class="hljs c">factorial(n=2) /* ... */
/* 04 */    int r = factorial(n-1);</code></pre></li><ul><li><pre><code class="hljs c">factorial(n=1) /* ... */
/* 04 */    int r = factorial(n-1);</code></pre></li><ul><li><pre><code class="hljs c">factorial(n=0) /* ... */
/* 03 */    return 1;</code></pre></li></ul></ul></ul></ul></ul></ul><p>Agruparemos la información de cada función en un <code>frame</code>.</p><p>Un frame necesita tener:</p><ul><li>Un puntero a la instrucción que se está ejecutando (lo necesitaremos para reanudar el cálculo)</li><ul><li>Con ese puntero queda implícita la función que se estaba calculando, es la dueña de esa instrucción.</li></ul><li>Los argumentos que le entregaron a la función.</li><li>Las variables locales de la función.</li></ul><p>Para almacenar la ejecución completa podríamos tener un arreglo de frames y un índice al frame actual.</p><ul><li>Pero no todas las funciones usan la misma cantidad de argumentos y variables locales.</li><li>Además no nos interesa poder acceder a cualquier función, sólo necesitamos un orden LIFO.</li><li>Un stack de <code>frames</code> de tamaño variable.</li></ul><p>Durante la ejecución de un programa, el compilador transforma las llamadas a funciones y retornos a operaciones del stack de funciones.</p><p>Pero eso es una vez que ya está corriendo el programa.</p><p>¿Quién hace el caso base? El SO cuando carga el programa...</p></section><section><br /></section><section id="hw1"><h2>Tarea 1</h2><section id="hw1-formalidades"><h4>Formalidades</h4><p>La tarea será entregada vía <code>git</code></p><ul><li> La entrega es el Lunes 28 de Marzo a las 23:59.</li><li> Puede ser realizada en grupos de 2.</li><li> Su repositorio DEBE ser privado, de lo contrario calificará como copia (alguien les podría haber copiado).</li><li> La entrega será automatizada, basta que <a href="http://goo.gl/forms/Oph3ORVNLv" target="_blank">registren</a> su grupo y repositorio</li><ul><li> Como el repositorio debe ser privado, tendrán que <a href="https://confluence.atlassian.com/bitbucket/use-deployment-keys-294486051.html">permitir</a> acceso especial al curso, autorizando al servidor de tareas acceder al contenido.</li><ul><li> Para esto basta <a href="https://confluence.atlassian.com/bitbucket/use-deployment-keys-294486051.html" target="_blank">registrar</a> la <a href="/os-id_rsa.pub">llave pública del curso</a> en las <em>Deployment Keys</em> de su repositorio.</li></ul></ul></ul></section><section><h4>Repositorio</h4><p>El código de la tarea se encuentra en <a href="https://bitbucket.org/Dietr1ch/pintos/commits/branch/os16-1" target="_blank">el repositorio del curso</a> y para trabajar en el deben <a href="https://bitbucket.org/Dietr1ch/pintos/fork" target="_blank">hacer un fork</a> PRIVADO!</p><ul><li> Lo más cómodo es que usen bitbucket, pero pueden usar github u otro host mientras sea privado.</li></ul><p>El "repo" del curso es un fork del proyecto <a href="http://web.stanford.edu/class/cs140/projects/pintos/pintos_1.html#SEC1" target="_blank">pintos</a> de Stanford</p><h4>TODO:</h4><p>Como ya se dijo, la tarea se divide en 2 partes independientes,</p><ul><li> <em>Warmup (30%)</em>: Preparar un stack en un programa pequeño.</li><ul><li><code>/extra/argParse.c</code></li></ul><li> <em>Tarea (70%)</em>: Preparar el stack de Pintos</li><ul><li><code>/src/userprog/process.c</code></li></ul></ul><section><h5>Parte 1</h5><p>Para ejecutarlo deben compilarlo</p><pre><code class="hljs bash">cd path/to/pintos/
cd extra
$CC -g -o argParse argParse.c  # CC = "gcc" || "clang"

# Common problems:
#  * $CC May be not set on some environments, set it or just pick a compiler
#  * Old compilers don't use C11 by default (use -std=C11 to force it)</code></pre><p>Y luego lo pueden ejecutar,</p><pre><code class="hljs bash">./argParse</code></pre><p>Sólo cambiando <code>int parse()</code> debería ejecutar sin errores.</p></section><section><h5>Parte 2</h5><p> Para trabajar con el resto de pintos deben compilar distintos módulos del kernel y preparar un "disco duro" con programas para ejecutar </p><p> Los módulos se encuentran en <code>/src/</code> </p><ul><li> <code>threads</code></li><li> <code>userprog</code></li><li> <code>vm</code></li><li> <code>examples</code></li><li> <code>filesys</code></li></ul><p> Para compilar los módulos, basta ejecutar <code>make</code> en cada uno de los directorios.</p><p> La preparación del disco necesita ejecutar la máquina virtual varias veces,</p><ul><li> Hay que crear un archivo que sirva de "disco duro" para pintos.</li><li> Hay que formatear el disco, ya que el disco se usa con una estructura particular en vez de como un arreglo gigante de bytes.</li><li> Hay que copiar programas al disco duro (ya que comienza vacío)</li><ul><li> Para la tarea cualquier programa que use argumentos es útil</li><ul><li> cowsay</li><li> interecho</li><li> &hellip;</li></ul></ul></ul><br /><p> Una vez hecho esto, desde <code>/src/userprog</code> se puede ejecutar pintos y pedirle que luego de comenzar ejecute algún programa de los que se copiaron</p><pre><code class="hljs bash">cd path/to/pintos
cd src/userprog
../utils/pintos -- run "programName programArgs.."</code></pre><h6>Branch del curso</h6><p> Obviamente la preparación de esto hace que sea tedioso probar el programa, es por esto que en el repo del curso hay un <a href="https://bitbucket.org/Dietr1ch/pintos/commits/branch/os16-1" target="_blank"><em>branch</em></a> que aliviana la tarea, <code>os16-1</code>. Se sugiere fuertemente que hagan <em>merge</em> de ese <em>branch</em> al <em>branch</em> principal de su 'repo'.</p><p> En el branch se mejora el <code>Makefile</code> de <code>/</code> ("root", el directorio base del proyecto) para simplificar el proceso,</p><ul><li> Crea <code>TAGS</code> para <a href="https://en.wikipedia.org/wiki/Ctags#Editors_that_support_ctags" target="_blank">navegar el código</a> (si tienen <code>ctags</code> instalado).</li><li> Compila todos los módulos.</li></ul><p> También se agrega un script de <code>bash</code> para preparar el disco, <code>build-disk</code>, este no se ejecuta desde <code>make</code> ya que puede no ser necesario recrear el disco</p><p> Pronto se agregará un commit con soporte parcial de la syscall <code>write</code>, lo que permitirá que los programas del disco duro puedan imprimir por <code>stdout</code>.</p><pre><code class="hljs bash">cd path/to/pintos
make         # Builds all modules
./build-disk # Prepares a disks with a few programs</code></pre><section><h6>¿Dónde comenzar?</h6><p>El <em>hack</em> de <a href="http://web.stanford.edu/class/cs140/projects/pintos/pintos_3.html#SEC40" target="_blank">sugerido por la documentación</a> ya fue aplicado en el branch del curso, pero se espera lo eliminen cuando implementen esta tarea.</p><ul><li><a href="http://web.stanford.edu/class/cs140/projects/pintos/pintos.html" target="_blank">Documentación de Pintos</a><p>(Recuerden que la documentación de Pintos cubre más cosas y habla sobre tareas mucho más extensas que esta)</p></li><ul><li><a href="http://web.stanford.edu/class/cs140/projects/pintos/pintos_3.html#SEC44" target="_blank">Argument Passing</a></li><ul><li><a href="http://web.stanford.edu/class/cs140/projects/pintos/pintos_3.html#SEC51" target="_blank">Program Startup</a></li></ul><li><a href="http://web.stanford.edu/class/cs140/projects/pintos/pintos_10.html#SEC145" target="_blank">Debugging Tools</a><p>Se recomienda intentar en este orden: print, backtraces y <code>gdb</code>. Pero una vez que ya sepan usar <code>gdb</code> (con breakpoints y evaluar expresiones basta) no van a querer depender de prints y backtraces.</p></li></ul></ul></section><section><h6>¿Qué debería modificar?</h6><p><code>/src/userprog/process.c</code></p><ul><li><code>setup_stack(...)</code></li></ul></section><section><h6>Resumen</h6><pre><code class="hljs bash">git clone urlMyPrivateFork
cd project
# Add remote and merge changes

$EDITOR .    # Work
make         # Builds all modules
./build-disk # Prepares a disks with a few programs

cd src/userprog/
../utils/pintos -- run program  # Test changes

git commit
git push</code></pre></section></section></section></section></article></div><footer><div class="col-xs-12 col-md-8 col-md-offset-2"><p style="padding-top:4em;">Sistemas Operativos y Redes</p><p>Departamento de Ciencia de la Computación</p><p>Pontificia Universidad Católica de Chile</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0-alpha1/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.min.css"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jasny-bootstrap/3.1.3/js/jasny-bootstrap.min.js"></script><script>renderMathInElement(document.body)</script></body></html>