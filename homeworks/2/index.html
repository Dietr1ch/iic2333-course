<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>Tarea 2 (25/4 12:00)</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta content="Dietrich Daroch" name="author" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.min.css" rel="stylesheet" /><link href="//cdnjs.cloudflare.com/ajax/libs/jasny-bootstrap/3.1.3/css/jasny-bootstrap.min.css" rel="stylesheet" /><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/zenburn.min.css" rel="stylesheet" /><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js" type="text/javascript"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/contrib/auto-render.min.js"></script><script>hljs.initHighlightingOnLoad();</script><style type="text/css">pre code.hljs {
  display: block;
}
code.hljs {
  display: inline;
}

// Hover stuff
code:hover>div {
  display: block;
}
code>div {
  display: none;
}
table {
  margin: auto;
  //border-collapse: separate;
  //border-spacing: 0 0.1em;
}
tr.sep {
  margin-top: 0.2em;
}
td {
  min-width:4em;
}
td.r2 {
  rowspan: 2;
}
td.full {
  color: #ddd;
  background-color: #282;
}
td.empty {
  color: #ddd;
  background-color: #333;
}

// Fix dl/ dd-dt
dl.inline dd {
  display: inline;
  margin: 0;
}
dl.inline dd:after{
  display: block;
  content: '';
}
dl.inline dt{
  display: inline-block;
  min-width: 100px;
}

section {
  padding-top: 2em;
}
h1, h2, h3, h4, h5, h6 {
  padding-top: 0.4em;
}
.top {
  padding-top: 0.2em;
}
.container {
  display: flex;
  justify-content: center;
}
.container-col {
  display: flex;
  justify-content: center;
  flex-direction: column;
}
.container > img {
  align-content: center;
}
.container-col > img {
  align-content: center;
}</style></head><body><header class="col-xs-12 col-md-8 col-md-offset-2"><h2>Sistemas Operativos y Redes</h2></header><div class="col-xs-12 col-md-8 col-md-offset-2"><section><h1>Tarea 2 (25/4 12:00)</h1></section><article><section class="top"><p>En esta tarea van a implementar un <em>Scheduler</em> para pintos.</p><p>Además de elegir procesos a ejecutar, deberán solucionar algunos problemas relacionados.</p><ul><li>Un <em>Scheduler</em> de prioridades tiene algunos detalles,</li><ul><li>Hay que tener una prioridad para cada proceso.</li><li>Hay que tener cuidado con la <em>Inanición</em>, especialmente al considerar esperas.</li></ul><li>Los procesos necesitan reportar su estado de termino y estadísticas de ejecución.</li><ul><li>Los procesos padres deberían saber en qué estado terminaron sus hijos para decidir qué hacer.</li><li>Es mediante las estadísticas que se puede evaluar el <em>Scheduler</em></li></ul></ul></section><section id="todo"><h3><em>Scheduling</em></h3><p>El <em>Scheduling</em> es el arte de escoger un orden adecuado de tareas (paralelas o no) de manera de aprovechar de mejor manera los recursos disponibles.</p><p>Una de las ocurrencias del problema en un SO es al escoger un orden para ejecutar procesos.</p><p>Esta no es la situación ideal, ya que no sabemos mucho de los requisitos de cada tarea (ni tiempo, ni memoria a usar). Justamente por esto es que se necesitan criterios fáciles de calcular (decidibles) y a la vez informativos para lograr escoger algún orden bueno.</p><p>Uno de los conceptos esenciales en el <em>Scheduling</em> de CPU es el de buscar un orden equitativo al distribuir recursos entre todos los que los necesitan.</p><p>Para lograr una "buena" distribución se opta por ejecutar los programas activos de forma alternada intervalos de al menos 1 <em>Quantum</em>, una fracción ínfima de tiempo. Ese ínfimo se escoge de manera que los procesos alcancen a avanzar en su ejecución, pero evitando usar demasiado tiempo, ya que se dejaría al resto sin avanzar.</p><p>En sistemas interactivos se suele escoger también una cota superior para las ejecuciones, usualmente evitando ejecutar más de \(K\) quantums consecutivos el mismo proceso. En estos sistemas se suele premiar el devolver cooperativamente el control.</p><h4><em>Scheduling</em> de prioridades</h4><p>Un sistema de <em>Scheduling</em> común de ganar información para decidir el orden es usando prioridades definidas por el usuario.</p><p>El uso más simple de esa información es mediante un <em>Scheduling</em> de prioridades.</p><p>En este sistema, existe una función \(priority :: Process \rightarrow \mathbb{N}\) que para cada proceso retorna una prioridad en \([pri_{min}, pri_{max}]\). Esta función tendrá por defecto el valor \(pri_{default}\)</p><p>Al escoger un proceso de la lista \(ready\), se deberá escoger alguno de los de mayor prioridad, idealmente el con menor tiempo de ejecución en caso de empates.</p><h5>Casos especiales</h5><p>El <em>Scheduling</em> sería bastante simple si es que los procesos estuviesen siempre en estado \(running\) con una prioridad fija, pero esto no es así.</p><ul><li>Un proceso aumenta de prioridad sobrepasando la del proceso que ejecuta</li><li>El proceso que ejecuta disminuye de prioridad dejando de ser uno de los con mayor prioridad.</li><li>Aparece un proceso con mayor prioridad en la lista \(ready\)</li><ul><li>Proceso nuevo</li><li>Proceso que estaba en estado \(waiting\)</li></ul><li>Un proceso \(A\) espera a uno de menor prioridad \(C\).</li><ul><li>Puede haber un proceso \(B\) de prioridad intermedia que evita que \(C\) ejecute, logrando tener importancia aparente mayor que la de \(A\), ya que a través de la espera evita que \(A\) ejecute.</li></ul></ul><h5>Tests</h5><p>En <code>src/tests/threads/</code> pueden encontrar algunos tests para revisar esta tarea. (No dice que todos lo hacen..)</p><ul><li>priority-change</li><li>priority-preempt</li><li>priority-fifo</li><li>priority-donate-.*</li><ul><li>Sólo para <em>locks</em></li></ul></ul><p>Ejecución de tests,</p><pre><code class="hljs bash">cd /path/to/pintos/

cd src/threads/
make  # Root's make still works, but it does more work.

../utils/pintos -- run TestName  # where TestName is the basename of a test (priority-change.c => priority-change)</code></pre><h5>Estadísticas</h5><p>Es necesario obtener las siguientes medidas,</p><ul><li>Por Proceso</li><ul><li>Tiempo (o Quantums) y Veces que cada proceso está</li><ul><li>bloqueado</li><li>ejecutando</li></ul><li>Tiempo (o Quantums) en ready (pero no ejecutando)</li><li>Veces que</li><ul><li>Agotó su Quantum</li><li>Fué expropiado</li></ul></ul><li>Globales</li><ul><li>Cambios de contexto</li><li>Procesos que ejecutaron</li><li>Espera promedio en ready</li></ul></ul><p>El cálculo de estas debería ser lo más barato posible. Es posible medir diferencias con contadores globales para calcular rangos de tiempo y ocurrencias.</p></section></article></div><footer><div class="col-xs-12 col-md-8 col-md-offset-2"><p style="padding-top:4em;">Sistemas Operativos y Redes</p><p>Departamento de Ciencia de la Computación</p><p>Pontificia Universidad Católica de Chile</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0-alpha1/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.min.css"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jasny-bootstrap/3.1.3/js/jasny-bootstrap.min.js"></script><script>renderMathInElement(document.body)</script></body></html>